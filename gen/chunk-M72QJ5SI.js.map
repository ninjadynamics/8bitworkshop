{
  "version": 3,
  "sources": ["../node_modules/split.js/dist/split.js", "../src/common/toolbar.ts"],
  "sourcesContent": ["/*! Split.js - v1.6.5 */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Split = factory());\n}(this, (function () { 'use strict';\n\n    // The programming goals of Split.js are to deliver readable, understandable and\n    // maintainable code, while at the same time manually optimizing for tiny minified file size,\n    // browser compatibility without additional requirements\n    // and very few assumptions about the user's page layout.\n    var global = typeof window !== 'undefined' ? window : null;\n    var ssr = global === null;\n    var document = !ssr ? global.document : undefined;\n\n    // Save a couple long function names that are used frequently.\n    // This optimization saves around 400 bytes.\n    var addEventListener = 'addEventListener';\n    var removeEventListener = 'removeEventListener';\n    var getBoundingClientRect = 'getBoundingClientRect';\n    var gutterStartDragging = '_a';\n    var aGutterSize = '_b';\n    var bGutterSize = '_c';\n    var HORIZONTAL = 'horizontal';\n    var NOOP = function () { return false; };\n\n    // Helper function determines which prefixes of CSS calc we need.\n    // We only need to do this once on startup, when this anonymous function is called.\n    //\n    // Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n    // http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\n    var calc = ssr\n        ? 'calc'\n        : ((['', '-webkit-', '-moz-', '-o-']\n              .filter(function (prefix) {\n                  var el = document.createElement('div');\n                  el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n                  return !!el.style.length\n              })\n              .shift()) + \"calc\");\n\n    // Helper function checks if its argument is a string-like type\n    var isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n    // Helper function allows elements and string selectors to be used\n    // interchangeably. In either case an element is returned. This allows us to\n    // do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\n    var elementOrSelector = function (el) {\n        if (isString(el)) {\n            var ele = document.querySelector(el);\n            if (!ele) {\n                throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n            }\n            return ele\n        }\n\n        return el\n    };\n\n    // Helper function gets a property from the properties object, with a default fallback\n    var getOption = function (options, propName, def) {\n        var value = options[propName];\n        if (value !== undefined) {\n            return value\n        }\n        return def\n    };\n\n    var getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n        if (isFirst) {\n            if (gutterAlign === 'end') {\n                return 0\n            }\n            if (gutterAlign === 'center') {\n                return gutterSize / 2\n            }\n        } else if (isLast) {\n            if (gutterAlign === 'start') {\n                return 0\n            }\n            if (gutterAlign === 'center') {\n                return gutterSize / 2\n            }\n        }\n\n        return gutterSize\n    };\n\n    // Default options\n    var defaultGutterFn = function (i, gutterDirection) {\n        var gut = document.createElement('div');\n        gut.className = \"gutter gutter-\" + gutterDirection;\n        return gut\n    };\n\n    var defaultElementStyleFn = function (dim, size, gutSize) {\n        var style = {};\n\n        if (!isString(size)) {\n            style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n        } else {\n            style[dim] = size;\n        }\n\n        return style\n    };\n\n    var defaultGutterStyleFn = function (dim, gutSize) {\n        var obj;\n\n        return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n    };\n\n    // The main function to initialize a split. Split.js thinks about each pair\n    // of elements as an independant pair. Dragging the gutter between two elements\n    // only changes the dimensions of elements in that pair. This is key to understanding\n    // how the following functions operate, since each function is bound to a pair.\n    //\n    // A pair object is shaped like this:\n    //\n    // {\n    //     a: DOM element,\n    //     b: DOM element,\n    //     aMin: Number,\n    //     bMin: Number,\n    //     dragging: Boolean,\n    //     parent: DOM element,\n    //     direction: 'horizontal' | 'vertical'\n    // }\n    //\n    // The basic sequence:\n    //\n    // 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    //    A lot of the behavior in the rest of the library is paramatized down to\n    //    rely on CSS strings and classes.\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // 4. Loop through the elements while pairing them off. Every pair gets an\n    //    `pair` object and a gutter.\n    // 5. Actually size the pair elements, insert gutters and attach event listeners.\n    var Split = function (idsOption, options) {\n        if ( options === void 0 ) options = {};\n\n        if (ssr) { return {} }\n\n        var ids = idsOption;\n        var dimension;\n        var clientAxis;\n        var position;\n        var positionEnd;\n        var clientSize;\n        var elements;\n\n        // Allow HTMLCollection to be used as an argument when supported\n        if (Array.from) {\n            ids = Array.from(ids);\n        }\n\n        // All DOM elements in the split should have a common parent. We can grab\n        // the first elements parent and hope users read the docs because the\n        // behavior will be whacky otherwise.\n        var firstElement = elementOrSelector(ids[0]);\n        var parent = firstElement.parentNode;\n        var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n        var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n        // Set default options.sizes to equal percentages of the parent element.\n        var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n        // Standardize minSize and maxSize to an array if it isn't already.\n        // This allows minSize and maxSize to be passed as a number.\n        var minSize = getOption(options, 'minSize', 100);\n        var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n        var maxSize = getOption(options, 'maxSize', Infinity);\n        var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n        // Get other options\n        var expandToMin = getOption(options, 'expandToMin', false);\n        var gutterSize = getOption(options, 'gutterSize', 10);\n        var gutterAlign = getOption(options, 'gutterAlign', 'center');\n        var snapOffset = getOption(options, 'snapOffset', 30);\n        var snapOffsets = Array.isArray(snapOffset) ? snapOffset : ids.map(function () { return snapOffset; });\n        var dragInterval = getOption(options, 'dragInterval', 1);\n        var direction = getOption(options, 'direction', HORIZONTAL);\n        var cursor = getOption(\n            options,\n            'cursor',\n            direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n        );\n        var gutter = getOption(options, 'gutter', defaultGutterFn);\n        var elementStyle = getOption(\n            options,\n            'elementStyle',\n            defaultElementStyleFn\n        );\n        var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n        // 2. Initialize a bunch of strings based on the direction we're splitting.\n        // A lot of the behavior in the rest of the library is paramatized down to\n        // rely on CSS strings and classes.\n        if (direction === HORIZONTAL) {\n            dimension = 'width';\n            clientAxis = 'clientX';\n            position = 'left';\n            positionEnd = 'right';\n            clientSize = 'clientWidth';\n        } else if (direction === 'vertical') {\n            dimension = 'height';\n            clientAxis = 'clientY';\n            position = 'top';\n            positionEnd = 'bottom';\n            clientSize = 'clientHeight';\n        }\n\n        // 3. Define the dragging helper functions, and a few helpers to go with them.\n        // Each helper is bound to a pair object that contains its metadata. This\n        // also makes it easy to store references to listeners that that will be\n        // added and removed.\n        //\n        // Even though there are no other functions contained in them, aliasing\n        // this to self saves 50 bytes or so since it's used so frequently.\n        //\n        // The pair object saves metadata like dragging state, position and\n        // event listener references.\n\n        function setElementSize(el, size, gutSize, i) {\n            // Split.js allows setting sizes via numbers (ideally), or if you must,\n            // by string, like '300px'. This is less than ideal, because it breaks\n            // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n            // make sure you calculate the gutter size by hand.\n            var style = elementStyle(dimension, size, gutSize, i);\n\n            Object.keys(style).forEach(function (prop) {\n                // eslint-disable-next-line no-param-reassign\n                el.style[prop] = style[prop];\n            });\n        }\n\n        function setGutterSize(gutterElement, gutSize, i) {\n            var style = gutterStyle(dimension, gutSize, i);\n\n            Object.keys(style).forEach(function (prop) {\n                // eslint-disable-next-line no-param-reassign\n                gutterElement.style[prop] = style[prop];\n            });\n        }\n\n        function getSizes() {\n            return elements.map(function (element) { return element.size; })\n        }\n\n        // Supports touch events, but not multitouch, so only the first\n        // finger `touches[0]` is counted.\n        function getMousePosition(e) {\n            if ('touches' in e) { return e.touches[0][clientAxis] }\n            return e[clientAxis]\n        }\n\n        // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n        // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n        // which allows the viewport to be resized without additional logic.\n        // Element a's size is the same as offset. b's size is total size - a size.\n        // Both sizes are calculated from the initial parent percentage,\n        // then the gutter size is subtracted.\n        function adjust(offset) {\n            var a = elements[this.a];\n            var b = elements[this.b];\n            var percentage = a.size + b.size;\n\n            a.size = (offset / this.size) * percentage;\n            b.size = percentage - (offset / this.size) * percentage;\n\n            setElementSize(a.element, a.size, this[aGutterSize], a.i);\n            setElementSize(b.element, b.size, this[bGutterSize], b.i);\n        }\n\n        // drag, where all the magic happens. The logic is really quite simple:\n        //\n        // 1. Ignore if the pair is not dragging.\n        // 2. Get the offset of the event.\n        // 3. Snap offset to min if within snappable range (within min + snapOffset).\n        // 4. Actually adjust each element in the pair to offset.\n        //\n        // ---------------------------------------------------------------------\n        // |    | <- a.minSize               ||              b.minSize -> |    |\n        // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n        // |    |  |                         ||                        |  |    |\n        // |    |  |                         ||                        |  |    |\n        // ---------------------------------------------------------------------\n        // | <- this.start                                        this.size -> |\n        function drag(e) {\n            var offset;\n            var a = elements[this.a];\n            var b = elements[this.b];\n\n            if (!this.dragging) { return }\n\n            // Get the offset of the event from the first side of the\n            // pair `this.start`. Then offset by the initial position of the\n            // mouse compared to the gutter size.\n            offset =\n                getMousePosition(e) -\n                this.start +\n                (this[aGutterSize] - this.dragOffset);\n\n            if (dragInterval > 1) {\n                offset = Math.round(offset / dragInterval) * dragInterval;\n            }\n\n            // If within snapOffset of min or max, set offset to min or max.\n            // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n            // Include the appropriate gutter sizes to prevent overflows.\n            if (offset <= a.minSize + a.snapOffset + this[aGutterSize]) {\n                offset = a.minSize + this[aGutterSize];\n            } else if (\n                offset >=\n                this.size - (b.minSize + b.snapOffset + this[bGutterSize])\n            ) {\n                offset = this.size - (b.minSize + this[bGutterSize]);\n            }\n\n            if (offset >= a.maxSize - a.snapOffset + this[aGutterSize]) {\n                offset = a.maxSize + this[aGutterSize];\n            } else if (\n                offset <=\n                this.size - (b.maxSize - b.snapOffset + this[bGutterSize])\n            ) {\n                offset = this.size - (b.maxSize + this[bGutterSize]);\n            }\n\n            // Actually adjust the size.\n            adjust.call(this, offset);\n\n            // Call the drag callback continously. Don't do anything too intensive\n            // in this callback.\n            getOption(options, 'onDrag', NOOP)(getSizes());\n        }\n\n        // Cache some important sizes when drag starts, so we don't have to do that\n        // continously:\n        //\n        // `size`: The total size of the pair. First + second + first gutter + second gutter.\n        // `start`: The leading side of the first element.\n        //\n        // ------------------------------------------------\n        // |      aGutterSize -> |||                      |\n        // |                     |||                      |\n        // |                     |||                      |\n        // |                     ||| <- bGutterSize       |\n        // ------------------------------------------------\n        // | <- start                             size -> |\n        function calculateSizes() {\n            // Figure out the parent size minus padding.\n            var a = elements[this.a].element;\n            var b = elements[this.b].element;\n\n            var aBounds = a[getBoundingClientRect]();\n            var bBounds = b[getBoundingClientRect]();\n\n            this.size =\n                aBounds[dimension] +\n                bBounds[dimension] +\n                this[aGutterSize] +\n                this[bGutterSize];\n            this.start = aBounds[position];\n            this.end = aBounds[positionEnd];\n        }\n\n        function innerSize(element) {\n            // Return nothing if getComputedStyle is not supported (< IE9)\n            // Or if parent element has no layout yet\n            if (!getComputedStyle) { return null }\n\n            var computedStyle = getComputedStyle(element);\n\n            if (!computedStyle) { return null }\n\n            var size = element[clientSize];\n\n            if (size === 0) { return null }\n\n            if (direction === HORIZONTAL) {\n                size -=\n                    parseFloat(computedStyle.paddingLeft) +\n                    parseFloat(computedStyle.paddingRight);\n            } else {\n                size -=\n                    parseFloat(computedStyle.paddingTop) +\n                    parseFloat(computedStyle.paddingBottom);\n            }\n\n            return size\n        }\n\n        // When specifying percentage sizes that are less than the computed\n        // size of the element minus the gutter, the lesser percentages must be increased\n        // (and decreased from the other elements) to make space for the pixels\n        // subtracted by the gutters.\n        function trimToMin(sizesToTrim) {\n            // Try to get inner size of parent element.\n            // If it's no supported, return original sizes.\n            var parentSize = innerSize(parent);\n            if (parentSize === null) {\n                return sizesToTrim\n            }\n\n            if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n                return sizesToTrim\n            }\n\n            // Keep track of the excess pixels, the amount of pixels over the desired percentage\n            // Also keep track of the elements with pixels to spare, to decrease after if needed\n            var excessPixels = 0;\n            var toSpare = [];\n\n            var pixelSizes = sizesToTrim.map(function (size, i) {\n                // Convert requested percentages to pixel sizes\n                var pixelSize = (parentSize * size) / 100;\n                var elementGutterSize = getGutterSize(\n                    gutterSize,\n                    i === 0,\n                    i === sizesToTrim.length - 1,\n                    gutterAlign\n                );\n                var elementMinSize = minSizes[i] + elementGutterSize;\n\n                // If element is too smal, increase excess pixels by the difference\n                // and mark that it has no pixels to spare\n                if (pixelSize < elementMinSize) {\n                    excessPixels += elementMinSize - pixelSize;\n                    toSpare.push(0);\n                    return elementMinSize\n                }\n\n                // Otherwise, mark the pixels it has to spare and return it's original size\n                toSpare.push(pixelSize - elementMinSize);\n                return pixelSize\n            });\n\n            // If nothing was adjusted, return the original sizes\n            if (excessPixels === 0) {\n                return sizesToTrim\n            }\n\n            return pixelSizes.map(function (pixelSize, i) {\n                var newPixelSize = pixelSize;\n\n                // While there's still pixels to take, and there's enough pixels to spare,\n                // take as many as possible up to the total excess pixels\n                if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                    var takenPixels = Math.min(\n                        excessPixels,\n                        toSpare[i] - excessPixels\n                    );\n\n                    // Subtract the amount taken for the next iteration\n                    excessPixels -= takenPixels;\n                    newPixelSize = pixelSize - takenPixels;\n                }\n\n                // Return the pixel size adjusted as a percentage\n                return (newPixelSize / parentSize) * 100\n            })\n        }\n\n        // stopDragging is very similar to startDragging in reverse.\n        function stopDragging() {\n            var self = this;\n            var a = elements[self.a].element;\n            var b = elements[self.b].element;\n\n            if (self.dragging) {\n                getOption(options, 'onDragEnd', NOOP)(getSizes());\n            }\n\n            self.dragging = false;\n\n            // Remove the stored event listeners. This is why we store them.\n            global[removeEventListener]('mouseup', self.stop);\n            global[removeEventListener]('touchend', self.stop);\n            global[removeEventListener]('touchcancel', self.stop);\n            global[removeEventListener]('mousemove', self.move);\n            global[removeEventListener]('touchmove', self.move);\n\n            // Clear bound function references\n            self.stop = null;\n            self.move = null;\n\n            a[removeEventListener]('selectstart', NOOP);\n            a[removeEventListener]('dragstart', NOOP);\n            b[removeEventListener]('selectstart', NOOP);\n            b[removeEventListener]('dragstart', NOOP);\n\n            a.style.userSelect = '';\n            a.style.webkitUserSelect = '';\n            a.style.MozUserSelect = '';\n            a.style.pointerEvents = '';\n\n            b.style.userSelect = '';\n            b.style.webkitUserSelect = '';\n            b.style.MozUserSelect = '';\n            b.style.pointerEvents = '';\n\n            self.gutter.style.cursor = '';\n            self.parent.style.cursor = '';\n            document.body.style.cursor = '';\n        }\n\n        // startDragging calls `calculateSizes` to store the inital size in the pair object.\n        // It also adds event listeners for mouse/touch events,\n        // and prevents selection while dragging so avoid the selecting text.\n        function startDragging(e) {\n            // Right-clicking can't start dragging.\n            if ('button' in e && e.button !== 0) {\n                return\n            }\n\n            // Alias frequently used variables to save space. 200 bytes.\n            var self = this;\n            var a = elements[self.a].element;\n            var b = elements[self.b].element;\n\n            // Call the onDragStart callback.\n            if (!self.dragging) {\n                getOption(options, 'onDragStart', NOOP)(getSizes());\n            }\n\n            // Don't actually drag the element. We emulate that in the drag function.\n            e.preventDefault();\n\n            // Set the dragging property of the pair object.\n            self.dragging = true;\n\n            // Create two event listeners bound to the same pair object and store\n            // them in the pair object.\n            self.move = drag.bind(self);\n            self.stop = stopDragging.bind(self);\n\n            // All the binding. `window` gets the stop events in case we drag out of the elements.\n            global[addEventListener]('mouseup', self.stop);\n            global[addEventListener]('touchend', self.stop);\n            global[addEventListener]('touchcancel', self.stop);\n            global[addEventListener]('mousemove', self.move);\n            global[addEventListener]('touchmove', self.move);\n\n            // Disable selection. Disable!\n            a[addEventListener]('selectstart', NOOP);\n            a[addEventListener]('dragstart', NOOP);\n            b[addEventListener]('selectstart', NOOP);\n            b[addEventListener]('dragstart', NOOP);\n\n            a.style.userSelect = 'none';\n            a.style.webkitUserSelect = 'none';\n            a.style.MozUserSelect = 'none';\n            a.style.pointerEvents = 'none';\n\n            b.style.userSelect = 'none';\n            b.style.webkitUserSelect = 'none';\n            b.style.MozUserSelect = 'none';\n            b.style.pointerEvents = 'none';\n\n            // Set the cursor at multiple levels\n            self.gutter.style.cursor = cursor;\n            self.parent.style.cursor = cursor;\n            document.body.style.cursor = cursor;\n\n            // Cache the initial sizes of the pair.\n            calculateSizes.call(self);\n\n            // Determine the position of the mouse compared to the gutter\n            self.dragOffset = getMousePosition(e) - self.end;\n        }\n\n        // adjust sizes to ensure percentage is within min size and gutter.\n        sizes = trimToMin(sizes);\n\n        // 5. Create pair and element objects. Each pair has an index reference to\n        // elements `a` and `b` of the pair (first and second elements).\n        // Loop through the elements while pairing them off. Every pair gets a\n        // `pair` object and a gutter.\n        //\n        // Basic logic:\n        //\n        // - Starting with the second element `i > 0`, create `pair` objects with\n        //   `a = i - 1` and `b = i`\n        // - Set gutter sizes based on the _pair_ being first/last. The first and last\n        //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n        // - Create gutter elements and add event listeners.\n        // - Set the size of the elements, minus the gutter sizes.\n        //\n        // -----------------------------------------------------------------------\n        // |     i=0     |         i=1         |        i=2       |      i=3     |\n        // |             |                     |                  |              |\n        // |           pair 0                pair 1             pair 2           |\n        // |             |                     |                  |              |\n        // -----------------------------------------------------------------------\n        var pairs = [];\n        elements = ids.map(function (id, i) {\n            // Create the element object.\n            var element = {\n                element: elementOrSelector(id),\n                size: sizes[i],\n                minSize: minSizes[i],\n                maxSize: maxSizes[i],\n                snapOffset: snapOffsets[i],\n                i: i,\n            };\n\n            var pair;\n\n            if (i > 0) {\n                // Create the pair object with its metadata.\n                pair = {\n                    a: i - 1,\n                    b: i,\n                    dragging: false,\n                    direction: direction,\n                    parent: parent,\n                };\n\n                pair[aGutterSize] = getGutterSize(\n                    gutterSize,\n                    i - 1 === 0,\n                    false,\n                    gutterAlign\n                );\n                pair[bGutterSize] = getGutterSize(\n                    gutterSize,\n                    false,\n                    i === ids.length - 1,\n                    gutterAlign\n                );\n\n                // if the parent has a reverse flex-direction, switch the pair elements.\n                if (\n                    parentFlexDirection === 'row-reverse' ||\n                    parentFlexDirection === 'column-reverse'\n                ) {\n                    var temp = pair.a;\n                    pair.a = pair.b;\n                    pair.b = temp;\n                }\n            }\n\n            // Determine the size of the current element. IE8 is supported by\n            // staticly assigning sizes without draggable gutters. Assigns a string\n            // to `size`.\n            //\n            // Create gutter elements for each pair.\n            if (i > 0) {\n                var gutterElement = gutter(i, direction, element.element);\n                setGutterSize(gutterElement, gutterSize, i);\n\n                // Save bound event listener for removal later\n                pair[gutterStartDragging] = startDragging.bind(pair);\n\n                // Attach bound event listener\n                gutterElement[addEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                gutterElement[addEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n\n                parent.insertBefore(gutterElement, element.element);\n\n                pair.gutter = gutterElement;\n            }\n\n            setElementSize(\n                element.element,\n                element.size,\n                getGutterSize(\n                    gutterSize,\n                    i === 0,\n                    i === ids.length - 1,\n                    gutterAlign\n                ),\n                i\n            );\n\n            // After the first iteration, and we have a pair object, append it to the\n            // list of pairs.\n            if (i > 0) {\n                pairs.push(pair);\n            }\n\n            return element\n        });\n\n        function adjustToMin(element) {\n            var isLast = element.i === pairs.length;\n            var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n            calculateSizes.call(pair);\n\n            var size = isLast\n                ? pair.size - element.minSize - pair[bGutterSize]\n                : element.minSize + pair[aGutterSize];\n\n            adjust.call(pair, size);\n        }\n\n        elements.forEach(function (element) {\n            var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n            if (computedSize < element.minSize) {\n                if (expandToMin) {\n                    adjustToMin(element);\n                } else {\n                    // eslint-disable-next-line no-param-reassign\n                    element.minSize = computedSize;\n                }\n            }\n        });\n\n        function setSizes(newSizes) {\n            var trimmed = trimToMin(newSizes);\n            trimmed.forEach(function (newSize, i) {\n                if (i > 0) {\n                    var pair = pairs[i - 1];\n\n                    var a = elements[pair.a];\n                    var b = elements[pair.b];\n\n                    a.size = trimmed[i - 1];\n                    b.size = newSize;\n\n                    setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                    setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n                }\n            });\n        }\n\n        function destroy(preserveStyles, preserveGutter) {\n            pairs.forEach(function (pair) {\n                if (preserveGutter !== true) {\n                    pair.parent.removeChild(pair.gutter);\n                } else {\n                    pair.gutter[removeEventListener](\n                        'mousedown',\n                        pair[gutterStartDragging]\n                    );\n                    pair.gutter[removeEventListener](\n                        'touchstart',\n                        pair[gutterStartDragging]\n                    );\n                }\n\n                if (preserveStyles !== true) {\n                    var style = elementStyle(\n                        dimension,\n                        pair.a.size,\n                        pair[aGutterSize]\n                    );\n\n                    Object.keys(style).forEach(function (prop) {\n                        elements[pair.a].element.style[prop] = '';\n                        elements[pair.b].element.style[prop] = '';\n                    });\n                }\n            });\n        }\n\n        return {\n            setSizes: setSizes,\n            getSizes: getSizes,\n            collapse: function collapse(i) {\n                adjustToMin(elements[i]);\n            },\n            destroy: destroy,\n            parent: parent,\n            pairs: pairs,\n        }\n    };\n\n    return Split;\n\n})));\n", "\nimport Mousetrap = require('mousetrap');\n\n/// TOOLBAR\n\nexport class Toolbar {\n    span : JQuery;\n    grp : JQuery;\n    mousetrap;\n    boundkeys = [];\n    \n    constructor(parentDiv:HTMLElement, focusDiv:HTMLElement) {\n      this.mousetrap = focusDiv ? new Mousetrap(focusDiv) : Mousetrap;\n      this.span = $(document.createElement(\"span\")).addClass(\"btn_toolbar\");\n      parentDiv.appendChild(this.span[0]);\n      this.newGroup();\n    }\n    destroy() {\n      if (this.span) {\n        this.span.remove();\n        this.span = null;\n      }\n      if (this.mousetrap) {\n        for (var key of this.boundkeys) {\n          this.mousetrap.unbind(key);\n        }\n        this.mousetrap = null;\n      }\n    }\n    newGroup() {\n      return this.grp = $(document.createElement(\"span\")).addClass(\"btn_group\").appendTo(this.span).hide();\n    }\n    add(key:string, alttext:string, icon:string, fn:(e,combo) => void) {\n      var btn = null;\n      if (icon) {\n        btn = $(document.createElement(\"button\")).addClass(\"btn\");\n        if (icon.startsWith('glyphicon')) {\n          icon = '<span class=\"glyphicon ' + icon + '\" aria-hidden=\"true\"></span>';\n        }\n        btn.html(icon);\n        btn.prop(\"title\", key ? (alttext+\" (\"+key+\")\") : alttext);\n        btn.click(fn);\n        this.grp.append(btn).show();\n      }\n      if (key) {\n        this.mousetrap.bind(key, fn);\n        this.boundkeys.push(key);\n      }\n      return btn;\n    }\n    \n  }\n  "],
  "mappings": "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",
  "names": []
}
