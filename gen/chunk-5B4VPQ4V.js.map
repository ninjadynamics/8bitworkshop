{
  "version": 3,
  "sources": ["../src/common/recorder.ts"],
  "sourcesContent": ["\nimport { Platform, EmuState, EmuControlsState, EmuRecorder } from \"./baseplatform\";\nimport { getNoiseSeed, setNoiseSeed } from \"./emu\";\n\n// RECORDER\n\ntype FrameRec = {controls:EmuControlsState, seed:number};\n\nexport class StateRecorderImpl implements EmuRecorder {\n  \n    checkpointInterval : number = 10;\n    callbackStateChanged : () => void;\n    callbackNewCheckpoint : (state:EmuState) => void;\n    maxCheckpoints : number = 300;\n    \n    platform : Platform;\n    checkpoints : EmuState[];\n    framerecs : FrameRec[];\n    frameCount : number;\n    lastSeekFrame : number;\n    lastSeekStep : number;\n    lastStepCount : number;\n    \n    constructor(platform : Platform) {\n        this.reset();\n        this.platform = platform;\n    }\n\n    reset() {\n        this.checkpoints = [];\n        this.framerecs = [];\n        this.frameCount = 0;\n        this.lastSeekFrame = 0;\n        this.lastSeekStep = 0;\n        this.lastStepCount = 0;\n        if (this.callbackStateChanged) this.callbackStateChanged();\n    }\n\n    frameRequested() : boolean {\n        var controls = {\n          controls:this.platform.saveControlsState(),\n          seed:getNoiseSeed()\n        };\n        var requested = false;\n        // are we replaying? then we don't need to save a frame, just replace controls\n        if (this.lastSeekFrame < this.frameCount) {\n            this.loadControls(this.lastSeekFrame);\n        } else {\n            // record the control state, if available\n            if (this.platform.saveControlsState) {\n                this.framerecs.push(controls);\n            }\n            // time to save next frame?\n            requested = (this.frameCount++ % this.checkpointInterval) == 0;\n        }\n        this.lastSeekFrame++;\n        this.lastSeekStep = 0;\n        if (this.callbackStateChanged) this.callbackStateChanged();\n        return requested;\n    }\n    \n    numFrames() : number {\n        return this.frameCount;\n    }\n    \n    currentFrame() : number {\n        return this.lastSeekFrame;\n    }\n\n    currentStep() : number {\n      return this.lastSeekStep;\n  }\n\n    recordFrame(state : EmuState) {\n        this.checkpoints.push(state);\n        if (this.callbackNewCheckpoint) this.callbackNewCheckpoint(state);\n        // checkpoints full?\n        if (this.checkpoints.length > this.maxCheckpoints) {\n            this.checkpoints.shift(); // remove 1st checkpoint\n            this.framerecs = this.framerecs.slice(this.checkpointInterval);\n            this.lastSeekFrame -= this.checkpointInterval;\n            this.frameCount -= this.checkpointInterval;\n            if (this.callbackStateChanged) this.callbackStateChanged();\n        }\n    }\n\n    getStateAtOrBefore(frame : number) : {frame : number, state : EmuState} {\n        // initial frame?\n        if (frame <= 0 && this.checkpoints.length > 0)\n          return {frame:0, state:this.checkpoints[0]};\n\n        var bufidx = Math.floor(frame / this.checkpointInterval);\n        var foundidx = bufidx < this.checkpoints.length ? bufidx : this.checkpoints.length-1;\n        var foundframe = foundidx * this.checkpointInterval;\n        return {frame:foundframe, state:this.checkpoints[foundidx]};\n    }\n\n    loadFrame(seekframe : number, seekstep? : number) : number {\n        seekframe |= 0;\n        seekstep |= 0;\n        if (seekframe == this.lastSeekFrame && seekstep == this.lastSeekStep) {\n            return seekframe; // already set to this frame\n        }\n        // TODO: what if < 1?\n        let {frame,state} = this.getStateAtOrBefore(seekframe-1);\n        if (state) {\n            var numSteps = 0;\n            this.platform.pause();\n            this.platform.loadState(state);\n            // seek to frame index\n            while (frame < seekframe) {\n                if (frame < this.framerecs.length) {\n                    this.loadControls(frame);\n                }\n                frame++;\n                numSteps = this.platform.advance(frame < seekframe); // TODO: infinite loop?\n            }\n            // TODO: if first frame, we must figure out # of steps\n            if (frame == 0) {\n              numSteps = this.platform.advance(true);\n              this.platform.loadState(state);\n            }\n            // seek to step index\n            // TODO: what if advance() returns clocks, but steps use insns?\n            if (seekstep > 0 && this.platform.advanceFrameClock) { \n              seekstep = this.platform.advanceFrameClock(null, seekstep);\n            }\n            // record new values\n            this.lastSeekFrame = seekframe;\n            this.lastSeekStep = seekstep;\n            this.lastStepCount = numSteps;\n            return seekframe;\n        } else {\n            return -1;\n        }\n    }\n    \n    loadControls(frame : number) {\n        if (this.platform.loadControlsState)\n            this.platform.loadControlsState(this.framerecs[frame].controls);\n        setNoiseSeed(this.framerecs[frame].seed);\n    }\n    \n    getLastCheckpoint() : EmuState {\n        return this.checkpoints.length && this.checkpoints[this.checkpoints.length-1];\n    }\n}\n\n/////\n\nimport { Probeable, ProbeAll } from \"./devices\";\n\nexport enum ProbeFlags {\n  CLOCKS\t  = 0x00000000,\n  EXECUTE\t  = 0x01000000,\n  HAS_VALUE = 0x10000000,\n  MEM_READ\t= 0x12000000,\n  MEM_WRITE\t= 0x13000000,\n  IO_READ\t  = 0x14000000,\n  IO_WRITE\t= 0x15000000,\n  VRAM_READ\t= 0x16000000,\n  VRAM_WRITE= 0x17000000,\n  INTERRUPT\t= 0x08000000,\n  ILLEGAL\t  = 0x09000000,\n  SP_PUSH\t  = 0x0a000000,\n  SP_POP\t  = 0x0b000000,\n  SCANLINE\t= 0x7e000000,\n  FRAME\t\t  = 0x7f000000,\n}\n\nclass ProbeFrame {\n  data : Uint32Array;\n  len : number;\n}\n\nexport class ProbeRecorder implements ProbeAll {\n\n  m : Probeable;      // machine to probe\n  buf : Uint32Array;  // buffer\n  idx : number = 0;   // index into buffer\n  sl : number = 0;    // scanline\n  cur_sp = -1;        // last stack pointer\n  singleFrame : boolean = true; // clear between frames\n\n  constructor(m:Probeable, buflen?:number) {\n    this.m = m;\n    this.reset(buflen || 0x100000);\n  }\n  start() {\n    this.m.connectProbe(this);\n  }\n  stop() {\n    this.m.connectProbe(null);\n  }\n  reset(newbuflen? : number) {\n    if (newbuflen) this.buf = new Uint32Array(newbuflen);\n    this.sl = 0;\n    this.cur_sp = -1;\n    this.clear();\n  }\n  clear() {\n    this.idx = 0;\n  }\n  logData(a:number) {\n    this.log(a);\n  }\n  log(a:number) {\n    // TODO: coalesce READ and EXECUTE and PUSH/POP\n    if (this.idx >= this.buf.length) return;\n    this.buf[this.idx++] = a;\n  }\n  relog(a:number) {\n    this.buf[this.idx-1] = a;\n  }\n  lastOp() {\n    if (this.idx > 0)\n      return this.buf[this.idx-1] & 0xff000000;\n    else\n      return -1;\n  }\n  lastAddr() {\n    if (this.idx > 0)\n      return this.buf[this.idx-1] & 0xffffff;\n    else\n      return -1;\n  }\n  addLogBuffer(src: Uint32Array) {\n    if (this.idx + src.length > this.buf.length) {\n      src = src.slice(0, this.buf.length - this.idx);\n    }\n    this.buf.set(src, this.idx);\n    this.idx += src.length;\n}\n  logClocks(clocks:number) {\n    clocks |= 0;\n    if (clocks > 0) {\n      if (this.lastOp() == ProbeFlags.CLOCKS)\n        this.relog((this.lastAddr() + clocks) | ProbeFlags.CLOCKS); // coalesce clocks\n      else\n        this.log(clocks | ProbeFlags.CLOCKS);\n    }\n  }\n  logNewScanline() {\n    this.log(ProbeFlags.SCANLINE);\n    this.sl++;\n  }\n  logNewFrame() {\n    this.log(ProbeFlags.FRAME);\n    this.sl = 0;\n    if (this.singleFrame) this.clear();\n  }\n  logExecute(address:number, SP:number) {\n    // record stack pushes/pops (from last instruction)\n    if (this.cur_sp !== SP) {\n      if (SP < this.cur_sp) {\n        this.log(ProbeFlags.SP_PUSH | SP);\n      }\n      if (SP > this.cur_sp) {\n        this.log(ProbeFlags.SP_POP | SP);\n      }\n      this.cur_sp = SP;\n    }\n    this.log(address | ProbeFlags.EXECUTE);\n  }\n  logInterrupt(type:number) {\n    this.log(type | ProbeFlags.INTERRUPT);\n  }\n  logValue(address:number, value:number, op:number) {\n    this.log((address & 0xffff) | ((value & 0xff)<<16) | op);\n  }\n  logRead(address:number, value:number) {\n    this.logValue(address, value, ProbeFlags.MEM_READ);\n  }\n  logWrite(address:number, value:number) {\n    this.logValue(address, value, ProbeFlags.MEM_WRITE);\n  }\n  logIORead(address:number, value:number) {\n    this.logValue(address, value, ProbeFlags.IO_READ);\n  }\n  logIOWrite(address:number, value:number) {\n    this.logValue(address, value, ProbeFlags.IO_WRITE);\n  }\n  logVRAMRead(address:number, value:number) {\n    this.logValue(address, value, ProbeFlags.VRAM_READ);\n  }\n  logVRAMWrite(address:number, value:number) {\n    this.logValue(address, value, ProbeFlags.VRAM_WRITE);\n  }\n  logIllegal(address:number) {\n    this.log(address | ProbeFlags.ILLEGAL);\n  }\n  countEvents(op : number) : number {\n    var count = 0;\n    for (var i=0; i<this.idx; i++) {\n      if ((this.buf[i] & 0xff000000) == op)\n        count++;\n    }\n    return count;\n  }\n  countClocks() : number {\n    var count = 0;\n    for (var i=0; i<this.idx; i++) {\n      if ((this.buf[i] & 0xff000000) == ProbeFlags.CLOCKS)\n        count += this.buf[i] & 0xffff;\n    }\n    return count;\n  }\n\n}\n"],
  "mappings": "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",
  "names": []
}
