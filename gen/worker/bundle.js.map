{
  "version": 3,
  "sources": ["../../src/common/util.ts", "../../src/common/basic/compiler.ts", "../../src/worker/tools/misc.ts", "../../src/worker/tools/cc65.ts", "../../src/worker/tools/dasm.ts", "../../src/worker/tools/sdcc.ts", "../../src/worker/assembler.ts", "../../src/common/hdl/hdltypes.ts", "../../src/common/hdl/vxmlparser.ts", "../../src/worker/tools/verilog.ts", "../../src/worker/tools/m6809.ts", "../../src/worker/tools/m6502.ts", "../../src/worker/tools/z80.ts", "../../src/worker/tools/x86.ts", "../../src/worker/tools/arm.ts", "../../src/common/tokenizer.ts", "../../src/common/ecs/binpack.ts", "../../src/common/ecs/ecs.ts", "../../src/common/ecs/decoder.ts", "../../src/common/ecs/compiler.ts", "../../src/worker/tools/ecs.ts", "../../src/worker/workermain.ts"],
  "sourcesContent": ["\nexport function lpad(s:string, n:number):string {\n  s += ''; // convert to string\n  while (s.length<n) s=\" \"+s;\n  return s;\n}\n\nexport function rpad(s:string, n:number):string {\n  s += ''; // convert to string\n  while (s.length<n) s+=\" \";\n  return s;\n}\n\nexport function byte2signed(b:number):number {\n  b &= 0xff;\n  return (b < 0x80) ? b : -(256-b);\n}\n\nexport function getFilenameForPath(s:string):string {\n  var toks = s.split('/');\n  return toks[toks.length-1];\n}\n\nexport function getFolderForPath(s:string):string {\n  return s.substring(0, s.lastIndexOf('/'));\n}\n\nexport function getFilenamePrefix(s:string):string {\n  var pos = s.lastIndexOf('.');\n  return (pos > 0) ? s.substr(0, pos) : s;\n}\n\nexport function hex(v:number, nd?:number) {\n  if (!nd) nd = 2;\n  if (nd == 8) {\n    return hex((v>>16)&0xffff,4) + hex(v&0xffff,4);\n  } else {\n    return toradix(v,nd,16);\n  }\n}\n\nexport function tobin(v:number, nd?:number) {\n  if (!nd) nd = 8;\n  return toradix(v,nd,2);\n}\n\nexport function toradix(v:number, nd:number, radix:number) {\n  try {\n    var s = v.toString(radix).toUpperCase();\n    while (s.length < nd)\n      s = \"0\" + s;\n    return s;\n  } catch (e) {\n    return v+\"\";\n  }\n}\n\nexport function arrayCompare(a:ArrayLike<any>, b:ArrayLike<any>):boolean {\n  if (a == null && b == null) return true;\n  if (a == null) return false;\n  if (b == null) return false;\n  if (a.length != b.length) return false;\n  for (var i=0; i<a.length; i++)\n    if (a[i] != b[i])\n      return false;\n  return true;\n}\n\nexport function invertMap(m:{}):{} {\n  var r = {};\n  if (m) {\n    for (var k in m) r[m[k]] = k;\n  }\n  return r;\n}\n\nexport function highlightDifferences(s1:string, s2:string):string {\n  var split1 = s1.split(/(\\S+\\s+)/).filter(function(n) {return n});\n  var split2 = s2.split(/(\\S+\\s+)/).filter(function(n) {return n});\n  var i = 0;\n  var j = 0;\n  var result = \"\";\n  while (i < split1.length && j < split2.length) {\n    var w1 = split1[i];\n    var w2 = split2[j];\n    if (w2 && w2.indexOf(\"\\n\") >= 0) {\n      while (i < s1.length && split1[i].indexOf(\"\\n\") < 0)\n        i++;\n    }\n    if (w1 != w2) {\n      w2 = '<span class=\"hilite\">' + w2 + '</span>';\n    }\n    result += w2;\n    i++;\n    j++;\n  }\n  while (j < split2.length) {\n      result += split2[j++];\n  }\n  return result;\n}\n\nexport function lzgmini() {\n\n  // Constants\n  var LZG_HEADER_SIZE = 16;\n  var LZG_METHOD_COPY = 0;\n  var LZG_METHOD_LZG1 = 1;\n\n  // LUT for decoding the copy length parameter\n  var LZG_LENGTH_DECODE_LUT = [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,\n                               20,21,22,23,24,25,26,27,28,29,35,48,72,128];\n\n  // Decoded data (produced by the decode() method)\n  var outdata = null;\n\n  // Calculate the checksum\n  var calcChecksum = function(data) {\n    var a = 1;\n    var b = 0;\n    var i = LZG_HEADER_SIZE;\n    while (i < data.length)\n    {\n      a = (a + (data[i] & 0xff)) & 0xffff;\n      b = (b + a) & 0xffff;\n      i++;\n    }\n    return (b << 16) | a;\n  }\n\n  // Decode LZG coded data. The function returns the size of the decoded data.\n  // Use any of the get* methods to retrieve the decoded data.\n  this.decode = function(data:number[]):number[] {\n    // Start by clearing the decompressed array in this object\n    outdata = null;\n\n    // Check magic ID\n    if ((data.length < LZG_HEADER_SIZE) || (data[0] != 76) ||\n         (data[1] != 90) || (data[2] != 71))\n    {\n      return null;\n    }\n    \n    // what's the length?\n    var uncomplen = data[6] | (data[5]<<8) | (data[4]<<16) | (data[3]<<24);\n\n    // Calculate & check the checksum\n    var checksum = ((data[11] & 0xff) << 24) |\n                   ((data[12] & 0xff) << 16) |\n                   ((data[13] & 0xff) << 8) |\n                   (data[14] & 0xff);\n    if (calcChecksum(data) != checksum)\n    {\n      return null;\n    }\n\n    var dst = new Array();\n    // Check which method to use\n    var method = data[15] & 0xff;\n    if (method == LZG_METHOD_LZG1)\n    {\n      // Get marker symbols\n      var m1 = data[16] & 0xff;\n      var m2 = data[17] & 0xff;\n      var m3 = data[18] & 0xff;\n      var m4 = data[19] & 0xff;\n\n      // Main decompression loop\n      var symbol, b, b2, b3, len, offset;\n      var dstlen = 0;\n      var k = LZG_HEADER_SIZE + 4;\n      var datalen = data.length;\n      while (k <= datalen)\n      {\n        symbol = data[k++] & 0xff;\n        if ((symbol != m1) && (symbol != m2) && (symbol != m3) && (symbol != m4))\n        {\n          // Literal copy\n          dst[dstlen++] = symbol;\n        }\n        else\n        {\n          b = data[k++] & 0xff;\n          if (b != 0)\n          {\n            // Decode offset / length parameters\n            if (symbol == m1)\n            {\n              // marker1 - \"Distant copy\"\n              len = LZG_LENGTH_DECODE_LUT[b & 0x1f];\n              b2 = data[k++] & 0xff;\n              b3 = data[k++] & 0xff;\n              offset = (((b & 0xe0) << 11) | (b2 << 8) | b3) + 2056;\n            }\n            else if (symbol == m2)\n            {\n              // marker2 - \"Medium copy\"\n              len = LZG_LENGTH_DECODE_LUT[b & 0x1f];\n              b2 = data[k++] & 0xff;\n              offset = (((b & 0xe0) << 3) | b2) + 8;\n            }\n            else if (symbol == m3)\n            {\n              // marker3 - \"Short copy\"\n              len = (b >> 6) + 3;\n              offset = (b & 63) + 8;\n            }\n            else\n            {\n              // marker4 - \"Near copy (incl. RLE)\"\n              len = LZG_LENGTH_DECODE_LUT[b & 0x1f];\n              offset = (b >> 5) + 1;\n            }\n\n            // Copy the corresponding data from the history window\n            for (i = 0; i < len; i++)\n            {\n              dst[dstlen] = dst[dstlen-offset];\n              dstlen++;\n            }\n          }\n          else\n          {\n            // Literal copy (single occurance of a marker symbol)\n            dst[dstlen++] = symbol;\n          }\n        }\n      }\n\n    }\n    else if (method == LZG_METHOD_COPY)\n    {\n      // Plain copy\n      var dstlen = 0;\n      var datalen = data.length;\n      for (var i = LZG_HEADER_SIZE; i < datalen; i++)\n      {\n        dst[dstlen++] = data[i] & 0xff;\n      }\n    }\n    else\n    {\n      // Unknown method\n      return null;\n    }\n    // Store the decompressed data in the lzgmini object for later retrieval\n    if (dst.length < uncomplen) return null; // data too short\n    outdata = dst.slice(0, uncomplen);\n    return outdata;\n  }\n\n  // Get the decoded byte array\n  this.getByteArray = function():number[]\n  {\n    return outdata;\n  }\n\n  // Get the decoded string from a Latin 1 (or ASCII) encoded array\n  this.getStringLatin1 = function():string {\n    return byteArrayToString(outdata);\n  }\n\n  // Get the decoded string from an UTF-8 encoded array\n  this.getStringUTF8 = function():string {\n    return byteArrayToUTF8(outdata);\n  }\n}\n\nexport function stringToByteArray(s:string) : Uint8Array {\n  var a = new Uint8Array(s.length);\n  for (var i=0; i<s.length; i++)\n    a[i] = s.charCodeAt(i);\n  return a;\n}\n\nexport function byteArrayToString(data : number[] | Uint8Array) : string {\n  var str = \"\";\n  if (data != null) {\n    var charLUT = new Array();\n    for (var i = 0; i < 256; ++i)\n      charLUT[i] = String.fromCharCode(i);\n    var len = data.length;\n    for (var i = 0; i < len; i++)\n      str += charLUT[data[i]];\n  }\n  return str;\n}\n\nexport function byteArrayToUTF8(data : number[] | Uint8Array) : string {\n  var str = \"\";\n  var charLUT = new Array();\n  for (var i = 0; i < 128; ++i)\n    charLUT[i] = String.fromCharCode(i);\n  var c;\n  var len = data.length;\n  for (var i = 0; i < len;) {\n    c = data[i++];\n    if (c < 128) {\n      str += charLUT[c];\n    } else {\n      if ((c >= 192) && (c < 224)) {\n        c = ((c & 31) << 6) | (data[i++] & 63);\n      } else {\n        c = ((c & 15) << 12) | ((data[i] & 63) << 6) | (data[i+1] & 63);\n        i += 2;\n        if (c == 0xfeff) continue; // ignore BOM\n      }\n      str += String.fromCharCode(c);\n    }\n  }\n  return str;\n}\n\nexport function removeBOM(s:string) {\n  if (s.charCodeAt(0) === 0xFEFF) {\n    s = s.substr(1);\n  }\n  return s;\n}\n\nexport function isProbablyBinary(path:string, data?:number[] | Uint8Array) : boolean {\n  var score = 0;\n  // check extensions\n  if (path) {\n    path = path.toUpperCase();\n    const BINEXTS = ['.CHR','.BIN','.DAT','.PAL','.NAM','.RLE','.LZ4','.NSF'];\n    for (var ext of BINEXTS) {\n      if (path.endsWith(ext)) score++;\n    }\n  }\n  // decode as UTF-8\n  for (var i = 0; i < (data?data.length:0);) {\n    let c = data[i++];\n    if ((c & 0x80) == 0) {\n      // more likely binary if we see a NUL or obscure control character\n      if (c < 9 || (c >= 14 && c < 26) || c == 0x7f) {\n        score++;\n        break;\n      }\n    } else {\n      // look for invalid unicode sequences\n      var nextra = 0;\n      if ((c & 0xe0) == 0xc0) nextra = 1;\n      else if ((c & 0xf0) == 0xe0) nextra = 2;\n      else if ((c & 0xf8) == 0xf0) nextra = 3;\n      else if (c < 0xa0) score++;\n      else if (c == 0xff) score++;\n      while (nextra--) {\n        if (i >= data.length || (data[i++] & 0xc0) != 0x80) {\n          score++;\n          break;\n        }\n      }\n    }\n  }\n  return score > 0;\n}\n\n// need to load liblzg.js first\nexport function compressLZG(em_module, inBuffer:number[], levelArg?:boolean) : Uint8Array {\n  var level = levelArg || 9;\n  var inLen = inBuffer.length;\n  var inPtr = em_module._malloc(inLen + 1);\n  for (var i = 0; i < inLen; i++) {\n      em_module.setValue(inPtr + i, inBuffer[i], 'i8');\n  }\n  var maxEncSize = em_module._LZG_MaxEncodedSize(inLen);\n  var outPtr = em_module._malloc(maxEncSize + 1);\n  var compLen = em_module.ccall('compress_lzg', 'number', ['number', 'number', 'number', 'number', 'number'], [level, inPtr, inLen, maxEncSize, outPtr]);\n  em_module._free(inPtr);\n  var outBuffer = new Uint8Array(compLen);\n  for (var i = 0; i < compLen; i++) {\n      outBuffer[i] = em_module.getValue(outPtr + i, 'i8');\n  }\n  em_module._free(outPtr);\n  return outBuffer;\n}\n\n// only does primitives, 1D arrays and no recursion\nexport function safe_extend(deep, dest, src) {\n  // TODO: deep ignored\n  for (var key in src) {\n    var val = src[key];\n    var type = typeof(val);\n    if (val === null || type == 'undefined') {\n      dest[key] = val;\n    } else if (type == 'function') {\n      // ignore function\n    } else if (type == 'object') {\n      if (val['slice']) { // array?\n        dest[key] = val.slice();\n      } else {\n        // ignore object\n      }\n    } else {\n      dest[key] = val;\n    }\n  }\n  return dest;\n}\n\nexport function printFlags(val:number, names:string[], r2l:boolean) {\n  var s = '';\n  for (var i=0; i<names.length; i++) {\n    if (names[i]) {\n      var bit = 1 << (r2l ? (names.length-1-i) : i);\n      if (i > 0) s += \" \";\n      s += (val & bit) ? names[i] : \"-\";\n    }\n  }\n  return s;\n}\n\nexport function rgb2bgr(x) {\n  return ((x&0xff)<<16) | ((x>>16)&0xff) | (x&0x00ff00);\n}\n\nexport function RGBA(r:number,g:number,b:number) {\n  return (r&0xff) | ((g&0xff)<<8) | ((b&0xff)<<16) | 0xff000000;\n}\n\nexport function clamp(minv:number, maxv:number, v:number) {\n  return (v < minv) ? minv : (v > maxv) ? maxv : v;\n}\n\nexport function safeident(s : string) : string {\n  return s.replace(/\\W+/g, \"_\");\n}\n\nexport function rle_unpack(src : Uint8Array) : Uint8Array {\n  var i = 0;\n  var tag = src[i++];\n  var dest = [];\n  var data = tag;\n  while (i < src.length) {\n    var ch = src[i++];\n    if (ch == tag) {\n      var count = src[i++];\n      for (var j=0; j<count; j++)\n        dest.push(data);\n      if (count == 0)\n        break;\n    } else {\n      data = ch;\n      dest.push(data);\n    }\n  }\n  return new Uint8Array(dest);\n}\n\n// firefox doesn't do GET with binary files\n// TODO: replace with fetch()?\nexport function getWithBinary(url:string, success:(text:string|Uint8Array)=>void, datatype:'text'|'arraybuffer') {\n  var oReq = new XMLHttpRequest();\n  oReq.open(\"GET\", url, true);\n  oReq.responseType = datatype;\n  oReq.onload = function (oEvent) {\n    if (oReq.status == 200) {\n      var data = oReq.response;\n      if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      }\n      success(data);\n    } else if (oReq.status == 404) {\n      success(null);\n    } else {\n      throw Error(\"Error \" + oReq.status + \" loading \" + url);\n    }\n  }\n  oReq.onerror = function (oEvent) {\n    success(null);\n  }\n  oReq.ontimeout = function (oEvent) {\n    throw Error(\"Timeout loading \" + url);\n  }\n  oReq.send(null);\n}\n\n// get platform ID without . emulator\nexport function getBasePlatform(platform : string) : string {\n  return platform.split('.')[0];\n}\n\n// get platform ID without - specialization\nfunction getRootPlatform(platform : string) : string {\n  return platform.split('-')[0];\n}\n\n// get platform ID without emulator or specialization\nexport function getRootBasePlatform(platform : string) : string {\n  return getRootPlatform(getBasePlatform(platform));\n}\n\nexport function isArray(obj: any) : obj is ArrayLike<any> {\n  return obj != null && (Array.isArray(obj) || isTypedArray(obj));\n}\n\nexport function isTypedArray(obj: any) : obj is ArrayLike<number> {\n  return obj != null && obj['BYTES_PER_ELEMENT'];\n}\n\nexport function convertDataToUint8Array(data: string|Uint8Array) : Uint8Array {\n  return (typeof data === 'string') ? stringToByteArray(data) : data;\n}\n\nexport function convertDataToString(data: string|Uint8Array) : string {\n  return (data instanceof Uint8Array) ? byteArrayToUTF8(data) : data;\n}\n\nexport function byteToASCII(b: number) : string {\n  if (b < 32)\n    return String.fromCharCode(b + 0x2400);\n  else\n    return String.fromCharCode(b);\n}\n\nexport function loadScript(scriptfn:string) : Promise<Event> {\n  return new Promise( (resolve, reject) => {\n    var script = document.createElement('script');\n    script.onload = resolve;\n    script.onerror = reject;\n    script.src = scriptfn;\n    document.getElementsByTagName('head')[0].appendChild(script);\n  });\n}\n\nexport function decodeQueryString(qs : string) : {} {\n  if (qs.startsWith('?')) qs = qs.substr(1);\n  var a = qs.split('&');\n  if (!a || a.length == 0)\n      return {};\n  var b = {};\n  for (var i = 0; i < a.length; ++i) {\n      var p = a[i].split('=', 2);\n      if (p.length == 1)\n          b[p[0]] = \"\";\n      else\n          b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n  }\n  return b;\n}\n\nexport function parseBool(s : string) : boolean {\n  if (!s) return false;\n  if (s == 'false' || s == '0') return false;\n  if (s == 'true' || s == '1') return true;\n  return s ? true : false;\n}\n\n///\n\nexport class XMLParseError extends Error {\n}\n\nexport interface XMLNode {\n  type: string;\n  text: string | null;\n  children: XMLNode[];\n  attrs: { [id: string]: string };\n  obj: any;\n}\n\nexport type XMLVisitFunction = (node: XMLNode) => any;\n\nfunction escapeXML(s: string): string {\n  if (s.indexOf('&') >= 0) {\n      return s.replace(/&apos;/g, \"'\")\n          .replace(/&quot;/g, '\"')\n          .replace(/&gt;/g, '>')\n          .replace(/&lt;/g, '<')\n          .replace(/&amp;/g, '&');\n  } else {\n      return s;\n  }\n}\n\nexport function parseXMLPoorly(s: string, openfn?: XMLVisitFunction, closefn?: XMLVisitFunction): XMLNode {\n  const tag_re = /[<]([/]?)([?a-z_-]+)([^>]*)[>]+|(\\s*[^<]+)/gi;\n  const attr_re = /\\s*(\\w+)=\"(.*?)\"\\s*/gi;\n  var fm: RegExpMatchArray;\n  var stack: XMLNode[] = [];\n  var top: XMLNode;\n\n  function closetop() {\n      top = stack.pop();\n      if (top == null || top.type != ident) throw new XMLParseError(\"mismatch close tag: \" + ident);\n      if (closefn) {\n          top.obj = closefn(top);\n      }\n      if (stack.length == 0) throw new XMLParseError(\"close tag without open: \" + ident);\n      stack[stack.length - 1].children.push(top);\n  }\n  function parseattrs(as: string): { [id: string]: string } {\n      var am;\n      var attrs = {};\n      if (as != null) {\n          while (am = attr_re.exec(as)) {\n              attrs[am[1]] = escapeXML(am[2]);\n          }\n      }\n      return attrs;\n  }\n  while (fm = tag_re.exec(s)) {\n      var [_m0, close, ident, attrs, content] = fm;\n      //console.log(stack.length, close, ident, attrs, content);\n      if (close) {\n          closetop();\n      } else if (ident) {\n          var node = { type: ident, text: null, children: [], attrs: parseattrs(attrs), obj: null };\n          stack.push(node);\n          if (attrs) {\n              parseattrs(attrs);\n          }\n          if (openfn) {\n              node.obj = openfn(node);\n          }\n          if (attrs && attrs.endsWith('/')) closetop();\n      } else if (content != null) {\n          if (stack.length == 0) throw new XMLParseError(\"content without element\");\n          var txt = escapeXML(content as string).trim();\n          if (txt.length) stack[stack.length - 1].text = txt;\n      }\n  }\n  if (stack.length != 1) throw new XMLParseError(\"tag not closed\");\n  if (stack[0].type != '?xml') throw new XMLParseError(\"?xml needs to be first element\");\n  return top;\n}\n\nexport function escapeHTML(s: string): string {\n  return s.replace(/[&]/g, '&amp;').replace(/[<]/g, '&lt;').replace(/[>]/g, '&gt;');\n}\n\n// lame factorization for displaying bitmaps\n// returns a > b such that a * b == x (or higher), a >= mina, b >= minb\nexport function findIntegerFactors(x: number, mina: number, minb: number, aspect: number) : {a: number, b: number} {\n  let a = x;\n  let b = 1;\n  if (minb > 1 && minb < a) {\n    a = Math.ceil(x / minb);\n    b = minb;\n  }\n  while (a > b) {\n    let a2 = a;\n    let b2 = b;\n    if ((a & 1) == 0) {\n      b2 = b * 2;\n      a2 = a / 2;\n    }\n    if ((a % 3) == 0) {\n      b2 = b * 3;\n      a2 = a / 3;\n    }\n    if ((a % 5) == 0) {\n      b2 = b * 5;\n      a2 = a / 5;\n    }\n    if (a2 < mina) break;\n    if (a2 < b2 * aspect) break;\n    a = a2;\n    b = b2;\n  }\n  return {a, b};\n}\n\nexport class FileDataCache {\n  maxSize : number = 8000000;\n  size : number;\n  cache : Map<string, string|Uint8Array>;\n  constructor() {\n    this.reset();\n  }\n  get(key : string) : string|Uint8Array {\n    return this.cache.get(key);\n  }\n  put(key : string, value : string|Uint8Array) {\n    this.cache.set(key, value);\n    this.size += value.length;\n    if (this.size > this.maxSize) {\n      console.log('cache reset', this);\n      this.reset();\n    }\n  }\n  reset() {\n    this.cache = new Map();\n    this.size = 0;\n  }\n}\n\nexport function coerceToArray<T>(arrobj: any) : T[] {\n    if (Array.isArray(arrobj)) return arrobj;\n    else if (arrobj != null && typeof arrobj[Symbol.iterator] === 'function') return Array.from(arrobj);\n    else if (typeof arrobj === 'object') return Array.from(Object.values(arrobj))\n    else throw new Error(`Expected array or object, got \"${arrobj}\"`);\n}\n", "import { WorkerError, CodeListingMap, SourceLocation, SourceLine, SourceLocated, SourceLineLocated } from \"../workertypes\";\n\nexport interface BASICOptions {\n    dialectName : string;               // use this to select the dialect \n    // SYNTAX AND PARSING\n    asciiOnly : boolean;                // reject non-ASCII chars?\n    uppercaseOnly : boolean;            // convert everything to uppercase?\n    optionalLabels : boolean;\t\t\t// can omit line numbers and use labels?\n    optionalWhitespace : boolean;       // can \"crunch\" keywords? also, eat extra \":\" delims\n    multipleStmtsPerLine : boolean;     // multiple statements separated by \":\"\n    varNaming : 'A'|'A1'|'A1$'|'AA'|'*';      // only allow A0-9 for numerics, single letter for arrays/strings\n    squareBrackets : boolean;           // \"[\" and \"]\" interchangable with \"(\" and \")\"?\n    tickComments : boolean;             // support 'comments?\n    hexOctalConsts : boolean;           // support &H and &O integer constants?\n    optionalLet : boolean;              // LET is optional\n    chainAssignments : boolean;         // support A = B = value (HP2000)\n    validKeywords : string[];           // valid keywords (or null for accept all)\n    validFunctions : string[];          // valid functions (or null for accept all)\n    validOperators : string[];          // valid operators (or null for accept all)\n    // VALUES AND OPERATORS\n    defaultValues : boolean;            // initialize unset variables to default value? (0 or \"\")\n    stringConcat : boolean;             // can concat strings with \"+\" operator?\n    checkOverflow : boolean;            // check for overflow of numerics?\n    bitwiseLogic : boolean;             // -1 = TRUE, 0 = FALSE, AND/OR/NOT done with bitwise ops\n    maxStringLength : number;           // maximum string length in chars\n    maxDefArgs : number;                // maximum # of arguments for user-defined functions\n    // ARRAYS\n    staticArrays : boolean;             // can only DIM with constant value? (and never redim)\n    sharedArrayNamespace : boolean;     // arrays and variables have same namespace? (TODO)\n    defaultArrayBase : number;          // arrays start at this number (0 or 1)\n    defaultArraySize : number;          // arrays are allocated w/ this size (starting @ 0)\n    maxDimensions : number;             // max number of dimensions for arrays\n    arraysContainChars : boolean;       // HP BASIC array-slicing syntax\n    // PRINTING\n    printZoneLength : number;           // print zone length\n    numericPadding : boolean;           // \" \" or \"-\" before and \" \" after numbers?\n    // CONTROL FLOW\n    compiledBlocks : boolean;           // assume blocks are statically compiled, not interpreted\n    testInitialFor : boolean;           // can we skip a NEXT statement? (can't interleave tho)\n    optionalNextVar : boolean;          // can do NEXT without variable\n    multipleNextVars : boolean;         // NEXT J,I\n    checkOnGotoIndex : boolean;         // fatal error when ON..GOTO index out of bounds\n    computedGoto : boolean;             // non-const expr GOTO label (and GOTO..OF expression)\n    restoreWithLabel : boolean;         // RESTORE <label>\n    endStmtRequired : boolean;          // need END at end?\n    // MISC\n    multilineIfThen? : boolean;         // multi-line IF .. ELSE .. END IF?\n    commandsPerSec? : number;           // how many commands per second?\n    maxLinesPerFile? : number;          // limit on # of lines\n    maxArrayElements? : number;         // max array elements (all dimensions)\n}\n\nexport class CompileError extends Error {\n    $loc : SourceLocation;\n    constructor(msg: string, loc: SourceLocation) {\n        super(msg);\n        Object.setPrototypeOf(this, CompileError.prototype);\n        this.$loc = loc;\n    }\n}\n\n// Lexer regular expression -- each (capture group) handles a different token type\n//                FLOAT                             INT       HEXOCTAL                    REMARK   IDENT           STRING   RELOP        EXP    OPERATORS             OTHER  WS\nconst re_toks = /([0-9.]+[E][+-]?\\d+|\\d+[.][E0-9]*|[.][E0-9]+)|[0]*(\\d+)|&([OH][0-9A-F]+)|(['].*)|([A-Z_]\\w*[$]?)|(\".*?\")|([<>]?[=<>#])|(\\*\\*)|([-+*/^,;:()\\[\\]\\?\\\\])|(\\S+)|(\\s+)/gi;\n\nexport enum TokenType {\n    EOL = 0,\n    Float,\n    Int,\n    HexOctalInt,\n    Remark,\n    Ident,\n    String,\n    Relational,\n    DoubleStar,\n    Operator,\n    CatchAll,\n    Whitespace,\n    _LAST,\n}\n\nexport type ExprTypes = BinOp | UnOp | IndOp | Literal;\nexport type Expr = ExprTypes; // & SourceLocated;\nexport type Opcode = string;\nexport type Value = number | string;\nexport type ValueType = 'number' | 'string' | 'label';\n\nexport interface ExprBase extends SourceLocated {\n    valtype: ValueType;\n}\n\nexport interface Literal extends ExprBase {\n    value: Value;\n}\n\nexport interface BinOp extends ExprBase {\n    op: Opcode;\n    left: Expr;\n    right: Expr;\n}\n\nexport interface UnOp extends ExprBase {\n    op: 'neg' | 'lnot' | 'bnot';\n    expr: Expr;\n}\n\nexport interface IndOp extends ExprBase {\n    name: string;\n    args: Expr[];\n}\n\nexport interface Statement extends SourceLineLocated {\n    command: string;\n}\n\nexport interface ScopeStartStatement extends Statement {\n    endpc?: number;\n}\n\nexport interface ScopeEndStatement extends Statement {\n    startpc?: number;\n}\n\nexport interface PRINT_Statement extends Statement {\n    command: \"PRINT\";\n    args: Expr[];\n}\n\nexport interface LET_Statement extends Statement {\n    command: \"LET\";\n    lexprs: IndOp[];\n    right: Expr;\n}\n\nexport interface DIM_Statement extends Statement {\n    command: \"DIM\";\n    args: IndOp[];\n}\n\nexport interface GOTO_Statement extends Statement {\n    command: \"GOTO\";\n    label: Expr;\n}\n\nexport interface GOSUB_Statement extends Statement {\n    command: \"GOSUB\";\n    label: Expr;\n}\n\nexport interface RETURN_Statement extends Statement {\n    command: \"RETURN\";\n}\n\nexport interface ONGO_Statement extends Statement {\n    command: \"ONGOTO\" | \"ONGOSUB\";\n    expr: Expr;\n    labels: Expr[];\n}\n\nexport interface IF_Statement extends ScopeStartStatement {\n    command: \"IF\";\n    cond: Expr;\n}\n\nexport interface ELSE_Statement extends ScopeStartStatement {\n    command: \"ELSE\";\n}\n\nexport interface FOR_Statement extends ScopeStartStatement {\n    command: \"FOR\";\n    lexpr: IndOp;\n    initial: Expr;\n    target: Expr;\n    step?: Expr;\n}\n\nexport interface NEXT_Statement extends ScopeEndStatement {\n    command: \"NEXT\";\n    lexpr?: IndOp;\n}\n\nexport interface WHILE_Statement extends ScopeStartStatement {\n    command: \"WHILE\";\n    cond: Expr;\n}\n\nexport interface WEND_Statement extends ScopeEndStatement {\n    command: \"WEND\";\n}\n\nexport interface END_Statement extends ScopeEndStatement {\n    command: \"END\";\n}\n\nexport interface INPUT_Statement extends Statement {\n    command: \"INPUT\";\n    prompt: Expr;\n    args: IndOp[];\n    timeout?: Expr;\n    elapsed?: IndOp;\n}\n\nexport interface ENTER_Statement extends INPUT_Statement {\n    timeout: Expr;\n    elapsed: IndOp;\n}\n\nexport interface DATA_Statement extends Statement {\n    command: \"DATA\";\n    datums: Literal[];\n}\n\nexport interface READ_Statement extends Statement {\n    command: \"READ\";\n    args: IndOp[];\n}\n\nexport interface RESTORE_Statement extends Statement {\n    command: \"RESTORE\";\n    label: Expr;\n}\n\nexport interface DEF_Statement extends Statement {\n    command: \"DEF\";\n    lexpr: IndOp;\n    def: Expr;\n}\n\nexport interface SUB_Statement extends ScopeStartStatement {\n    command: \"SUB\";\n    lexpr: IndOp;\n}\n\nexport interface CALL_Statement {\n    command: \"CALL\";\n    call: IndOp;\n}\n\nexport interface OPTION_Statement extends Statement {\n    command: \"OPTION\";\n    optname: string;\n    optargs: string[];\n}\n\nexport interface GET_Statement extends Statement { // applesoft only?\n    command: \"GET\";\n    lexpr: IndOp;\n}\n\nexport interface CHANGE_Statement extends Statement {\n    command: \"CHANGE\";\n    src: Expr;\n    dest: IndOp;\n}\n\nexport interface CONVERT_Statement extends Statement {\n    command: \"CONVERT\";\n    src: Expr;\n    dest: IndOp;\n}\n\nexport interface NoArgStatement extends Statement {\n    command: string;\n}\n\nexport interface BASICProgram {\n    opts: BASICOptions;\n    stmts: Statement[];\n    labels: { [label: string]: number }; // label -> PC\n}\n\nclass Token implements SourceLocated {\n    str: string;\n    type: TokenType;\n    $loc: SourceLocation;\n}\n\nconst OPERATORS = {\n    'IMP':  {f:'bimp',p:4},\n    'EQV':  {f:'beqv',p:5},\n    'XOR':  {f:'bxor',p:6},\n    'OR':   {f:'bor',p:7}, // or \"lor\" for logical\n    'AND':  {f:'band',p:8}, // or \"land\" for logical\n    '||':   {f:'lor',p:17}, // not used\n    '&&':   {f:'land',p:18}, // not used\n    '=':    {f:'eq',p:50},\n    '==':   {f:'eq',p:50},\n    '<>':   {f:'ne',p:50},\n    '><':   {f:'ne',p:50},\n    '!=':   {f:'ne',p:50},\n    '#':    {f:'ne',p:50},\n    '<':    {f:'lt',p:50},\n    '>':    {f:'gt',p:50},\n    '<=':   {f:'le',p:50},\n    '>=':   {f:'ge',p:50},\n    'MIN':  {f:'min',p:75},\n    'MAX':  {f:'max',p:75},\n    '+':    {f:'add',p:100},\n    '-':    {f:'sub',p:100},\n    '%':    {f:'mod',p:140},\n    'MOD':  {f:'mod',p:140},\n    '\\\\':   {f:'idiv',p:150},\n    '*':    {f:'mul',p:200},\n    '/':    {f:'div',p:200},\n    '^':    {f:'pow',p:300},\n    '**':   {f:'pow',p:300},\n};\n\nfunction getOperator(op: string) {\n    return OPERATORS[op];\n}\n\nfunction getPrecedence(tok: Token): number {\n    switch (tok.type) {\n        case TokenType.Operator:\n        case TokenType.DoubleStar:\n        case TokenType.Relational:\n        case TokenType.Ident:\n            let op = getOperator(tok.str);\n            if (op) return op.p;\n    }\n    return -1;\n}\n\n// is token an end of statement marker? (\":\" or end of line)\nfunction isEOS(tok: Token) {\n    return tok.type == TokenType.EOL || tok.type == TokenType.Remark\n        || tok.str == ':' || tok.str == 'ELSE'; // TODO: only ELSE if ifElse==true\n}\n\nfunction stripQuotes(s: string) {\n    // TODO: assert\n    return s.substr(1, s.length-2);\n}\n\nfunction isLiteral(arg: Expr): arg is Literal {\n    return (arg as any).value != null;\n}\nfunction isLookup(arg: Expr): arg is IndOp {\n    return (arg as any).name != null;\n}\nfunction isBinOp(arg: Expr): arg is BinOp {\n    return (arg as any).op != null && (arg as any).left != null && (arg as any).right != null;\n}\nfunction isUnOp(arg: Expr): arg is UnOp {\n    return (arg as any).op != null && (arg as any).expr != null;\n}\n\nfunction mergeLocs(a: SourceLocation, b: SourceLocation) : SourceLocation {\n    return {\n        line:Math.min(a.line, b.line),\n        start:Math.min(a.start, b.start),\n        end:Math.max(a.end, b.end),\n        label:a.label || b.label,\n        path:a.path || b.path,\n    }\n}\n\n///// BASIC PARSER\n\nexport class BASICParser {\n    opts : BASICOptions = DIALECTS['DEFAULT'];\n    optionCount : number; // how many OPTION stmts so far?\n    maxlinelen : number = 255; // maximum line length (some like HP use 72 chars)\n    stmts : Statement[];\n    errors: WorkerError[];\n    listings: CodeListingMap;\n    labels: { [label: string]: number }; // label -> PC\n    targets: { [targetlabel: string]: SourceLocation }; // targets of GOTOs etc\n    vardefs: { [name: string]: IndOp }; // LET or DIM\n    varrefs: { [name: string]: SourceLocation }; // variable references\n    fnrefs: { [name: string]: string[] }; // DEF FN call graph\n    scopestack: number[];\n    elseifcount: number;\n\n    path : string;\n    lineno : number;\n    tokens: Token[];\n    eol: Token;\n    curlabel: string;\n    lasttoken: Token;\n\n    constructor() {\n        this.optionCount = 0;\n        this.lineno = 0;\n        this.curlabel = null;\n        this.stmts = [];\n        this.labels = {};\n        this.targets = {};\n        this.errors = [];\n        this.listings = {};\n        this.vardefs = {};\n        this.varrefs = {};\n        this.fnrefs = {};\n        this.scopestack = [];\n        this.elseifcount = 0;\n    }\n    addError(msg: string, loc?: SourceLocation) {\n        var tok = this.lasttoken || this.peekToken();\n        if (!loc) loc = tok.$loc;\n        this.errors.push({path:loc.path, line:loc.line, label:this.curlabel, start:loc.start, end:loc.end, msg:msg});\n    }\n    compileError(msg: string, loc?: SourceLocation, loc2?: SourceLocation) {\n        this.addError(msg, loc);\n        //if (loc2 != null) this.addError(`...`, loc2);\n        throw new CompileError(msg, loc);\n    }\n    dialectError(what: string, loc?: SourceLocation) {\n        this.compileError(`${what} in this dialect of BASIC (${this.opts.dialectName}).`, loc);\n    }\n    dialectErrorNoSupport(what: string, loc?: SourceLocation) {\n        this.compileError(`You can't use ${what} in this dialect of BASIC (${this.opts.dialectName}).`, loc); // TODO\n    }\n    consumeToken(): Token {\n        var tok = this.lasttoken = (this.tokens.shift() || this.eol);\n        return tok;\n    }\n    expectToken(str: string, msg?: string) : Token {\n        var tok = this.consumeToken();\n        var tokstr = tok.str;\n        if (str != tokstr) {\n            this.compileError(msg || `There should be a \"${str}\" here.`);\n        }\n        return tok;\n    }\n    expectTokens(strlist: string[], msg?: string) : Token {\n        var tok = this.consumeToken();\n        var tokstr = tok.str;\n        if (strlist.indexOf(tokstr) < 0) {\n            this.compileError(msg || `There should be a ${strlist.map((s) => `\"${s}\"`).join(' or ')} here.`);\n        }\n        return tok;\n    }\n    peekToken(lookahead?: number): Token {\n        var tok = this.tokens[lookahead || 0];\n        return tok ? tok : this.eol;\n    }\n    pushbackToken(tok: Token) {\n        this.tokens.unshift(tok);\n    }\n    // this parses either a line number or \"label:\" -- or adds a default label to a line\n    parseOptLabel() {\n        let tok = this.consumeToken();\n        switch (tok.type) {\n            case TokenType.Ident:\n                if (this.opts.optionalLabels || tok.str == 'OPTION') {\n                    // is it a \"label :\" and not a keyword like \"PRINT : \"\n                    if (this.peekToken().str == ':' && !this.supportsCommand(tok.str)) { \n                        this.consumeToken(); // eat the \":\"\n                        // fall through to the next case\n                    } else {\n                        this.pushbackToken(tok); // nope\n                        break;\n                    }\n                } else\n                    this.dialectError(`Each line must begin with a line number`);\n            case TokenType.Int:\n                this.addLabel(tok.str);\n                return;\n            // label added, return from function... other cases add default label\n            case TokenType.HexOctalInt:\n            case TokenType.Float:\n                this.compileError(`Line numbers must be positive integers.`);\n                break;\n            case TokenType.Operator:\n                if (this.supportsCommand(tok.str) && this.validKeyword(tok.str)) {\n                    this.pushbackToken(tok);\n                    break; // \"?\" is allowed\n                }\n            default:\n                if (this.opts.optionalLabels)\n                    this.compileError(`A line must start with a line number, command, or label.`);\n                else\n                    this.compileError(`A line must start with a line number.`);\n            case TokenType.Remark:\n                break;\n        }\n        // add default label\n        this.addLabel('#'+this.lineno);\n    }\n    getPC() : number {\n        return this.stmts.length;\n    }\n    addStatement(stmt: Statement, cmdtok: Token, endtok?: Token) {\n        // set location for statement, adding offset (PC) field\n        if (endtok == null) endtok = this.peekToken();\n        stmt.$loc = { path: cmdtok.$loc.path, line: cmdtok.$loc.line, start: cmdtok.$loc.start, end: endtok.$loc.start,\n            label: this.curlabel,\n            offset: this.stmts.length };\n        // check IF/THEN WHILE/WEND FOR/NEXT etc\n        this.modifyScope(stmt);\n        // add to list\n        this.stmts.push(stmt);\n    }\n    addLabel(str: string, offset?: number) {\n        if (this.labels[str] != null) this.compileError(`There's a duplicated label named \"${str}\".`);\n        this.labels[str] = this.getPC() + (offset || 0);\n        this.curlabel = str;\n        this.tokens.forEach((tok) => tok.$loc.label = str);\n    }\n    parseFile(file: string, path: string) : BASICProgram {\n        this.path = path;\n        var txtlines = file.split(/\\n|\\r\\n?/);\n        txtlines.forEach((line) => this.parseLine(line));\n        var program = { opts: this.opts, stmts: this.stmts, labels: this.labels };\n        this.checkAll(program);\n        this.listings[path] = this.generateListing(file, program);\n        return program;\n    }\n    parseLine(line: string) : void {\n        try {\n            this.tokenize(line);\n            this.parse();\n        } catch (e) {\n            if (!(e instanceof CompileError)) throw e; // ignore compile errors since errors[] list captures them\n        }\n    }\n    _tokenize(line: string) : void {\n        // split identifier regex (if token-crunching enabled)\n        let splitre = this.opts.optionalWhitespace && new RegExp('('+this.opts.validKeywords.map(s => `${s}`).join('|')+')');\n        // iterate over each token via re_toks regex\n        var lastTokType = TokenType.CatchAll;\n        var m : RegExpMatchArray;\n        while (m = re_toks.exec(line)) {\n            for (var i = 1; i <= lastTokType; i++) {\n                let s : string = m[i];\n                if (s != null) {\n                    let loc = { path: this.path, line: this.lineno, start: m.index, end: m.index+s.length };\n                    // maybe we don't support unicode in 1975?\n                    if (this.opts.asciiOnly && !/^[\\x00-\\x7F]*$/.test(s))\n                        this.dialectErrorNoSupport(`non-ASCII characters`);\n                    // uppercase all identifiers, and maybe more\n                    if (i == TokenType.Ident || i == TokenType.HexOctalInt || this.opts.uppercaseOnly) {\n                        s = s.toUpperCase();\n                        // DATA statement captures whitespace too\n                        if (s == 'DATA') lastTokType = TokenType.Whitespace;\n                        // certain keywords shouldn't split for rest of line\n                        if (s == 'DATA') splitre = null;\n                        if (s == 'OPTION') splitre = null;\n                        // REM means ignore rest of statement\n                        if (lastTokType == TokenType.CatchAll && s.startsWith('REM')) {\n                            s = 'REM';\n                            lastTokType = TokenType.EOL;\n                        }\n                    }\n                    // convert brackets\n                    if (s == '[' || s == ']') {\n                        if (!this.opts.squareBrackets) this.dialectErrorNoSupport(`square brackets`);\n                        if (s == '[') s = '(';\n                        if (s == ']') s = ')';\n                    }\n                    // un-crunch tokens?\n                    if (splitre && i == TokenType.Ident) {\n                        var splittoks = s.split(splitre).filter((s) => s != ''); // only non-empties\n                        if (splittoks.length > 1) {\n                            splittoks.forEach((ss) => {\n                                // check to see if leftover might be integer, or identifier\n                                if (/^[0-9]+$/.test(ss)) i = TokenType.Int;\n                                else if (/^[A-Z_]\\w*[$]?$/.test(ss)) i = TokenType.Ident;\n                                else this.compileError(`Try adding whitespace before \"${ss}\".`);\n                                this.tokens.push({str: ss, type: i, $loc:loc});\n                            });\n                            s = null;\n                        }\n                    }\n                    // add token to list\n                    if (s) this.tokens.push({str: s, type: i, $loc:loc});\n                    break;\n                }\n            }\n        }\n    }\n    tokenize(line: string) : void {\n        this.lineno++;\n        this.tokens = []; // can't have errors until this is set\n        this.eol = { type: TokenType.EOL, str: \"\", $loc: { path: this.path, line: this.lineno, start: line.length } };\n        if (line.length > this.maxlinelen) this.compileError(`A line should be no more than ${this.maxlinelen} characters long.`);\n        this._tokenize(line);\n    }\n    parse() : void {\n        // not empty line?\n        if (this.tokens.length) {\n            this.parseOptLabel();\n            if (this.tokens.length) {\n                this.parseCompoundStatement();\n            }\n            var next = this.peekToken();\n            if (!isEOS(next)) this.compileError(`Expected end of line or ':'`, next.$loc);\n            this.curlabel = null;\n        }\n    }\n    parseCompoundStatement() : void {\n        if (this.opts.multipleStmtsPerLine) {\n            this.parseList(this.parseStatement, ':');\n        } else {\n            this.parseList(this.parseStatement, '\\0');\n            if (this.peekToken().str == ':') this.dialectErrorNoSupport(`multiple statements on a line`);\n        }\n    }\n    validKeyword(keyword: string) : string {\n        return (this.opts.validKeywords && this.opts.validKeywords.indexOf(keyword) < 0) ? null : keyword;\n    }\n    validFunction(funcname: string) : string {\n        return (this.opts.validFunctions && this.opts.validFunctions.indexOf(funcname) < 0) ? null : funcname;\n    }\n    supportsCommand(cmd: string) : () => Statement {\n        if (cmd == '?') return this.stmt__PRINT;\n        else return this['stmt__' + cmd];\n    }\n    parseStatement(): Statement | null {\n        // eat extra \":\" (should have separate property for this)\n        if (this.opts.optionalWhitespace && this.peekToken().str == ':') return null;\n        // get the command word\n        var cmdtok = this.consumeToken();\n        var cmd = cmdtok.str;\n        var stmt : Statement;\n        switch (cmdtok.type) {\n            case TokenType.Remark:\n                if (cmdtok.str.startsWith(\"'\") && !this.opts.tickComments)\n                    this.dialectErrorNoSupport(`tick comments`);\n                return null;\n            case TokenType.Operator:\n                // \"?\" is alias for \"PRINT\" on some platforms\n                if (cmd == this.validKeyword('?')) cmd = 'PRINT';\n            case TokenType.Ident:\n                // ignore remarks\n                if (cmd == 'REM') return null;\n                // look for \"GO TO\" and \"GO SUB\"\n                if (cmd == 'GO' && this.peekToken().str == 'TO') {\n                    this.consumeToken();\n                    cmd = 'GOTO';\n                } else if (cmd == 'GO' && this.peekToken().str == 'SUB') {\n                    this.consumeToken();\n                    cmd = 'GOSUB';\n                }\n                // lookup JS function for command\n                var fn = this.supportsCommand(cmd);\n                if (fn) {\n                    if (this.validKeyword(cmd) == null)\n                        this.dialectErrorNoSupport(`the ${cmd} statement`);\n                    stmt = fn.bind(this)();\n                    break;\n                } else if (this.peekToken().str == '=' || this.peekToken().str == '(') {\n                    if (!this.opts.optionalLet)\n                        this.dialectError(`Assignments must have a preceding LET`);\n                    // 'A = expr' or 'A(X) = expr'\n                    this.pushbackToken(cmdtok);\n                    stmt = this.stmt__LET();\n                    break;\n                } else {\n                    this.compileError(`I don't understand the command \"${cmd}\".`);\n                }\n            case TokenType.EOL:\n                if (this.opts.optionalWhitespace) return null;\n            default:\n                this.compileError(`There should be a command here.`);\n                return null;\n        }\n        // add statement to list\n        if (stmt != null) this.addStatement(stmt, cmdtok);\n        return stmt;\n    }\n    // check scope stuff (if compiledBlocks is true)\n    modifyScope(stmt: Statement) {\n        if (this.opts.compiledBlocks) {\n            var cmd = stmt.command;\n            if (cmd == 'FOR' || cmd == 'WHILE' || cmd == 'SUB') {\n                this.scopestack.push(this.getPC()); // has to be before adding statment to list\n            } else if (cmd == 'NEXT') {\n                this.popScope(stmt as NEXT_Statement, 'FOR');\n            } else if (cmd == 'WEND') {\n                this.popScope(stmt as WEND_Statement, 'WHILE');\n            }\n        }\n    }\n    popScope(close: WEND_Statement|NEXT_Statement|END_Statement, open: string) {\n        var popidx = this.scopestack.pop();\n        var popstmt : ScopeStartStatement = popidx != null ? this.stmts[popidx] : null;\n        if (popstmt == null)\n            this.compileError(`There's a ${close.command} without a matching ${open}.`, close.$loc);\n        else if (popstmt.command != open)\n            this.compileError(`There's a ${close.command} paired with ${popstmt.command}, but it should be paired with ${open}.`, close.$loc, popstmt.$loc);\n        else if (close.command == 'NEXT' && !this.opts.optionalNextVar \n            && close.lexpr.name != (popstmt as FOR_Statement).lexpr.name)\n            this.compileError(`This NEXT statement is matched with the wrong FOR variable (${close.lexpr.name}).`, close.$loc, popstmt.$loc);\n        // set start + end locations\n        close.startpc = popidx;\n        popstmt.endpc = this.getPC(); // has to be before adding statment to list\n    }\n    popIfThenScope(nextpc?: number) {\n        var popidx = this.scopestack.pop();\n        var popstmt : ScopeStartStatement = popidx != null ? this.stmts[popidx] : null;\n        if (popstmt == null)\n            this.compileError(`There's an END IF without a matching IF or ELSE.`);\n        if (popstmt.command == 'ELSE') {\n            popstmt.endpc = this.getPC();\n            this.popIfThenScope(popidx + 1); // IF goes to ELSE+1\n        } else if (popstmt.command == 'IF') {\n            popstmt.endpc = nextpc != null ? nextpc : this.getPC();\n        } else {\n            this.compileError(`There's an END IF paired with a ${popstmt.command}, not IF or ELSE.`, this.lasttoken.$loc, popstmt.$loc);\n        }\n    }\n    parseVarSubscriptOrFunc(): IndOp {\n        var tok = this.consumeToken();\n        switch (tok.type) {\n            case TokenType.Ident:\n                let args = null;\n                if (this.peekToken().str == '(') {\n                    this.expectToken('(');\n                    args = this.parseExprList();\n                    this.expectToken(')', `There should be another expression or a \")\" here.`);\n                }\n                var loc = mergeLocs(tok.$loc, this.lasttoken.$loc);\n                var valtype = this.exprTypeForSubscript(tok.str, args, loc);\n                return { valtype: valtype, name: tok.str, args: args, $loc:loc };\n            default:\n                this.compileError(`There should be a variable name here.`);\n                break;\n        }\n    }\n    parseLexpr(): IndOp {\n        var lexpr = this.parseVarSubscriptOrFunc();\n        this.vardefs[lexpr.name] = lexpr;\n        this.validateVarName(lexpr);\n        return lexpr;\n    }\n    parseForNextLexpr() : IndOp {\n        var lexpr = this.parseLexpr();\n        if (lexpr.args || lexpr.name.endsWith('$'))\n            this.compileError(`A FOR ... NEXT loop can only use numeric variables.`, lexpr.$loc);\n        return lexpr;\n    }\n    parseList<T>(parseFunc:()=>T, delim:string): T[] {\n        var sep;\n        var list = [];\n        do {\n            var el = parseFunc.bind(this)(); // call parse function\n            if (el != null) list.push(el); // add parsed element to list\n            sep = this.consumeToken(); // consume seperator token\n        } while (sep.str == delim);\n        this.pushbackToken(sep);\n        return list;\n    }\n    parseLexprList(): IndOp[] {\n        return this.parseList(this.parseLexpr, ',');\n    }\n    parseExprList(): Expr[] {\n        return this.parseList(this.parseExpr, ',');\n    }\n    parseLabelList(): Expr[] {\n        return this.parseList(this.parseLabel, ',');\n    }\n    parseLabel() : Expr {\n        // parse full expr?\n        if (this.opts.computedGoto) {\n            // parse expression, but still add to list of label targets if constant\n            var expr = this.parseExpr();\n            if (isLiteral(expr)) this.targets[expr.value] = this.lasttoken.$loc;\n            return expr;\n        } else {\n            // parse a single number or ident label\n            var tok = this.consumeToken();\n            switch (tok.type) {\n                case TokenType.Ident:\n                    if (!this.opts.optionalLabels)\n                        this.dialectError(`All labels must be line numbers`)\n                case TokenType.Int:\n                    var label = tok.str;\n                    this.targets[label] = tok.$loc;\n                    return {valtype:'label', value:label};\n                default:\n                    var what = this.opts.optionalLabels ? \"label or line number\" : \"line number\";\n                    this.compileError(`There should be a ${what} here.`);\n            }\n        }\n    }\n    parseDatumList(): Literal[] {\n        return this.parseList(this.parseDatum, ',');\n    }\n    parseDatum(): Literal {\n        var tok = this.consumeToken();\n        // get rid of leading whitespace\n        while (tok.type == TokenType.Whitespace)\n            tok = this.consumeToken();\n        if (isEOS(tok)) this.compileError(`There should be a datum here.`);\n        // parse constants\n        if (tok.type <= TokenType.HexOctalInt) {\n            return this.parseValue(tok);\n        }\n        if (tok.str == '-' && this.peekToken().type <= TokenType.HexOctalInt) {\n            tok = this.consumeToken();\n            return { valtype:'number', value: -this.parseValue(tok).value };\n        }\n        if (tok.str == '+' && this.peekToken().type <= TokenType.HexOctalInt) {\n            tok = this.consumeToken();\n            return this.parseValue(tok);\n        }\n        // concat all stuff including whitespace\n        // TODO: should trim whitespace only if not quoted string\n        var s = '';\n        while (!isEOS(tok) && tok.str != ',') {\n            s += this.parseValue(tok).value;\n            tok = this.consumeToken();\n        }\n        this.pushbackToken(tok);\n        return { valtype:'string', value: s }; // trim leading and trailing whitespace\n    }\n    parseValue(tok: Token): Literal {\n        switch (tok.type) {\n            case TokenType.HexOctalInt:\n                if (!this.opts.hexOctalConsts)\n                    this.dialectErrorNoSupport(`hex/octal constants`);\n                let base = tok.str.startsWith('H') ? 16 : 8;\n                return { valtype:'number', value: parseInt(tok.str.substr(1), base) };\n            case TokenType.Int:\n            case TokenType.Float:\n                return { valtype:'number', value: this.parseNumber(tok.str) };\n            case TokenType.String:\n                return { valtype:'string', value: stripQuotes(tok.str) };\n            default:\n                return { valtype:'string', value: tok.str }; // only used in DATA statement\n        }\n    }\n    parsePrimary(): Expr {\n        let tok = this.consumeToken();\n        switch (tok.type) {\n            case TokenType.HexOctalInt:\n            case TokenType.Int:\n            case TokenType.Float:\n            case TokenType.String:\n                return this.parseValue(tok);\n            case TokenType.Ident:\n                if (tok.str == 'NOT') {\n                    let expr = this.parsePrimary();\n                    return { valtype:'number', op: this.opts.bitwiseLogic ? 'bnot' : 'lnot', expr: expr };\n                } else {\n                    this.pushbackToken(tok);\n                    return this.parseVarSubscriptOrFunc();\n                }\n            case TokenType.Operator:\n                if (tok.str == '(') {\n                    let expr = this.parseExpr();\n                    this.expectToken(')', `There should be another expression or a \")\" here.`);\n                    return expr;\n                } else if (tok.str == '-') {\n                    let expr = this.parsePrimary(); // TODO: -2^2=-4 and -2-2=-4\n                    return { valtype:'number', op: 'neg', expr: expr };\n                } else if (tok.str == '+') {\n                    return this.parsePrimary(); // ignore unary +\n                }\n            default:\n                this.compileError(`The expression is incomplete.`);\n                return;\n        }\n    }\n    parseNumber(str: string) : number {\n        var n = parseFloat(str);\n        if (isNaN(n))\n            this.compileError(`The number ${str} is not a valid floating-point number.`);\n        if (this.opts.checkOverflow && !isFinite(n))\n            this.compileError(`The number ${str} is too big to fit into a floating-point value.`);\n        return n;\n    }\n    parseExpr1(left: Expr, minPred: number): Expr {\n        let look = this.peekToken();\n        while (getPrecedence(look) >= minPred) {\n            let op = this.consumeToken();\n            if (this.opts.validOperators && this.opts.validOperators.indexOf(op.str) < 0)\n                this.dialectErrorNoSupport(`the \"${op.str}\" operator`);\n            let right: Expr = this.parsePrimary();\n            look = this.peekToken();\n            while (getPrecedence(look) > getPrecedence(op)) {\n                right = this.parseExpr1(right, getPrecedence(look));\n                look = this.peekToken();\n            }\n            var opfn = getOperator(op.str).f;\n            // use logical operators instead of bitwise?\n            if (!this.opts.bitwiseLogic && op.str == 'AND') opfn = 'land';\n            if (!this.opts.bitwiseLogic && op.str == 'OR') opfn = 'lor';\n            var valtype = this.exprTypeForOp(opfn, left, right, op);\n            left = { valtype:valtype, op:opfn, left: left, right: right };\n        }\n        return left;\n    }\n    parseExpr(): Expr {\n        var startloc = this.peekToken().$loc;\n        var expr = this.parseExpr1(this.parsePrimary(), 0);\n        var endloc = this.lasttoken.$loc;\n        expr.$loc = mergeLocs(startloc, endloc);\n        return expr;\n    }\n    parseExprWithType(expecttype: ValueType): Expr {\n        var expr = this.parseExpr();\n        if (expr.valtype != expecttype)\n            this.compileError(`There should be a ${expecttype} here, but this expression evaluates to a ${expr.valtype}.`, expr.$loc);\n        return expr;\n    }\n    validateVarName(lexpr: IndOp) {\n        switch (this.opts.varNaming) {\n            case 'A': // TINY BASIC, no strings\n                if (!/^[A-Z]$/i.test(lexpr.name))\n                    this.dialectErrorNoSupport(`variable names other than a single letter`);\n                break;\n            case 'A1':\n                if (lexpr.args == null && !/^[A-Z][0-9]?[$]?$/i.test(lexpr.name))\n                    this.dialectErrorNoSupport(`variable names other than a letter followed by an optional digit`);\n                if (lexpr.args != null && !/^[A-Z]?[$]?$/i.test(lexpr.name))\n                    this.dialectErrorNoSupport(`array names other than a single letter`);\n                break;\n            case 'A1$':\n                if (!/^[A-Z][0-9]?[$]?$/i.test(lexpr.name))\n                    this.dialectErrorNoSupport(`variable names other than a letter followed by an optional digit`);\n                break;\n            case 'AA':\n                if (lexpr.args == null && !/^[A-Z][A-Z0-9]?[$]?$/i.test(lexpr.name))\n                    this.dialectErrorNoSupport(`variable names other than a letter followed by an optional letter or digit`);\n                break;\n            case '*':\n                break;\n        }\n    }\n    visitExpr(expr: Expr, callback: (expr:Expr) => void) {\n        if (isBinOp(expr)) {\n            this.visitExpr(expr.left, callback);\n            this.visitExpr(expr.right, callback);\n        }\n        if (isUnOp(expr)) {\n            this.visitExpr(expr.expr, callback);\n        }\n        if (isLookup(expr) && expr.args != null) {\n            for (var arg of expr.args)\n                this.visitExpr(arg, callback);\n        }\n        callback(expr);\n    }\n    // type-checking\n    exprTypeForOp(fnname: string, left: Expr, right: Expr, optok: Token) : ValueType {\n        if (left.valtype == 'string' || right.valtype == 'string') {\n            if (fnname == 'add') {\n                if (this.opts.stringConcat) return 'string' // concat strings\n                else this.dialectErrorNoSupport(`the \"+\" operator to concatenate strings`, optok.$loc);\n            } else if (fnname.length != 2) // only relops are 2 chars long!\n                this.compileError(`You can't do math on strings until they're converted to numbers.`, optok.$loc);\n        }\n        return 'number';\n    }\n    exprTypeForSubscript(fnname: string, args: Expr[], loc: SourceLocation) : ValueType {\n        args = args || [];\n        // first check the built-in functions\n        var defs = BUILTIN_MAP[fnname];\n        if (defs != null) {\n            if (!this.validFunction(fnname)) this.dialectErrorNoSupport(`the ${fnname} function`, loc);\n            for (var def of defs) {\n                if (args.length == def.args.length)\n                    return def.result; // TODO: check arg types\n            }\n            // TODO: check func arg types\n            this.compileError(`The ${fnname} function takes ${def.args.length} arguments, but ${args.length} are given.`, loc);\n        }\n        // no function found, assume it's an array ref\n        // TODO: validateVarName() later?\n        this.varrefs[fnname] = loc;\n        return fnname.endsWith('$') ? 'string' : 'number';\n    }\n\n    //// STATEMENTS\n\n    stmt__LET(): LET_Statement {\n        var lexprs = [ this.parseLexpr() ];\n        this.expectToken(\"=\");\n        // look for A=B=expr (TODO: doesn't work on arrays)\n        while (this.opts.chainAssignments && this.peekToken().type == TokenType.Ident && this.peekToken(1).str == '=') {\n            lexprs.push(this.parseLexpr());\n            this.expectToken(\"=\");\n        }\n        var right = this.parseExprWithType(lexprs[0].valtype);\n        return { command: \"LET\", lexprs: lexprs, right: right };\n    }\n    stmt__PRINT(): PRINT_Statement {\n        var sep, lastsep;\n        var list = [];\n        do {\n            sep = this.peekToken();\n            if (isEOS(sep)) {\n                break;\n            } else if (sep.str == ';') {\n                this.consumeToken();\n                lastsep = sep;\n            } else if (sep.str == ',') {\n                this.consumeToken();\n                list.push({value:'\\t'});\n                lastsep = sep;\n            } else {\n                list.push(this.parseExpr());\n                lastsep = null;\n            }\n        } while (true);\n        if (!(lastsep && (lastsep.str == ';' || sep.str != ','))) {\n            list.push({value:'\\n'});\n        }\n        return { command: \"PRINT\", args: list };\n    }\n    stmt__GOTO(): GOTO_Statement | GOSUB_Statement | ONGO_Statement {\n        return this.__GO(\"GOTO\");\n    }\n    stmt__GOSUB(): GOTO_Statement | GOSUB_Statement | ONGO_Statement {\n        return this.__GO(\"GOSUB\");\n    }\n    __GO(cmd: \"GOTO\"|\"GOSUB\"): GOTO_Statement | GOSUB_Statement | ONGO_Statement {\n        var expr = this.parseLabel();\n        // GOTO (expr) OF (labels...)\n        if (this.peekToken().str == this.validKeyword('OF')) {\n            this.expectToken('OF');\n            let newcmd : 'ONGOTO'|'ONGOSUB' = (cmd == 'GOTO') ? 'ONGOTO' : 'ONGOSUB';\n            return { command: newcmd, expr: expr, labels: this.parseLabelList() };\n        } else {\n            // regular GOTO or GOSUB\n            return { command: cmd, label: expr };\n        }\n    }\n    stmt__IF(): void {\n        var cmdtok = this.lasttoken;\n        var cond = this.parseExprWithType(\"number\");\n        var ifstmt : IF_Statement = { command: \"IF\", cond: cond };\n        this.addStatement(ifstmt, cmdtok);\n        // we accept GOTO or THEN if line number provided (DEC accepts GO TO)\n        var thengoto = this.expectTokens(['THEN','GOTO','GO']);\n        if (thengoto.str == 'GO') this.expectToken('TO');\n        // multiline IF .. THEN? push it to scope stack\n        if (this.opts.multilineIfThen && isEOS(this.peekToken())) {\n            this.scopestack.push(this.getPC() - 1); // we already added stmt to list, so - 1\n        } else {\n            // parse line number or statement clause\n            this.parseGotoOrStatements();\n            // is the next statement an ELSE?\n            // gotta parse it now because it's an end-of-statement token\n            if (this.peekToken().str == 'ELSE') {\n                this.expectToken('ELSE');\n                ifstmt.endpc = this.getPC() + 1;\n                this.stmt__ELSE();\n            } else {\n                ifstmt.endpc = this.getPC();\n            }\n        }\n    }\n    stmt__ELSE(): void {\n        var elsestmt : ELSE_Statement = { command: \"ELSE\" };\n        this.addStatement(elsestmt, this.lasttoken);\n        // multiline ELSE? or ELSE IF?\n        var nexttok = this.peekToken();\n        if (this.opts.multilineIfThen && isEOS(nexttok)) {\n            this.scopestack.push(this.getPC() - 1); // we already added stmt to list, so - 1\n        } else if (this.opts.multilineIfThen && nexttok.str == 'IF') {\n            this.scopestack.push(this.getPC() - 1); // we already added stmt to list, so - 1\n            this.parseGotoOrStatements();\n            this.elseifcount++;\n        } else {\n            // parse line number or statement clause\n            this.parseGotoOrStatements();\n            elsestmt.endpc = this.getPC();\n        }\n    }\n    parseGotoOrStatements() {\n        var lineno = this.peekToken();\n        // assume GOTO if number given after THEN\n        if (lineno.type == TokenType.Int) {\n            this.parseLabel();\n            var gotostmt : GOTO_Statement = { command:'GOTO', label: {valtype:'label', value:lineno.str} }\n            this.addStatement(gotostmt, lineno);\n        } else {\n            // parse rest of IF clause\n            this.parseCompoundStatement();\n        }\n    }\n    stmt__FOR() : FOR_Statement {\n        var lexpr = this.parseForNextLexpr();\n        this.expectToken('=');\n        var init = this.parseExprWithType(\"number\");\n        this.expectToken('TO');\n        var targ = this.parseExprWithType(\"number\");\n        if (this.peekToken().str == 'STEP') {\n            this.consumeToken();\n            var step = this.parseExprWithType(\"number\");\n        }\n        return { command:'FOR', lexpr:lexpr, initial:init, target:targ, step:step };\n    }\n    stmt__NEXT() : NEXT_Statement {\n        var lexpr = null;\n        // NEXT var might be optional\n        if (!this.opts.optionalNextVar || !isEOS(this.peekToken())) {\n            lexpr = this.parseForNextLexpr();\n            // convert ',' to ':' 'NEXT'\n            if (this.opts.multipleNextVars && this.peekToken().str == ',') {\n                this.consumeToken(); // consume ','\n                this.tokens.unshift({type:TokenType.Ident, str:'NEXT', $loc:this.peekToken().$loc});\n                this.tokens.unshift({type:TokenType.Operator, str:':', $loc:this.peekToken().$loc});\n            }\n        }\n        return { command:'NEXT', lexpr:lexpr };\n    }\n    stmt__WHILE(): WHILE_Statement {\n        var cond = this.parseExprWithType(\"number\");\n        return { command:'WHILE', cond:cond };\n    }\n    stmt__WEND(): WEND_Statement {\n        return { command:'WEND' };\n    }\n    stmt__DIM() : DIM_Statement {\n        var lexprs = this.parseLexprList();\n        lexprs.forEach((arr) => {\n            if (arr.args == null || arr.args.length == 0) \n                this.compileError(`An array defined by DIM must have at least one dimension.`)\n            else if (arr.args.length > this.opts.maxDimensions) \n                this.dialectErrorNoSupport(`arrays with more than ${this.opts.maxDimensions} dimensionals`);\n            for (var arrdim of arr.args) {\n                if (arrdim.valtype != 'number')\n                    this.compileError(`Array dimensions must be numeric.`, arrdim.$loc);\n                if (isLiteral(arrdim) && arrdim.value < this.opts.defaultArrayBase)\n                    this.compileError(`An array dimension cannot be less than ${this.opts.defaultArrayBase}.`, arrdim.$loc);\n            }\n        });\n        return { command:'DIM', args:lexprs };\n    }\n    stmt__INPUT() : INPUT_Statement {\n        var prompt = this.consumeToken();\n        var promptstr;\n        if (prompt.type == TokenType.String) {\n            this.expectTokens([';', ',']);\n            promptstr = stripQuotes(prompt.str);\n        } else {\n            this.pushbackToken(prompt);\n            promptstr = \"\";\n        }\n        return { command:'INPUT', prompt:{ valtype:'string', value: promptstr }, args:this.parseLexprList() };\n    }\n    /* for HP BASIC only */\n    stmt__ENTER() : INPUT_Statement {\n        var timeout = this.parseExpr();\n        this.expectToken(',');\n        var elapsed = this.parseLexpr(); // TODO: this has to go somewheres\n        this.expectToken(',');\n        return { command:'INPUT', prompt:null, args:this.parseLexprList(), timeout:timeout, elapsed:elapsed };\n    }\n    // TODO: DATA statement doesn't read unquoted strings\n    stmt__DATA() : DATA_Statement {\n        return { command:'DATA', datums:this.parseDatumList() };\n    }\n    stmt__READ() : READ_Statement {\n        return { command:'READ', args:this.parseLexprList() };\n    }\n    stmt__RESTORE() : RESTORE_Statement {\n        var label = null;\n        if (this.opts.restoreWithLabel && !isEOS(this.peekToken()))\n            label = this.parseLabel();\n        return { command:'RESTORE', label:label };\n    }\n    stmt__RETURN() {\n        return { command:'RETURN' };\n    }\n    stmt__STOP() {\n        return { command:'STOP' };\n    }\n    stmt__END() {\n        if (this.opts.multilineIfThen && this.scopestack.length) {\n            let endtok = this.expectTokens(['IF','SUB']);\n            if (endtok.str == 'IF') {\n                this.popIfThenScope();\n                while (this.elseifcount--) this.popIfThenScope(); // pop additional ELSE IF blocks?\n                this.elseifcount = 0;\n            } else if (endtok.str == 'SUB') {\n                this.addStatement( { command: 'RETURN' }, endtok );\n                this.popScope( { command: 'END' }, 'SUB'); // fake command to avoid null\n            }\n        } else {\n            return { command:'END' };\n        }\n    }\n    stmt__ON() : ONGO_Statement {\n        var expr = this.parseExprWithType(\"number\");\n        var gotok = this.consumeToken();\n        var cmd = {GOTO:'ONGOTO', THEN:'ONGOTO', GOSUB:'ONGOSUB'}[gotok.str]; // THEN only for DEC basic?\n        if (!cmd) this.compileError(`There should be a GOTO or GOSUB here.`);\n        var labels = this.parseLabelList();\n        return { command:cmd as any, expr:expr, labels:labels };\n    }\n    stmt__DEF() : DEF_Statement {\n        var lexpr = this.parseVarSubscriptOrFunc(); // TODO: only allow parameter names, not exprs\n        if (lexpr.args && lexpr.args.length > this.opts.maxDefArgs)\n            this.compileError(`There can be no more than ${this.opts.maxDefArgs} arguments to a function or subscript.`, lexpr.$loc);\n        if (!lexpr.name.startsWith('FN')) this.compileError(`Functions defined with DEF must begin with the letters \"FN\".`, lexpr.$loc)\n        this.markVarDefs(lexpr); // local variables need to be marked as referenced (TODO: only for this scope)\n        this.expectToken(\"=\");\n        var func = this.parseExpr();\n        // build call graph to detect cycles\n        this.visitExpr(func, (expr:Expr) => {\n            if (isLookup(expr) && expr.name.startsWith('FN')) {\n                if (!this.fnrefs[lexpr.name])\n                    this.fnrefs[lexpr.name] = [];\n                this.fnrefs[lexpr.name].push(expr.name);\n            }\n        });\n        this.checkCallGraph(lexpr.name, new Set());\n        return { command:'DEF', lexpr:lexpr, def:func };\n    }\n    stmt__SUB() : SUB_Statement {\n        var lexpr = this.parseVarSubscriptOrFunc(); // TODO: only allow parameter names, not exprs\n        this.markVarDefs(lexpr); // local variables need to be marked as referenced (TODO: only for this scope)\n        this.addLabel(lexpr.name, 1); // offset +1 to skip SUB command\n        return { command:'SUB', lexpr:lexpr };\n    }\n    stmt__CALL() : CALL_Statement {\n        return { command:'CALL', call:this.parseVarSubscriptOrFunc() };\n    }\n    markVarDefs(lexpr: IndOp) {\n        this.vardefs[lexpr.name] = lexpr;\n        if (lexpr.args != null)\n            for (let arg of lexpr.args) {\n                if (isLookup(arg) && arg.args == null)\n                    this.vardefs[arg.name] = arg;\n                else\n                    this.compileError(`A definition can only define symbols, not expressions.`);\n            }\n    }\n    // detect cycles in call graph starting at function 'name'\n    checkCallGraph(name: string, visited: Set<string>) {\n        if (visited.has(name)) this.compileError(`There was a cycle in the function definition graph for ${name}.`);\n        visited.add(name);\n        var refs = this.fnrefs[name] || [];\n        for (var ref of refs)\n            this.checkCallGraph(ref, visited); // recurse\n        visited.delete(name);\n    }\n    stmt__POP() : NoArgStatement {\n        return { command:'POP' };\n    }\n    stmt__GET() : GET_Statement {\n        var lexpr = this.parseLexpr();\n        return { command:'GET', lexpr:lexpr };\n    }\n    stmt__CLEAR() : NoArgStatement {\n        return { command:'CLEAR' };\n    }\n    stmt__RANDOMIZE() : NoArgStatement {\n        return { command:'RANDOMIZE' };\n    }\n    stmt__CHANGE() : CHANGE_Statement {\n        var src = this.parseExpr();\n        this.expectToken('TO');\n        var dest = this.parseLexpr();\n        if (dest.valtype == src.valtype)\n            this.compileError(`CHANGE can only convert strings to numeric arrays, or vice-versa.`, mergeLocs(src.$loc, dest.$loc));\n        return { command:'CHANGE', src:src, dest:dest };\n    }\n    stmt__CONVERT() : CONVERT_Statement {\n        var src = this.parseExpr();\n        this.expectToken('TO');\n        var dest = this.parseLexpr();\n        if (dest.valtype == src.valtype)\n            this.compileError(`CONVERT can only convert strings to numbers, or vice-versa.`, mergeLocs(src.$loc, dest.$loc));\n        return { command:'CONVERT', src:src, dest:dest };\n    }\n    // TODO: CHANGE A TO A$ (4th edition, A(0) is len and A(1..) are chars)\n    stmt__OPTION() : OPTION_Statement {\n        this.optionCount++;\n        var tokname = this.consumeToken();\n        var optname = tokname.str.toUpperCase();\n        if (tokname.type != TokenType.Ident) this.compileError(`There must be a name after the OPTION statement.`)\n        var tokarg = this.consumeToken();\n        var arg = tokarg.str.toUpperCase();\n        switch (optname) {\n            case 'DIALECT':\n                if (this.optionCount > 1) this.compileError(`OPTION DIALECT must be the first OPTION statement in the file.`, tokname.$loc);\n                let dname = arg || \"\";\n                if (dname == \"\") this.compileError(`OPTION DIALECT requires a dialect name.`, tokname.$loc);\n                let dialect = DIALECTS[dname.toUpperCase()];\n                if (dialect) this.opts = dialect;\n                else this.compileError(`${dname} is not a valid dialect.`);\n                break;\n            case 'BASE':\n                let base = parseInt(arg);\n                if (base == 0 || base == 1) this.opts.defaultArrayBase = base;\n                else this.compileError(\"OPTION BASE can only be 0 or 1.\");\n                break;\n            case 'CPUSPEED':\n                if (!(this.opts.commandsPerSec = Math.min(1e7, arg=='MAX' ? Infinity : parseFloat(arg))))\n                    this.compileError(`OPTION CPUSPEED takes a positive number or MAX.`);\n                break;\n            default:\n                // maybe it's one of the options?\n                let propname = Object.getOwnPropertyNames(this.opts).find((n) => n.toUpperCase() == optname);\n                if (propname == null) this.compileError(`${optname} is not a valid option.`, tokname.$loc);\n                if (arg == null) this.compileError(`OPTION ${optname} requires a parameter.`);\n                switch (typeof this.opts[propname]) {\n                    case 'boolean' : this.opts[propname] = arg.toUpperCase().startsWith(\"T\") || (arg as any)>0; return;\n                    case 'number' : this.opts[propname] = parseFloat(arg); return;\n                    case 'string' : this.opts[propname] = arg; return;\n                    case 'object' :\n                        if (Array.isArray(this.opts[propname]) && arg == 'ALL') {\n                            this.opts[propname] = null;\n                            return;\n                        }\n                        this.compileError(`OPTION ${optname} ALL is the only option supported.`);\n                }\n                break;\n        }\n        return { command:'OPTION', optname:optname, optargs:[arg]}\n    }\n    \n    // for workermain\n    generateListing(file: string, program: BASICProgram) {\n        var srclines = [];\n        var laststmt : Statement;\n        program.stmts.forEach((stmt, idx) => {\n            laststmt = stmt;\n            srclines.push(stmt.$loc);\n        });\n        if (this.opts.endStmtRequired && (laststmt == null || laststmt.command != 'END'))\n            this.dialectError(`All programs must have a final END statement`);\n        return { lines: srclines };\n    }\n    getListings() : CodeListingMap {\n        return this.listings;\n    }\n\n    // LINT STUFF\n    checkAll(program : BASICProgram) {\n        this.checkLabels();\n        this.checkScopes();\n        this.checkVarRefs();\n    }\n    checkLabels() {\n        for (let targ in this.targets) {\n            if (this.labels[targ] == null) {\n                var what = this.opts.optionalLabels && isNaN(parseInt(targ)) ? \"label named\" : \"line number\";\n                this.addError(`There isn't a ${what} ${targ}.`, this.targets[targ]);\n            }\n        }\n    }\n    checkScopes() {\n        if (this.opts.compiledBlocks && this.scopestack.length) {\n            var open = this.stmts[this.scopestack.pop()];\n            var close = {FOR:\"NEXT\", WHILE:\"WEND\", IF:\"END IF\", SUB:\"END SUB\"};\n            this.compileError(`Don't forget to add a matching ${close[open.command]} statement.`, open.$loc);\n        }\n    }\n    checkVarRefs() {\n        if (!this.opts.defaultValues) {\n            for (var varname in this.varrefs) {\n                if (this.vardefs[varname] == null)\n                    this.compileError(`The variable ${varname} isn't defined anywhere in the program.`, this.varrefs[varname]);\n            }\n        }\n    }\n}\n\n///// BASIC DIALECTS\n\nexport const ECMA55_MINIMAL : BASICOptions = {\n    dialectName: \"ECMA55\",\n    asciiOnly : true,\n    uppercaseOnly : true,\n    optionalLabels : false,\n    optionalWhitespace : false,\n    multipleStmtsPerLine : false,\n    varNaming : \"A1\",\n    staticArrays : true,\n    sharedArrayNamespace : true,\n    defaultArrayBase : 0,\n    defaultArraySize : 11,\n    defaultValues : false,\n    stringConcat : false,\n    maxDimensions : 2,\n    maxDefArgs : 255,\n    maxStringLength : 255,\n    tickComments : false,\n    hexOctalConsts : false,\n    validKeywords : [\n        'BASE','DATA','DEF','DIM','END',\n        'FOR','GO','GOSUB','GOTO','IF','INPUT','LET','NEXT','ON','OPTION','PRINT',\n        'RANDOMIZE','READ','REM','RESTORE','RETURN','STEP','STOP','THEN','TO' // 'SUB'\n    ],\n    validFunctions : [\n        'ABS','ATN','COS','EXP','INT','LOG','RND','SGN','SIN','SQR','TAB','TAN'\n    ],\n    validOperators : [\n        '=', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '^'\n    ],\n    printZoneLength : 15,\n    numericPadding : true,\n    checkOverflow : true,\n    testInitialFor : true,\n    optionalNextVar : false,\n    multipleNextVars : false,\n    bitwiseLogic : false,\n    checkOnGotoIndex : true,\n    computedGoto : false,\n    restoreWithLabel : false,\n    squareBrackets : false,\n    arraysContainChars : false,\n    endStmtRequired : true,\n    chainAssignments : false,\n    optionalLet : false,\n    compiledBlocks : true,\n}\n\nexport const DARTMOUTH_4TH_EDITION : BASICOptions = {\n    dialectName: \"DARTMOUTH4\",\n    asciiOnly : true,\n    uppercaseOnly : true,\n    optionalLabels : false,\n    optionalWhitespace : false,\n    multipleStmtsPerLine : false,\n    varNaming : \"A1\",\n    staticArrays : true,\n    sharedArrayNamespace : false,\n    defaultArrayBase : 0,\n    defaultArraySize : 11,\n    defaultValues : false,\n    stringConcat : false,\n    maxDimensions : 2,\n    maxDefArgs : 255,\n    maxStringLength : 255,\n    tickComments : true,\n    hexOctalConsts : false,\n    validKeywords : [\n        'BASE','DATA','DEF','DIM','END',\n        'FOR','GO','GOSUB','GOTO','IF','INPUT','LET','NEXT','ON','OPTION','PRINT',\n        'RANDOMIZE','READ','REM','RESTORE','RETURN','STEP','STOP','THEN','TO', //'SUB',\n        'CHANGE','MAT','RANDOM','RESTORE$','RESTORE*',\n    ],\n    validFunctions : [\n        'ABS','ATN','COS','EXP','INT','LOG','RND','SGN','SIN','SQR','TAB','TAN',\n        'TRN','INV','DET','NUM','ZER', // NUM = # of strings input for MAT INPUT\n    ],\n    validOperators : [\n        '=', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '^'\n    ],\n    printZoneLength : 15,\n    numericPadding : true,\n    checkOverflow : true,\n    testInitialFor : true,\n    optionalNextVar : false,\n    multipleNextVars : false,\n    bitwiseLogic : false,\n    checkOnGotoIndex : true,\n    computedGoto : false,\n    restoreWithLabel : false,\n    squareBrackets : false,\n    arraysContainChars : false,\n    endStmtRequired : true,\n    chainAssignments : true,\n    optionalLet : false,\n    compiledBlocks : true,\n}\n\n// TODO: only integers supported\nexport const TINY_BASIC : BASICOptions = {\n    dialectName: \"TINY\",\n    asciiOnly : true,\n    uppercaseOnly : true,\n    optionalLabels : false,\n    optionalWhitespace : false,\n    multipleStmtsPerLine : false,\n    varNaming : \"A\",\n    staticArrays : false,\n    sharedArrayNamespace : true,\n    defaultArrayBase : 0,\n    defaultArraySize : 0,\n    defaultValues : true,\n    stringConcat : false,\n    maxDimensions : 0,\n    maxDefArgs : 255,\n    maxStringLength : 255,\n    tickComments : false,\n    hexOctalConsts : false,\n    validKeywords : [\n        'OPTION',\n        'PRINT','IF','THEN','GOTO','INPUT','LET','GOSUB','RETURN','CLEAR','END'\n    ],\n    validFunctions : [\n    ],\n    validOperators : [\n        '=', '<>', '><', '<', '>', '<=', '>=', '+', '-', '*', '/',\n    ],\n    printZoneLength : 1,\n    numericPadding : false,\n    checkOverflow : false,\n    testInitialFor : false,\n    optionalNextVar : false,\n    multipleNextVars : false,\n    bitwiseLogic : false,\n    checkOnGotoIndex : false,\n    computedGoto : true,\n    restoreWithLabel : false,\n    squareBrackets : false,\n    arraysContainChars : false,\n    endStmtRequired : false,\n    chainAssignments : false,\n    optionalLet : false,\n    compiledBlocks : false,\n}\n\nexport const HP_TIMESHARED_BASIC : BASICOptions = {\n    dialectName: \"HP2000\",\n    asciiOnly : true,\n    uppercaseOnly : true, // the terminal is usually uppercase\n    optionalLabels : false,\n    optionalWhitespace : false,\n    multipleStmtsPerLine : true,\n    varNaming : \"A1$\",\n    staticArrays : true,\n    sharedArrayNamespace : false,\n    defaultArrayBase : 1,\n    defaultArraySize : 11,\n    defaultValues : false,\n    stringConcat : false,\n    maxDimensions : 2,\n    maxDefArgs : 255,\n    maxStringLength : 255, // 72 for literals\n    tickComments : false, // TODO: HP BASIC has 'hh char constants\n    hexOctalConsts : false,\n    validKeywords : [\n        'BASE','DATA','DEF','DIM','END',\n        'FOR','GO','GOSUB','GOTO','IF','INPUT','LET','NEXT','OPTION','PRINT',\n        'RANDOMIZE','READ','REM','RESTORE','RETURN','STEP','STOP','THEN','TO', //'SUB',\n        'ENTER','MAT','CONVERT','OF','IMAGE','USING'\n    ],\n    validFunctions : [\n        'ABS','ATN','BRK','COS','CTL','EXP','INT','LEN','LIN','LOG','NUM',\n        'POS','RND','SGN','SIN','SPA','SQR','TAB','TAN','TIM','TYP','UPS$', // TODO: POS,\n        'NFORMAT$', // non-standard, substitute for PRINT USING\n    ],\n    validOperators : [\n        '=', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '^',\n        '**', '#', 'NOT', 'AND', 'OR', 'MIN', 'MAX',\n    ],\n    printZoneLength : 15,\n    numericPadding : true,\n    checkOverflow : false,\n    testInitialFor : true,\n    optionalNextVar : false,\n    multipleNextVars : false,\n    bitwiseLogic : false,\n    checkOnGotoIndex : false,\n    computedGoto : true, // not really, but we do parse expressions for GOTO ... OF \n    restoreWithLabel : true,\n    squareBrackets : true,\n    arraysContainChars : true,\n    endStmtRequired : true,\n    chainAssignments : true,\n    optionalLet : true,\n    compiledBlocks : true,\n    maxArrayElements : 5000,\n    // TODO: max line number\n}\n\nexport const DEC_BASIC_11 : BASICOptions = {\n    dialectName: \"DEC11\",\n    asciiOnly : true,\n    uppercaseOnly : true, // translates all lower to upper\n    optionalLabels : false,\n    optionalWhitespace : false,\n    multipleStmtsPerLine : false, // actually \"\\\"\n    varNaming : \"A1\",\n    staticArrays : true,\n    sharedArrayNamespace : false,\n    defaultArrayBase : 0,\n    defaultArraySize : 11,\n    defaultValues : true,\n    stringConcat : true, // can also use &\n    maxDimensions : 2,\n    maxDefArgs : 255, // ?\n    maxStringLength : 255,\n    tickComments : false,\n    hexOctalConsts : false,\n    validKeywords : [\n        'OPTION',\n        'DATA','DEF','DIM','END','FOR','STEP','GOSUB','GOTO','GO','TO',\n        'IF','THEN','INPUT','LET','NEXT','ON','PRINT','RANDOMIZE',\n        'READ','REM','RESET','RESTORE','RETURN','STOP',\n    ],\n    validFunctions : [\n        'ABS','ATN','COS','EXP','INT','LOG','LOG10','PI','RND','SGN','SIN','SQR','TAB',\n        'ASC','BIN','CHR$','CLK$','DAT$','LEN','OCT','POS','SEG$','STR$','TRM$','VAL',\n        'NFORMAT$', // non-standard, substitute for PRINT USING\n    ],\n    validOperators : [\n        '=', '<>', '><', '<', '>', '<=', '>=', '+', '-', '*', '/', '^',\n    ],\n    printZoneLength : 14,\n    numericPadding : true,\n    checkOverflow : true, // non-fatal; subst 0 and continue\n    testInitialFor : true,\n    optionalNextVar : false,\n    multipleNextVars : false,\n    bitwiseLogic : false,\n    checkOnGotoIndex : true, // might continue\n    computedGoto : false,\n    restoreWithLabel : false,\n    squareBrackets : false,\n    arraysContainChars : false,\n    endStmtRequired : false,\n    chainAssignments : false,\n    optionalLet : true,\n    compiledBlocks : true,\n    // TODO: max line number 32767\n    // TODO: \\ separator, % int vars and constants, 'single' quoted\n    // TODO: can't compare strings and numbers\n}\n\nexport const DEC_BASIC_PLUS : BASICOptions = {\n    dialectName: \"DECPLUS\",\n    asciiOnly : true,\n    uppercaseOnly : false,\n    optionalLabels : false,\n    optionalWhitespace : false,\n    multipleStmtsPerLine : true,\n    varNaming : \"A1\",\n    staticArrays : true,\n    sharedArrayNamespace : false,\n    defaultArrayBase : 0,\n    defaultArraySize : 11,\n    defaultValues : true,\n    stringConcat : true, // can also use \"&\"\n    maxDimensions : 2,\n    maxDefArgs : 255, // ?\n    maxStringLength : 255,\n    tickComments : true, // actually use \"!\"\n    hexOctalConsts : false,\n    validKeywords : [\n        'OPTION',\n        'REM','LET','DIM','RANDOM','RANDOMIZE','IF','THEN','ELSE',\n        'FOR','TO','STEP','WHILE','UNTIL','NEXT','DEF','ON','GOTO','GOSUB',\n        'RETURN','CHANGE','READ','DATA','RESTORE','PRINT','USING',\n        'INPUT','LINE','NAME','AS','ERROR','RESUME','CHAIN','STOP','END',\n        'MAT','UNLESS','SLEEP','WAIT',\n    ],\n    validFunctions : [\n        'ABS','ATN','COS','EXP','INT','LOG','LOG10','PI','RND','SGN','SIN','SQR','TAB','TAN',\n        'POS','TAB','ASCII','CHR$','CVT%$','CVTF$','CVT$%','CVT$F',\n        'LEFT$','RIGHT$','MID$','LEN','INSTR','SPACE$','NUM$','VAL','XLATE',\n        'DATE$','TIME$','TIME','ERR','ERL','SWAP%','RAD$',\n        'NFORMAT$', // non-standard, substitute for PRINT USING\n    ],\n    validOperators : [\n        '=', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '^',\n        '**', '==',\n        'NOT', 'AND', 'OR', 'XOR', 'IMP', 'EQV',\n    ],\n    printZoneLength : 14,\n    numericPadding : true,\n    checkOverflow : true, // non-fatal; subst 0 and continue\n    testInitialFor : true,\n    optionalNextVar : false,\n    multipleNextVars : false,\n    bitwiseLogic : false,\n    checkOnGotoIndex : true, // might continue\n    computedGoto : false,\n    restoreWithLabel : false,\n    squareBrackets : false,\n    arraysContainChars : false,\n    endStmtRequired : false,\n    chainAssignments : false, // TODO: can chain with \",\" not \"=\"\n    optionalLet : true,\n    compiledBlocks : true,\n    // TODO: max line number 32767\n    // TODO: \\ separator, % int vars and constants, 'single' quoted\n    // TODO: can't compare strings and numbers\n    // TODO: WHILE/UNTIL/FOR extra statements, etc\n}\n\nexport const BASICODE : BASICOptions = {\n    dialectName: \"BASICODE\",\n    asciiOnly : true,\n    uppercaseOnly : false,\n    optionalLabels : false,\n    optionalWhitespace : true,\n    multipleStmtsPerLine : true,\n    varNaming : \"AA\",\n    staticArrays : true,\n    sharedArrayNamespace : false,\n    defaultArrayBase : 0,\n    defaultArraySize : 11,\n    defaultValues : false,\n    stringConcat : true,\n    maxDimensions : 2,\n    maxDefArgs : 255,\n    maxStringLength : 255,\n    tickComments : false,\n    hexOctalConsts : false,\n    validKeywords : [\n        'BASE','DATA','DEF','DIM','END',\n        'FOR','GO','GOSUB','GOTO','IF','INPUT','LET','NEXT','ON','OPTION','PRINT',\n        'READ','REM','RESTORE','RETURN','STEP','STOP','THEN','TO', // 'SUB',\n        'AND', 'NOT', 'OR'\n    ],\n    validFunctions : [\n        'ABS','ASC','ATN','CHR$','COS','EXP','INT','LEFT$','LEN','LOG',    \n        'MID$','RIGHT$','SGN','SIN','SQR','TAB','TAN','VAL'\n    ],\n    validOperators : [\n        '=', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '^', 'AND', 'NOT', 'OR'\n    ],\n    printZoneLength : 15,\n    numericPadding : true,\n    checkOverflow : true,\n    testInitialFor : true,\n    optionalNextVar : false,\n    multipleNextVars : false,\n    bitwiseLogic : false,\n    checkOnGotoIndex : true,\n    computedGoto : false,\n    restoreWithLabel : false,\n    squareBrackets : false,\n    arraysContainChars : false,\n    endStmtRequired : false,\n    chainAssignments : false,\n    optionalLet : true,\n    compiledBlocks : false,\n}\n\nexport const ALTAIR_BASIC41 : BASICOptions = {\n    dialectName: \"ALTAIR41\",\n    asciiOnly : true,\n    uppercaseOnly : true,\n    optionalLabels : false,\n    optionalWhitespace : true,\n    multipleStmtsPerLine : true,\n    varNaming : \"*\", // or AA\n    staticArrays : false,\n    sharedArrayNamespace : true,\n    defaultArrayBase : 0,\n    defaultArraySize : 11,\n    defaultValues : true,\n    stringConcat : true,\n    maxDimensions : 128, // \"as many as will fit on a single line\" ... ?\n    maxDefArgs : 255,\n    maxStringLength : 255,\n    tickComments : false,\n    hexOctalConsts : false,\n    validKeywords : [\n        'OPTION',\n        'CONSOLE','DATA','DEF','DEFUSR','DIM','END','ERASE','ERROR',\n        'FOR','GOTO','GOSUB','IF','THEN','ELSE','INPUT','LET','LINE',\n        'PRINT','LPRINT','USING','NEXT','ON','OUT','POKE',\n        'READ','REM','RESTORE','RESUME','RETURN','STOP','SWAP',\n        'TROFF','TRON','WAIT',\n        'TO','STEP',\n        'AND', 'NOT', 'OR', 'XOR', 'IMP', 'EQV', 'MOD',\n        'RANDOMIZE' // not in Altair BASIC, but we add it anyway\n    ],\n    validFunctions : [\n        'ABS','ASC','ATN','CDBL','CHR$','CINT','COS','ERL','ERR',\n        'EXP','FIX','FRE','HEX$','INP','INSTR','INT',\n        'LEFT$','LEN','LOG','LPOS','MID$',\n        'OCT$','POS','RIGHT$','RND','SGN','SIN','SPACE$','SPC',\n        'SQR','STR$','STRING$','TAB','TAN','USR','VAL','VARPTR'\n    ],\n    validOperators : [\n        '=', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '^', '\\\\',\n        'AND', 'NOT', 'OR', 'XOR', 'IMP', 'EQV', 'MOD'\n    ],\n    printZoneLength : 15,\n    numericPadding : true,\n    checkOverflow : true,\n    testInitialFor : false,\n    optionalNextVar : true,\n    multipleNextVars : true,\n    bitwiseLogic : true,\n    checkOnGotoIndex : false,\n    computedGoto : false,\n    restoreWithLabel : false,\n    squareBrackets : false,\n    arraysContainChars : false,\n    endStmtRequired : false,\n    chainAssignments : false,\n    optionalLet : true,\n    compiledBlocks : false,\n}\n\nexport const APPLESOFT_BASIC : BASICOptions = {\n    dialectName: \"APPLESOFT\",\n    asciiOnly : true,\n    uppercaseOnly : false,\n    optionalLabels : false,\n    optionalWhitespace : true,\n    multipleStmtsPerLine : true,\n    varNaming : \"*\", // or AA\n    staticArrays : false,\n    sharedArrayNamespace : false,\n    defaultArrayBase : 0,\n    defaultArraySize : 11,\n    defaultValues : true,\n    stringConcat : true,\n    maxDimensions : 88,\n    maxDefArgs : 1, // TODO: no string FNs\n    maxStringLength : 255,\n    tickComments : false,\n    hexOctalConsts : false,\n    validKeywords : [\n        'OPTION',\n        'CLEAR','LET','DIM','DEF','GOTO','GOSUB','RETURN','ON','POP',\n        'FOR','NEXT','IF','THEN','END','STOP','ONERR','RESUME',\n        'PRINT','INPUT','GET','HOME','HTAB','VTAB',\n        'INVERSE','FLASH','NORMAL','TEXT',\n        'GR','COLOR','PLOT','HLIN','VLIN',\n        'HGR','HGR2','HPLOT','HCOLOR','AT',\n        'DATA','READ','RESTORE',\n        'REM','TRACE','NOTRACE',\n        'TO','STEP',\n        'AND', 'NOT', 'OR'\n    ],\n    validFunctions : [\n        'ABS','ATN','COS','EXP','INT','LOG','RND','SGN','SIN','SQR','TAN',\n        'LEN','LEFT$','MID$','RIGHT$','STR$','VAL','CHR$','ASC',\n        'FRE','SCRN','PDL','PEEK','POS'\n    ],\n    validOperators : [\n        '=', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '^',\n        'AND', 'NOT', 'OR'\n    ],\n    printZoneLength : 16,\n    numericPadding : false,\n    checkOverflow : true,\n    testInitialFor : false,\n    optionalNextVar : true,\n    multipleNextVars : true,\n    bitwiseLogic : false,\n    checkOnGotoIndex : false,\n    computedGoto : false,\n    restoreWithLabel : false,\n    squareBrackets : false,\n    arraysContainChars : false,\n    endStmtRequired : false,\n    chainAssignments : false,\n    optionalLet : true,\n    compiledBlocks : false,\n}\n\nexport const BASIC80 : BASICOptions = {\n    dialectName: \"BASIC80\",\n    asciiOnly : true,\n    uppercaseOnly : false,\n    optionalLabels : false,\n    optionalWhitespace : true,\n    multipleStmtsPerLine : true,\n    varNaming : \"*\",\n    staticArrays : false,\n    sharedArrayNamespace : true,\n    defaultArrayBase : 0,\n    defaultArraySize : 11,\n    defaultValues : true,\n    stringConcat : true,\n    maxDimensions : 255,\n    maxDefArgs : 255,\n    maxStringLength : 255,\n    //maxElements : 32767, // TODO\n    tickComments : true,\n    hexOctalConsts : true,\n    validKeywords : [\n        'OPTION',\n        'CONSOLE','DATA','DEF','DEFUSR','DIM','END','ERASE','ERROR',\n        'FOR','GOTO','GOSUB','IF','THEN','ELSE','INPUT','LET','LINE',\n        'PRINT','LPRINT','USING','NEXT','ON','OUT','POKE',\n        'READ','REM','RESTORE','RESUME','RETURN','STOP','SWAP',\n        'TROFF','TRON','WAIT',\n        'CALL','CHAIN','COMMON','WHILE','WEND','WRITE','RANDOMIZE',\n        'TO','STEP',\n        'AND', 'NOT', 'OR', 'XOR', 'IMP', 'EQV', 'MOD'\n    ],\n    validFunctions : [\n        'ABS','ASC','ATN','CDBL','CHR$','CINT','COS','CSNG','CVI','CVS','CVD',\n        'EOF','EXP','FIX','FRE','HEX$','INP','INPUT$','INSTR','INT',\n        'LEFT$','LEN','LOC','LOG','LPOS','MID$','MKI$','MKS$','MKD$',\n        'OCT$','PEEK','POS','RIGHT$','RND','SGN','SIN','SPACE$','SPC',\n        'SQR','STR$','STRING$','TAB','TAN','USR','VAL','VARPTR'\n    ],\n    validOperators : [\n        '=', '<>', '<', '>', '<=', '>=', '+', '-', '*', '/', '^', '\\\\',\n        'AND', 'NOT', 'OR', 'XOR', 'IMP', 'EQV', 'MOD'\n    ],\n    printZoneLength : 14,\n    numericPadding : true,\n    checkOverflow : false, // TODO: message displayed when overflow, division by zero = ok\n    testInitialFor : true,\n    optionalNextVar : true,\n    multipleNextVars : true,\n    bitwiseLogic : true,\n    checkOnGotoIndex : false,\n    computedGoto : false,\n    restoreWithLabel : true,\n    squareBrackets : false,\n    arraysContainChars : false,\n    endStmtRequired : false,\n    chainAssignments : false,\n    optionalLet : true,\n    compiledBlocks : false,\n}\n\nexport const MODERN_BASIC : BASICOptions = {\n    dialectName: \"MODERN\",\n    asciiOnly : false,\n    uppercaseOnly : false,\n    optionalLabels : true,\n    optionalWhitespace : false,\n    multipleStmtsPerLine : true,\n    varNaming : \"*\",\n    staticArrays : false,\n    sharedArrayNamespace : false,\n    defaultArrayBase : 0,\n    defaultArraySize : 0, // DIM required\n    defaultValues : false,\n    stringConcat : true,\n    maxDimensions : 255,\n    maxDefArgs : 255,\n    maxStringLength : 2048, // TODO?\n    tickComments : true,\n    hexOctalConsts : true,\n    validKeywords : null, // all\n    validFunctions : null, // all\n    validOperators : null, // all\n    printZoneLength : 16,\n    numericPadding : false,\n    checkOverflow : true,\n    testInitialFor : true,\n    optionalNextVar : true,\n    multipleNextVars : true,\n    bitwiseLogic : true,\n    checkOnGotoIndex : true,\n    computedGoto : false,\n    restoreWithLabel : true,\n    squareBrackets : true,\n    arraysContainChars : false,\n    endStmtRequired : false,\n    chainAssignments : true,\n    optionalLet : true,\n    compiledBlocks : true,\n    multilineIfThen : true,\n}\n\n// TODO: integer vars\n// TODO: DEFINT/DEFSTR\n// TODO: excess INPUT ignored, error msg\n// TODO: out of order line numbers\n\ntype BuiltinFunctionDef = [string, ValueType[], ValueType];\n\nconst BUILTIN_DEFS : BuiltinFunctionDef[] = [\n    ['ABS', ['number'], 'number' ],\n    ['ASC', ['string'], 'number' ],\n    ['ATN', ['number'], 'number' ],\n    ['CHR$', ['number'], 'string' ],\n    ['CINT', ['number'], 'number' ],\n    ['COS', ['number'], 'number' ],\n    ['COT', ['number'], 'number' ],\n    ['CTL', ['number'], 'string' ],\n    ['EXP', ['number'], 'number' ],\n    ['FIX', ['number'], 'number' ],\n    ['HEX$', ['number'], 'string' ],\n    ['INSTR', ['number', 'string', 'string'], 'number' ],\n    ['INSTR', ['string', 'string'], 'number' ],\n    ['INT', ['number'], 'number' ],\n    ['LEFT$', ['string', 'number'], 'string' ],\n    ['LEN', ['string'], 'number' ],\n    ['LIN', ['number'], 'string' ],\n    ['LOG', ['number'], 'number' ],\n    ['LOG10', ['number'], 'number' ],\n    ['MID$', ['string', 'number'], 'string'],\n    ['MID$', ['string', 'number', 'number'], 'string'],\n    ['OCT$', ['number'], 'string' ],\n    ['PI', [], 'number'],\n    ['POS', ['number'], 'number' ], // arg ignored\n    ['POS', ['string','string'], 'number' ], // HP POS\n    ['RIGHT$', ['string', 'number'], 'string' ],\n    ['RND', [], 'number' ],\n    ['RND', ['number'], 'number' ],\n    ['ROUND', ['number'], 'number' ],\n    ['SGN', ['number'], 'number' ],\n    ['SIN', ['number'], 'number' ],\n    ['SPACE$', ['number'], 'string' ],\n    ['SPC', ['number'], 'string' ],\n    ['SQR', ['number'], 'number' ],\n    ['STR$', ['number'], 'string' ],\n    ['STRING$', ['number', 'number'], 'string'],\n    ['STRING$', ['number', 'string'], 'string'],\n    ['TAB', ['number'], 'string' ],\n    ['TAN', ['number'], 'number' ],\n    ['TIM', ['number'], 'number' ], // only HP BASIC?\n    ['TIMER', [], 'number' ],\n    ['UPS$', ['string'], 'string' ],\n    ['VAL', ['string'], 'number' ],\n    ['LPAD$', ['string', 'number'], 'string' ],\n    ['RPAD$', ['string', 'number'], 'string' ],\n    ['NFORMAT$', ['number', 'number'], 'string' ],\n];\n\nvar BUILTIN_MAP : { [name:string] : {args:ValueType[], result:ValueType}[] } = {};\nBUILTIN_DEFS.forEach( (def, idx) => {\n    let [name, args, result] = def;\n    if (!BUILTIN_MAP[name]) BUILTIN_MAP[name] = [];\n    BUILTIN_MAP[name].push({args: args, result: result});\n});\n\nexport const DIALECTS = {\n    \"DEFAULT\":      MODERN_BASIC,\n    \"DARTMOUTH\":    DARTMOUTH_4TH_EDITION,\n    \"DARTMOUTH4\":   DARTMOUTH_4TH_EDITION,\n    \"ALTAIR\":       ALTAIR_BASIC41,\n    \"ALTAIR4\":      ALTAIR_BASIC41,\n    \"ALTAIR41\":     ALTAIR_BASIC41,\n    \"TINY\":         TINY_BASIC,\n    \"ECMA55\":       ECMA55_MINIMAL,\n    \"MINIMAL\":      ECMA55_MINIMAL,\n    \"HP\":           HP_TIMESHARED_BASIC,\n    \"HPB\":          HP_TIMESHARED_BASIC,\n    \"HPTSB\":        HP_TIMESHARED_BASIC,\n    \"HP2000\":       HP_TIMESHARED_BASIC,\n    \"HPBASIC\":      HP_TIMESHARED_BASIC,\n    \"HPACCESS\":     HP_TIMESHARED_BASIC,\n    \"DEC11\":        DEC_BASIC_11,\n    \"DEC\":          DEC_BASIC_PLUS,\n    \"DECPLUS\":      DEC_BASIC_PLUS,\n    \"BASICPLUS\":    DEC_BASIC_PLUS,\n    \"BASICODE\":     BASICODE,\n    \"APPLESOFT\":    APPLESOFT_BASIC,\n    \"BASIC80\":      BASIC80,\n    \"MODERN\":       MODERN_BASIC,\n};\n", "import { Segment, CodeListingMap, WorkerResult, WorkerError } from \"../../common/workertypes\";\nimport { BuildStep, BuildStepResult, setupRequireFunction, load, emglobal, getWorkFileAsString, loadNative, gatherFiles, staleFiles, msvcErrorMatcher, moduleInstFn, setupFS, populateFiles, execMain, putWorkFile, anyTargetChanged, parseListing, print_fn, makeErrorMatcher, populateExtraFiles } from \"../workermain\";\nimport { EmscriptenModule } from \"../workermain\"\nimport * as basic_compiler from '../../common/basic/compiler';\nimport { parseXMLPoorly } from \"../../common/util\";\n\nexport function translateShowdown(step: BuildStep): BuildStepResult {\n    setupRequireFunction();\n    load(\"showdown.min\");\n    var showdown = emglobal['showdown'];\n    var converter = new showdown.Converter({\n        tables: 'true',\n        smoothLivePreview: 'true',\n        requireSpaceBeforeHeadingText: 'true',\n        emoji: 'true',\n    });\n    var code = getWorkFileAsString(step.path);\n    var html = converter.makeHtml(code);\n    delete emglobal['require'];\n    return {\n        output: html\n    };\n}\n\nexport function compileInform6(step: BuildStep): BuildStepResult {\n    loadNative(\"inform\");\n    var errors = [];\n    gatherFiles(step, { mainFilePath: \"main.inf\" });\n    var objpath = step.prefix + \".z5\";\n    if (staleFiles(step, [objpath])) {\n        var errorMatcher = msvcErrorMatcher(errors);\n        var lstout = \"\";\n        var match_fn = (s: string) => {\n            if (s.indexOf(\"Error:\") >= 0) {\n                errorMatcher(s);\n            } else {\n                lstout += s;\n                lstout += \"\\n\";\n            }\n        }\n        // TODO: step.path must end in '.inf' or error\n        var args = ['-afjnops', '-v5', '-Cu', '-E1', '-k', '+/share/lib', step.path];\n        var inform: EmscriptenModule = emglobal.inform({\n            instantiateWasm: moduleInstFn('inform'),\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: match_fn,\n            printErr: match_fn,\n        });\n        var FS = inform.FS;\n        setupFS(FS, 'inform');\n        populateFiles(step, FS);\n        //fixParamsWithDefines(step.path, step.params);\n        execMain(step, inform, args);\n        if (errors.length)\n            return { errors: errors };\n        var objout = FS.readFile(objpath, { encoding: 'binary' });\n        putWorkFile(objpath, objout);\n        if (!anyTargetChanged(step, [objpath]))\n            return;\n\n        // parse debug XML\n        var symbolmap = {};\n        var segments: Segment[] = [];\n        var entitymap = {\n            // number -> string\n            'object': {}, 'property': {}, 'attribute': {}, 'constant': {}, 'global-variable': {}, 'routine': {},\n        };\n        var dbgout = FS.readFile(\"gameinfo.dbg\", { encoding: 'utf8' });\n        var xmlroot = parseXMLPoorly(dbgout);\n        //console.log(xmlroot);\n        var segtype = \"ram\";\n        xmlroot.children.forEach((node) => {\n            switch (node.type) {\n                case 'global-variable':\n                case 'routine':\n                    var ident = node.children.find((c, v) => c.type == 'identifier').text;\n                    var address = parseInt(node.children.find((c, v) => c.type == 'address').text);\n                    symbolmap[ident] = address;\n                    entitymap[node.type][address] = ident;\n                    break;\n                case 'object':\n                case 'property':\n                case 'attribute':\n                    var ident = node.children.find((c, v) => c.type == 'identifier').text;\n                    var value = parseInt(node.children.find((c, v) => c.type == 'value').text);\n                    //entitymap[node.type][ident] = value;\n                    entitymap[node.type][value] = ident;\n                    //symbolmap[ident] = address | 0x1000000;\n                    break;\n                case 'story-file-section':\n                    var name = node.children.find((c, v) => c.type == 'type').text;\n                    var address = parseInt(node.children.find((c, v) => c.type == 'address').text);\n                    var endAddress = parseInt(node.children.find((c, v) => c.type == 'end-address').text);\n                    if (name == \"grammar table\") segtype = \"rom\";\n                    segments.push({ name: name, start: address, size: endAddress - address, type: segtype });\n            }\n        });\n        // parse listing\n        var listings: CodeListingMap = {};\n        //    35  +00015 <*> call_vs      long_19 location long_424 -> sp \n        var lines = parseListing(lstout, /\\s*(\\d+)\\s+[+]([0-9a-f]+)\\s+([<*>]*)\\s*(\\w+)\\s+(.+)/i, -1, 2, 4);\n        var lstpath = step.prefix + '.lst';\n        listings[lstpath] = { lines: [], asmlines: lines, text: lstout };\n        return {\n            output: objout, //.slice(0),\n            listings: listings,\n            errors: errors,\n            symbolmap: symbolmap,\n            segments: segments,\n            debuginfo: entitymap,\n        };\n    }\n}\n\nexport function compileBASIC(step: BuildStep): WorkerResult {\n    var jsonpath = step.path + \".json\";\n    gatherFiles(step);\n    if (staleFiles(step, [jsonpath])) {\n        var parser = new basic_compiler.BASICParser();\n        var code = getWorkFileAsString(step.path);\n        try {\n            var ast = parser.parseFile(code, step.path);\n        } catch (e) {\n            console.log(e);\n            if (parser.errors.length == 0) throw e;\n        }\n        if (parser.errors.length) {\n            return { errors: parser.errors };\n        }\n        // put AST into JSON (sans source locations) to see if it has changed\n        var json = JSON.stringify(ast, (key, value) => { return (key == '$loc' ? undefined : value) });\n        putWorkFile(jsonpath, json);\n        if (anyTargetChanged(step, [jsonpath])) return {\n            output: ast,\n            listings: parser.getListings(),\n        };\n    }\n}\n\nexport function compileWiz(step: BuildStep): WorkerResult {\n    loadNative(\"wiz\");\n    var params = step.params;\n    gatherFiles(step, { mainFilePath: \"main.wiz\" });\n    var destpath = step.prefix + (params.wiz_rom_ext || \".bin\");\n    var errors: WorkerError[] = [];\n    if (staleFiles(step, [destpath])) {\n        var wiz: EmscriptenModule = emglobal.wiz({\n            instantiateWasm: moduleInstFn('wiz'),\n            noInitialRun: true,\n            print: print_fn,\n            //test.wiz:2: error: expected statement, but got identifier `test`\n            printErr: makeErrorMatcher(errors, /(.+?):(\\d+):\\s*(.+)/, 2, 3, step.path, 1),\n        });\n        var FS = wiz.FS;\n        setupFS(FS, 'wiz');\n        populateFiles(step, FS);\n        populateExtraFiles(step, FS, params.extra_compile_files);\n        const FWDIR = '/share/common';\n        var args = [\n            '-o', destpath,\n            '-I', FWDIR + '/' + (params.wiz_inc_dir || step.platform),\n            '-s', 'wla',\n            '--color=none',\n            step.path];\n        args.push('--system', params.wiz_sys_type || params.arch);\n        execMain(step, wiz, args);\n        if (errors.length)\n            return { errors: errors };\n        var binout = FS.readFile(destpath, { encoding: 'binary' });\n        putWorkFile(destpath, binout);\n        var dbgout = FS.readFile(step.prefix + '.sym', { encoding: 'utf8' });\n        var symbolmap = {};\n        for (var s of dbgout.split(\"\\n\")) {\n            var toks = s.split(/ /);\n            // 00:4008 header.basic_start\n            if (toks && toks.length >= 2) {\n                var tokrange = toks[0].split(':');\n                var start = parseInt(tokrange[1], 16);\n                var sym = toks[1];\n                symbolmap[sym] = start;\n            }\n        }\n        return {\n            output: binout, //.slice(0),\n            errors: errors,\n            symbolmap: symbolmap,\n        };\n    }\n}\n\n", "\nimport { getFilenamePrefix, getRootBasePlatform } from \"../../common/util\";\nimport { CodeListingMap, WorkerError } from \"../../common/workertypes\";\nimport { re_crlf, BuildStepResult, anyTargetChanged, execMain, gatherFiles, msvcErrorMatcher, populateEntry, populateExtraFiles, populateFiles, print_fn, putWorkFile, setupFS, staleFiles, BuildStep, emglobal, loadNative, moduleInstFn, fixParamsWithDefines, store, makeErrorMatcher, getWorkFileAsString } from \"../workermain\";\nimport { EmscriptenModule } from \"../workermain\"\n\n\n/*\n000000r 1               .segment        \"CODE\"\n000000r 1               .proc\t_rasterWait: near\n000000r 1               ; int main() { return mul2(2); }\n000000r 1                       .dbg    line, \"main.c\", 3\n000014r 1                      \t.dbg\t  func, \"main\", \"00\", extern, \"_main\"\n000000r 1  A2 00                ldx     #$00\n00B700  1               BOOT2:\n00B700  1  A2 01         ldx #1 ;track\n00B725  1  00           IBLASTDRVN: .byte 0\n00B726  1  xx xx        IBSECSZ: .res 2\n00BA2F  1  2A 2B E8 2C   HEX \"2A2BE82C2D2E2F303132F0F133343536\"\n*/\nfunction parseCA65Listing(code: string, symbols, segments, params, dbg: boolean, listings?: CodeListingMap) {\n    var segofs = 0;\n    var offset = 0;\n    var dbgLineMatch = /^([0-9A-F]+)([r]?)\\s+(\\d+)\\s+[.]dbg\\s+(\\w+), \"([^\"]+)\", (.+)/;\n    var funcLineMatch = /\"(\\w+)\", (\\w+), \"(\\w+)\"/;\n    var insnLineMatch = /^([0-9A-F]+)([r]?)\\s{1,2}(\\d+)\\s{1,2}([0-9A-Frx ]{11})\\s+(.*)/;\n    var segMatch = /[.]segment\\s+\"(\\w+)\"/i;\n    var origlines = [];\n    var lines = origlines;\n    var linenum = 0;\n    let curpath = '';\n    // TODO: only does .c functions, not all .s files\n    for (var line of code.split(re_crlf)) {\n        var dbgm = dbgLineMatch.exec(line);\n        if (dbgm && dbgm[1]) {\n            var dbgtype = dbgm[4];\n            offset = parseInt(dbgm[1], 16);\n            curpath = dbgm[5];\n            // new file?\n            if (curpath && listings) {\n                let l = listings[curpath];\n                if (!l) l = listings[curpath] = {lines:[]};\n                lines = l.lines;\n            }\n            if (dbgtype == 'func') {\n                var funcm = funcLineMatch.exec(dbgm[6]);\n                if (funcm) {\n                    var funcofs = symbols[funcm[3]];\n                    if (typeof funcofs === 'number') {\n                        segofs = funcofs - offset;\n                        //console.log(funcm[3], funcofs, '-', offset);\n                    }\n                }\n            }\n        }\n        if (dbg && dbgm && dbgtype == 'line') {\n            //console.log(dbgm[5], dbgm[6], offset, segofs);\n            lines.push({\n                path: dbgm[5],\n                line: parseInt(dbgm[6]),\n                offset: offset + segofs,\n                insns: null\n            });\n        }\n        linenum++;\n        var linem = insnLineMatch.exec(line);\n        var topfile = linem && linem[3] == '1';\n        if (topfile && linem[1]) {\n            var offset = parseInt(linem[1], 16);\n            var insns = linem[4].trim();\n            if (insns.length) {\n                if (!dbg) {\n                    lines.push({\n                        path: curpath,\n                        line: linenum,\n                        offset: offset + segofs,\n                        insns: insns,\n                        iscode: true // TODO: can't really tell unless we parse it\n                    });\n                }\n            } else {\n                var sym = linem[5];\n                if (sym.endsWith(':') && !sym.startsWith('@')) {\n                    var symofs = symbols[sym.substring(0, sym.length - 1)];\n                    if (typeof symofs === 'number') {\n                        segofs = symofs - offset;\n                        //console.log(sym, segofs, symofs, '-', offset);\n                    }\n                }\n            }\n        }\n    }\n    return origlines;\n}\n\nexport function assembleCA65(step: BuildStep): BuildStepResult {\n    loadNative(\"ca65\");\n    var errors = [];\n    gatherFiles(step, { mainFilePath: \"main.s\" });\n    var objpath = step.prefix + \".o\";\n    var lstpath = step.prefix + \".lst\";\n    if (staleFiles(step, [objpath, lstpath])) {\n        var objout, lstout;\n        var CA65: EmscriptenModule = emglobal.ca65({\n            instantiateWasm: moduleInstFn('ca65'),\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: print_fn,\n            printErr: makeErrorMatcher(errors, /(.+?):(\\d+): (.+)/, 2, 3, step.path, 1),\n        });\n        var FS = CA65.FS;\n        setupFS(FS, '65-' + getRootBasePlatform(step.platform));\n        populateFiles(step, FS);\n        fixParamsWithDefines(step.path, step.params);\n        var args = ['-v', '-g', '-I', '/share/asminc', '-o', objpath, '-l', lstpath, step.path];\n        args.unshift.apply(args, [\"-D\", \"__8BITWORKSHOP__=1\"]);\n        if (step.mainfile) {\n            args.unshift.apply(args, [\"-D\", \"__MAIN__=1\"]);\n        }\n        execMain(step, CA65, args);\n        if (errors.length) {\n            let listings : CodeListingMap = {};\n            // TODO? change extension to .lst\n            //listings[step.path] = { lines:[], text:getWorkFileAsString(step.path) };\n            return { errors, listings };\n        }\n        objout = FS.readFile(objpath, { encoding: 'binary' });\n        lstout = FS.readFile(lstpath, { encoding: 'utf8' });\n        putWorkFile(objpath, objout);\n        putWorkFile(lstpath, lstout);\n    }\n    return {\n        linktool: \"ld65\",\n        files: [objpath, lstpath],\n        args: [objpath]\n    };\n}\n\nexport function linkLD65(step: BuildStep): BuildStepResult {\n    loadNative(\"ld65\");\n    var params = step.params;\n    gatherFiles(step);\n    var binpath = \"main\";\n    if (staleFiles(step, [binpath])) {\n        var errors = [];\n        var LD65: EmscriptenModule = emglobal.ld65({\n            instantiateWasm: moduleInstFn('ld65'),\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: print_fn,\n            printErr: function (s) { errors.push({ msg: s, line: 0 }); }\n        });\n        var FS = LD65.FS;\n        setupFS(FS, '65-' + getRootBasePlatform(step.platform));\n        populateFiles(step, FS);\n        populateExtraFiles(step, FS, params.extra_link_files);\n        // populate .cfg file, if it is a custom one\n        if (store.hasFile(params.cfgfile)) {\n            populateEntry(FS, params.cfgfile, store.getFileEntry(params.cfgfile), null);\n        }\n        var libargs = params.libargs || [];\n        var cfgfile = params.cfgfile;\n        var args = ['--cfg-path', '/share/cfg',\n            '--lib-path', '/share/lib',\n            '-C', cfgfile,\n            '-Ln', 'main.vice',\n            //'--dbgfile', 'main.dbg', // TODO: get proper line numbers\n            '-o', 'main',\n            '-m', 'main.map'].concat(step.args, libargs);\n        //console.log(args);\n        execMain(step, LD65, args);\n        if (errors.length)\n            return { errors: errors };\n        var aout = FS.readFile(\"main\", { encoding: 'binary' });\n        var mapout = FS.readFile(\"main.map\", { encoding: 'utf8' });\n        var viceout = FS.readFile(\"main.vice\", { encoding: 'utf8' });\n        //var dbgout = FS.readFile(\"main.dbg\", {encoding:'utf8'});\n        putWorkFile(\"main\", aout);\n        putWorkFile(\"main.map\", mapout);\n        putWorkFile(\"main.vice\", viceout);\n        // return unchanged if no files changed\n        if (!anyTargetChanged(step, [\"main\", \"main.map\", \"main.vice\"]))\n            return;\n        // parse symbol map (TODO: omit segments, constants)\n        var symbolmap = {};\n        for (var s of viceout.split(\"\\n\")) {\n            var toks = s.split(\" \");\n            if (toks[0] == 'al') {\n                let ident = toks[2].substr(1);\n                if (ident.length != 5 || !ident.startsWith('L')) { // no line numbers\n                    let ofs = parseInt(toks[1], 16);\n                    symbolmap[ident] = ofs;\n                }\n            }\n        }\n        // TODO: move to Platform class\n        var segments = [];\n        segments.push({ name: 'CPU Stack', start: 0x100, size: 0x100, type: 'ram' });\n        segments.push({ name: 'CPU Vectors', start: 0xfffa, size: 0x6, type: 'rom' });\n        // TODO: CHR, banks, etc\n        let re_seglist = /(\\w+)\\s+([0-9A-F]+)\\s+([0-9A-F]+)\\s+([0-9A-F]+)\\s+([0-9A-F]+)/;\n        let parseseglist = false;\n        let m;\n        for (let s of mapout.split('\\n')) {\n            if (parseseglist && (m = re_seglist.exec(s))) {\n                let seg = m[1];\n                let start = parseInt(m[2], 16);\n                let size = parseInt(m[4], 16);\n                let type = '';\n                // TODO: better id of ram/rom\n                if (seg.startsWith('CODE') || seg == 'STARTUP' || seg == 'RODATA' || seg.endsWith('ROM')) type = 'rom';\n                else if (seg == 'ZP' || seg == 'DATA' || seg == 'BSS' || seg.endsWith('RAM')) type = 'ram';\n                segments.push({ name: seg, start, size, type });\n            }\n            if (s == 'Segment list:') parseseglist = true;\n            if (s == '') parseseglist = false;\n        }\n        // build listings\n        var listings: CodeListingMap = {};\n        for (var fn of step.files) {\n            if (fn.endsWith('.lst')) {\n                var lstout = FS.readFile(fn, { encoding: 'utf8' });\n                lstout = lstout.split('\\n\\n')[1] || lstout; // remove header\n                putWorkFile(fn, lstout);\n                console.log(step);\n                let isECS = step.debuginfo?.entities != null; // TODO\n                if (isECS) {\n                    var asmlines = [];\n                    var srclines = parseCA65Listing(lstout, symbolmap, segments, params, true, listings);\n                    listings[fn] = {\n                        lines: [],\n                        text: lstout\n                    }\n                } else {\n                    var asmlines = parseCA65Listing(lstout, symbolmap, segments, params, false);\n                    var srclines = parseCA65Listing(lstout, symbolmap, segments, params, true); // TODO: listings param for ecs\n                    listings[fn] = {\n                        asmlines: srclines.length ? asmlines : null,\n                        lines: srclines.length ? srclines : asmlines,\n                        text: lstout\n                    }\n                }\n            }\n        }\n        return {\n            output: aout, //.slice(0),\n            listings: listings,\n            errors: errors,\n            symbolmap: symbolmap,\n            segments: segments\n        };\n    }\n}\n\nexport function compileCC65(step: BuildStep): BuildStepResult {\n    loadNative(\"cc65\");\n    var params = step.params;\n    // stderr\n    var re_err1 = /(.*?):(\\d+): (.+)/;\n    var errors: WorkerError[] = [];\n    var errline = 0;\n    function match_fn(s) {\n        console.log(s);\n        var matches = re_err1.exec(s);\n        if (matches) {\n            errline = parseInt(matches[2]);\n            errors.push({\n                line: errline,\n                msg: matches[3],\n                path: matches[1]\n            });\n        }\n    }\n    gatherFiles(step, { mainFilePath: \"main.c\" });\n    var destpath = step.prefix + '.s';\n    if (staleFiles(step, [destpath])) {\n        var CC65: EmscriptenModule = emglobal.cc65({\n            instantiateWasm: moduleInstFn('cc65'),\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: print_fn,\n            printErr: match_fn,\n        });\n        var FS = CC65.FS;\n        setupFS(FS, '65-' + getRootBasePlatform(step.platform));\n        populateFiles(step, FS);\n        fixParamsWithDefines(step.path, params);\n        var args = [\n            '-I', '/share/include',\n            '-I', '.',\n            \"-D\", \"__8BITWORKSHOP__\",\n        ];\n        if (params.define) {\n            params.define.forEach((x) => args.push('-D' + x));\n        }\n        if (step.mainfile) {\n            args.unshift.apply(args, [\"-D\", \"__MAIN__\"]);\n        }\n        var customArgs = params.extra_compiler_args || ['-T', '-g', '-Oirs', '-Cl', '-W', '-pointer-sign,-no-effect'];\n        args = args.concat(customArgs, args);\n        args.push(step.path);\n        //console.log(args);\n        execMain(step, CC65, args);\n        if (errors.length)\n            return { errors: errors };\n        var asmout = FS.readFile(destpath, { encoding: 'utf8' });\n        putWorkFile(destpath, asmout);\n    }\n    return {\n        nexttool: \"ca65\",\n        path: destpath,\n        args: [destpath],\n        files: [destpath],\n    };\n}\n\n", "import { CodeListingMap, WorkerError } from \"../../common/workertypes\";\nimport { re_crlf, BuildStep, BuildStepResult, load, msvcErrorMatcher, emglobal, populateFiles, execMain, putWorkFile, anyTargetChanged, re_msvc, gatherFiles, getWorkFileAsString, print_fn, setupFS, setupStdin, staleFiles } from \"../workermain\";\nimport { EmscriptenModule } from \"../workermain\"\n\nfunction parseDASMListing(lstpath: string, lsttext: string, listings: CodeListingMap, errors: WorkerError[], unresolved: {}) {\n    // TODO: this gets very slow\n    // TODO: macros that are on adjacent lines don't get offset addresses\n    //        4  08ee\t\t       a9 00\t   start      lda\t#01workermain.js:23:5\n    let lineMatch = /\\s*(\\d+)\\s+(\\S+)\\s+([0-9a-f]+)\\s+([?0-9a-f][?0-9a-f ]+)?\\s+(.+)?/i;\n    let equMatch = /\\bequ\\b/i;\n    let macroMatch = /\\bMAC\\s+(\\S+)?/i;\n    let lastline = 0;\n    let macros = {};\n    let lstline = 0;\n    let lstlist = listings[lstpath];\n    for (let line of lsttext.split(re_crlf)) {\n        lstline++;\n        let linem = lineMatch.exec(line + \"    \");\n        if (linem && linem[1] != null) {\n            let linenum = parseInt(linem[1]);\n            let filename = linem[2];\n            let offset = parseInt(linem[3], 16);\n            let insns = linem[4];\n            let restline = linem[5];\n            if (insns && insns.startsWith('?')) insns = null;\n            // don't use listing yet\n            if (lstlist && lstlist.lines) {\n                lstlist.lines.push({\n                    line: lstline,\n                    offset: offset,\n                    insns: insns,\n                    iscode: true,\n                });\n            }\n            // inside of a file?\n            let lst = listings[filename];\n            if (lst) {\n                var lines = lst.lines;\n                // look for MAC statement\n                let macmatch = macroMatch.exec(restline);\n                if (macmatch) {\n                    macros[macmatch[1]] = { line: parseInt(linem[1]), file: linem[2].toLowerCase() };\n                }\n                else if (insns && restline && !restline.match(equMatch)) {\n                    lines.push({\n                        line: linenum,\n                        offset: offset,\n                        insns: insns,\n                        iscode: restline[0] != '.'\n                    });\n                }\n                lastline = linenum;\n            } else {\n                // inside of macro?\n                let mac = macros[filename.toLowerCase()];\n                // macro invocation in main file\n                if (mac && linenum == 0) {\n                    lines.push({\n                        line: lastline + 1,\n                        offset: offset,\n                        insns: insns,\n                        iscode: true\n                    });\n                }\n                if (insns && mac) {\n                    let maclst = listings[mac.file];\n                    if (maclst && maclst.lines) {\n                        maclst.lines.push({\n                            path: mac.file,\n                            line: mac.line + linenum,\n                            offset: offset,\n                            insns: insns,\n                            iscode: true\n                        });\n                    }\n                    // TODO: a listing file can't include other files\n                } else {\n                    // inside of macro or include file\n                    if (insns && linem[3] && lastline > 0) {\n                        lines.push({\n                            line: lastline + 1,\n                            offset: offset,\n                            insns: null\n                        });\n                    }\n                }\n            }\n            // TODO: better symbol test (word boundaries)\n            // TODO: ignore IFCONST and IFNCONST usage\n            for (let key in unresolved) {\n                let l = restline || line;\n                // find the identifier substring\n                let pos = l.indexOf(key);\n                if (pos >= 0) {\n                    // strip the comment, if any\n                    let cmt = l.indexOf(';');\n                    if (cmt < 0 || cmt > pos) {\n                        // make sure identifier is flanked by non-word chars\n                        if (new RegExp(\"\\\\b\" + key + \"\\\\b\").exec(l)) {\n                            errors.push({\n                                path: filename,\n                                line: linenum,\n                                msg: \"Unresolved symbol '\" + key + \"'\"\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        let errm = re_msvc.exec(line);\n        if (errm) {\n            errors.push({\n                path: errm[1],\n                line: parseInt(errm[2]),\n                msg: errm[4]\n            })\n        }\n    }\n}\n\nexport function assembleDASM(step: BuildStep): BuildStepResult {\n    load(\"dasm\");\n    var re_usl = /(\\w+)\\s+0000\\s+[?][?][?][?]/;\n    var unresolved = {};\n    var errors = [];\n    var errorMatcher = msvcErrorMatcher(errors);\n    function match_fn(s: string) {\n        // TODO: what if s is not string? (startsWith is not a function)\n        var matches = re_usl.exec(s);\n        if (matches) {\n            var key = matches[1];\n            if (key != 'NO_ILLEGAL_OPCODES') { // TODO\n                unresolved[matches[1]] = 0;\n            }\n        } else if (s.startsWith(\"Warning:\")) {\n            errors.push({ line: 0, msg: s.substr(9) });\n        } else if (s.startsWith(\"unable \")) {\n            errors.push({ line: 0, msg: s });\n        } else if (s.startsWith(\"segment: \")) {\n            errors.push({ line: 0, msg: \"Segment overflow: \" + s.substring(9) });\n        } else if (s.toLowerCase().indexOf('error:') >= 0) {\n            errors.push({ line: 0, msg: s.trim() });\n        } else {\n            errorMatcher(s);\n        }\n    }\n    var Module: EmscriptenModule = emglobal.DASM({\n        noInitialRun: true,\n        print: match_fn\n    });\n    var FS = Module.FS;\n    populateFiles(step, FS, {\n        mainFilePath: 'main.a'\n    });\n    var binpath = step.prefix + '.bin';\n    var lstpath = step.prefix + '.lst';\n    var sympath = step.prefix + '.sym';\n    execMain(step, Module, [step.path, '-f3',\n    \"-l\" + lstpath,\n    \"-o\" + binpath,\n    \"-s\" + sympath]);\n    var alst = FS.readFile(lstpath, { 'encoding': 'utf8' });\n    // parse main listing, get errors and listings for each file\n    var listings: CodeListingMap = {};\n    //listings[lstpath] = {lines:[], text:alst};\n    for (let path of step.files) {\n        listings[path] = { lines: [] };\n    }\n    parseDASMListing(lstpath, alst, listings, errors, unresolved);\n    if (errors.length) {\n        return { errors: errors };\n    }\n    // read binary rom output and symbols\n    var aout, asym;\n    aout = FS.readFile(binpath);\n    try {\n        asym = FS.readFile(sympath, { 'encoding': 'utf8' });\n    } catch (e) {\n        console.log(e);\n        errors.push({ line: 0, msg: \"No symbol table generated, maybe segment overflow?\" });\n        return { errors: errors }\n    }\n    putWorkFile(binpath, aout);\n    putWorkFile(lstpath, alst);\n    putWorkFile(sympath, asym);\n    // return unchanged if no files changed\n    // TODO: what if listing or symbols change?\n    if (!anyTargetChanged(step, [binpath/*, lstpath, sympath*/]))\n        return;\n    var symbolmap = {};\n    for (var s of asym.split(\"\\n\")) {\n        var toks = s.split(/\\s+/);\n        if (toks && toks.length >= 2 && !toks[0].startsWith('-')) {\n            symbolmap[toks[0]] = parseInt(toks[1], 16);\n        }\n    }\n    // for bataribasic (TODO)\n    if (step['bblines']) {\n        let lst = listings[step.path];\n        if (lst) {\n            lst.asmlines = lst.lines;\n            lst.text = alst;\n            lst.lines = [];\n        }\n    }\n    return {\n        output: aout,\n        listings: listings,\n        errors: errors,\n        symbolmap: symbolmap,\n    };\n}\n\n\nfunction preprocessBatariBasic(code: string): string {\n    load(\"bbpreprocess\");\n    var bbout = \"\";\n    function addbbout_fn(s) {\n        bbout += s;\n        bbout += \"\\n\";\n    }\n    var BBPRE: EmscriptenModule = emglobal.preprocess({\n        noInitialRun: true,\n        //logReadFiles:true,\n        print: addbbout_fn,\n        printErr: print_fn,\n        noFSInit: true,\n    });\n    var FS = BBPRE.FS;\n    setupStdin(FS, code);\n    BBPRE.callMain([]);\n    console.log(\"preprocess \" + code.length + \" -> \" + bbout.length + \" bytes\");\n    return bbout;\n}\n\nexport function compileBatariBasic(step: BuildStep): BuildStepResult {\n    load(\"bb2600basic\");\n    var params = step.params;\n    // stdout\n    var asmout = \"\";\n    function addasmout_fn(s) {\n        asmout += s;\n        asmout += \"\\n\";\n    }\n    // stderr\n    var re_err1 = /[(](\\d+)[)]:?\\s*(.+)/;\n    var errors = [];\n    var errline = 0;\n    function match_fn(s) {\n        console.log(s);\n        var matches = re_err1.exec(s);\n        if (matches) {\n            errline = parseInt(matches[1]);\n            errors.push({\n                line: errline,\n                msg: matches[2]\n            });\n        }\n    }\n    gatherFiles(step, { mainFilePath: \"main.bas\" });\n    var destpath = step.prefix + '.asm';\n    if (staleFiles(step, [destpath])) {\n        var BB: EmscriptenModule = emglobal.bb2600basic({\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: addasmout_fn,\n            printErr: match_fn,\n            noFSInit: true,\n            TOTAL_MEMORY: 64 * 1024 * 1024,\n        });\n        var FS = BB.FS;\n        populateFiles(step, FS);\n        // preprocess, pipe file to stdin\n        var code = getWorkFileAsString(step.path);\n        code = preprocessBatariBasic(code);\n        setupStdin(FS, code);\n        setupFS(FS, '2600basic');\n        execMain(step, BB, [\"-i\", \"/share\", step.path]);\n        if (errors.length)\n            return { errors: errors };\n        // build final assembly output from include file list\n        var includesout = FS.readFile(\"includes.bB\", { encoding: 'utf8' });\n        var redefsout = FS.readFile(\"2600basic_variable_redefs.h\", { encoding: 'utf8' });\n        var includes = includesout.trim().split(\"\\n\");\n        var combinedasm = \"\";\n        var splitasm = asmout.split(\"bB.asm file is split here\");\n        for (var incfile of includes) {\n            var inctext;\n            if (incfile == \"bB.asm\")\n                inctext = splitasm[0];\n            else if (incfile == \"bB2.asm\")\n                inctext = splitasm[1];\n            else\n                inctext = FS.readFile(\"/share/includes/\" + incfile, { encoding: 'utf8' });\n            console.log(incfile, inctext.length);\n            combinedasm += \"\\n\\n;;;\" + incfile + \"\\n\\n\";\n            combinedasm += inctext;\n        }\n        // TODO: ; bB.asm file is split here\n        putWorkFile(destpath, combinedasm);\n        putWorkFile(\"2600basic.h\", FS.readFile(\"/share/includes/2600basic.h\"));\n        putWorkFile(\"2600basic_variable_redefs.h\", redefsout);\n    }\n    return {\n        nexttool: \"dasm\",\n        path: destpath,\n        args: [destpath],\n        files: [destpath, \"2600basic.h\", \"2600basic_variable_redefs.h\"],\n        bblines: true,\n    };\n}", "import { CodeListingMap } from \"../../common/workertypes\";\nimport { BuildStep, BuildStepResult, loadNative, gatherFiles, staleFiles, emglobal, moduleInstFn, populateFiles, execMain, putWorkFile, setupFS, populateExtraFiles, anyTargetChanged, parseListing, print_fn, msvcErrorMatcher, getWorkFileAsString, setupStdin, preprocessMCPP, parseSourceLines } from \"../workermain\";\nimport { EmscriptenModule } from \"../workermain\"\n\nfunction hexToArray(s, ofs) {\n    var buf = new ArrayBuffer(s.length / 2);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < arr.length; i++) {\n        arr[i] = parseInt(s.slice(i * 2 + ofs, i * 2 + ofs + 2), 16);\n    }\n    return arr;\n}\n\nfunction parseIHX(ihx, rom_start, rom_size, errors) {\n    var output = new Uint8Array(new ArrayBuffer(rom_size));\n    var high_size = 0;\n    for (var s of ihx.split(\"\\n\")) {\n        if (s[0] == ':') {\n            var arr = hexToArray(s, 1);\n            var count = arr[0];\n            var address = (arr[1] << 8) + arr[2] - rom_start;\n            var rectype = arr[3];\n            //console.log(rectype,address.toString(16),count,arr);\n            if (rectype == 0) {\n                for (var i = 0; i < count; i++) {\n                    var b = arr[4 + i];\n                    output[i + address] = b;\n                }\n                if (i + address > high_size) high_size = i + address;\n            } else if (rectype == 1) {\n                break;\n            } else {\n                console.log(s); // unknown record type\n            }\n        }\n    }\n    // TODO: return ROM anyway?\n    if (high_size > rom_size) {\n        //errors.push({line:0, msg:\"ROM size too large: 0x\" + high_size.toString(16) + \" > 0x\" + rom_size.toString(16)});\n    }\n    return output;\n}\n\nexport function assembleSDASZ80(step: BuildStep): BuildStepResult {\n    loadNative(\"sdasz80\");\n    var objout, lstout, symout;\n    var errors = [];\n    gatherFiles(step, { mainFilePath: \"main.asm\" });\n    var objpath = step.prefix + \".rel\";\n    var lstpath = step.prefix + \".lst\";\n    if (staleFiles(step, [objpath, lstpath])) {\n        //?ASxxxx-Error-<o> in line 1 of main.asm null\n        //              <o> .org in REL area or directive / mnemonic error\n        // ?ASxxxx-Error-<q> in line 1627 of cosmic.asm\n        //    <q> missing or improper operators, terminators, or delimiters\n        var match_asm_re1 = / in line (\\d+) of (\\S+)/; // TODO\n        var match_asm_re2 = / <\\w> (.+)/; // TODO\n        var errline = 0;\n        var errpath = step.path;\n        var match_asm_fn = (s: string) => {\n            var m = match_asm_re1.exec(s);\n            if (m) {\n                errline = parseInt(m[1]);\n                errpath = m[2];\n            } else {\n                m = match_asm_re2.exec(s);\n                if (m) {\n                    errors.push({\n                        line: errline,\n                        path: errpath,\n                        msg: m[1]\n                    });\n                }\n            }\n        }\n        var ASZ80: EmscriptenModule = emglobal.sdasz80({\n            instantiateWasm: moduleInstFn('sdasz80'),\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: match_asm_fn,\n            printErr: match_asm_fn,\n        });\n        var FS = ASZ80.FS;\n        populateFiles(step, FS);\n        execMain(step, ASZ80, ['-plosgffwy', step.path]);\n        if (errors.length) {\n            return { errors: errors };\n        }\n        objout = FS.readFile(objpath, { encoding: 'utf8' });\n        lstout = FS.readFile(lstpath, { encoding: 'utf8' });\n        putWorkFile(objpath, objout);\n        putWorkFile(lstpath, lstout);\n    }\n    return {\n        linktool: \"sdldz80\",\n        files: [objpath, lstpath],\n        args: [objpath]\n    };\n    //symout = FS.readFile(\"main.sym\", {encoding:'utf8'});\n}\n\nexport function linkSDLDZ80(step: BuildStep) {\n    loadNative(\"sdldz80\");\n    var errors = [];\n    gatherFiles(step);\n    var binpath = \"main.ihx\";\n    if (staleFiles(step, [binpath])) {\n        //?ASlink-Warning-Undefined Global '__divsint' referenced by module 'main'\n        var match_aslink_re = /\\?ASlink-(\\w+)-(.+)/;\n        var match_aslink_fn = (s: string) => {\n            var matches = match_aslink_re.exec(s);\n            if (matches) {\n                errors.push({\n                    line: 0,\n                    msg: matches[2]\n                });\n            }\n        }\n        var params = step.params;\n        var LDZ80: EmscriptenModule = emglobal.sdldz80({\n            instantiateWasm: moduleInstFn('sdldz80'),\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: match_aslink_fn,\n            printErr: match_aslink_fn,\n        });\n        var FS = LDZ80.FS;\n        setupFS(FS, 'sdcc');\n        populateFiles(step, FS);\n        populateExtraFiles(step, FS, params.extra_link_files);\n        // TODO: coleco hack so that -u flag works\n        if (step.platform.startsWith(\"coleco\")) {\n            FS.writeFile('crt0.rel', FS.readFile('/share/lib/coleco/crt0.rel', { encoding: 'utf8' }));\n            FS.writeFile('crt0.lst', '\\n'); // TODO: needed so -u flag works\n        }\n        var args = ['-mjwxyu',\n            '-i', 'main.ihx', // TODO: main?\n            '-b', '_CODE=0x' + params.code_start.toString(16),\n            '-b', '_DATA=0x' + params.data_start.toString(16),\n            '-k', '/share/lib/z80',\n            '-l', 'z80'];\n        if (params.extra_link_args)\n            args.push.apply(args, params.extra_link_args);\n        args.push.apply(args, step.args);\n        //console.log(args);\n        execMain(step, LDZ80, args);\n        var hexout = FS.readFile(\"main.ihx\", { encoding: 'utf8' });\n        var noiout = FS.readFile(\"main.noi\", { encoding: 'utf8' });\n        putWorkFile(\"main.ihx\", hexout);\n        putWorkFile(\"main.noi\", noiout);\n        // return unchanged if no files changed\n        if (!anyTargetChanged(step, [\"main.ihx\", \"main.noi\"]))\n            return;\n        // parse binary file\n        var binout = parseIHX(hexout, params.rom_start !== undefined ? params.rom_start : params.code_start, params.rom_size, errors);\n        if (errors.length) {\n            return { errors: errors };\n        }\n        // parse listings\n        var listings: CodeListingMap = {};\n        for (var fn of step.files) {\n            if (fn.endsWith('.lst')) {\n                var rstout = FS.readFile(fn.replace('.lst', '.rst'), { encoding: 'utf8' });\n                //   0000 21 02 00      [10]   52 \tld\thl, #2\n                var asmlines = parseListing(rstout, /^\\s*([0-9A-F]{4})\\s+([0-9A-F][0-9A-F r]*[0-9A-F])\\s+\\[([0-9 ]+)\\]?\\s+(\\d+) (.*)/i, 4, 1, 2, 3);\n                var srclines = parseSourceLines(rstout, /^\\s+\\d+ ;<stdin>:(\\d+):/i, /^\\s*([0-9A-F]{4})/i);\n                putWorkFile(fn, rstout);\n                // TODO: you have to get rid of all source lines to get asm listing\n                listings[fn] = {\n                    asmlines: srclines.length ? asmlines : null,\n                    lines: srclines.length ? srclines : asmlines,\n                    text: rstout\n                };\n            }\n        }\n        // parse symbol map\n        var symbolmap = {};\n        for (var s of noiout.split(\"\\n\")) {\n            var toks = s.split(\" \");\n            if (toks[0] == 'DEF' && !toks[1].startsWith(\"A$\")) {\n                symbolmap[toks[1]] = parseInt(toks[2], 16);\n            }\n        }\n        // build segment map\n        var seg_re = /^s__(\\w+)$/;\n        var segments = [];\n        // TODO: use stack params for stack segment\n        for (let ident in symbolmap) {\n            let m = seg_re.exec(ident);\n            if (m) {\n                let seg = m[1];\n                let segstart = symbolmap[ident]; // s__SEG\n                let segsize = symbolmap['l__' + seg]; // l__SEG\n                if (segstart >= 0 && segsize > 0) {\n                    var type = null;\n                    if (['INITIALIZER', 'GSINIT', 'GSFINAL'].includes(seg)) type = 'rom';\n                    else if (seg.startsWith('CODE')) type = 'rom';\n                    else if (['DATA', 'INITIALIZED'].includes(seg)) type = 'ram';\n                    if (type == 'rom' || segstart > 0) // ignore HEADER0, CABS0, etc (TODO?)\n                        segments.push({ name: seg, start: segstart, size: segsize, type: type });\n                }\n            }\n        }\n        return {\n            output: binout,\n            listings: listings,\n            errors: errors,\n            symbolmap: symbolmap,\n            segments: segments\n        };\n    }\n}\n\nexport function compileSDCC(step: BuildStep): BuildStepResult {\n\n    gatherFiles(step, {\n        mainFilePath: \"main.c\" // not used\n    });\n    var outpath = step.prefix + \".asm\";\n    if (staleFiles(step, [outpath])) {\n        var errors = [];\n        var params = step.params;\n        loadNative('sdcc');\n        var SDCC: EmscriptenModule = emglobal.sdcc({\n            instantiateWasm: moduleInstFn('sdcc'),\n            noInitialRun: true,\n            noFSInit: true,\n            print: print_fn,\n            printErr: msvcErrorMatcher(errors),\n            //TOTAL_MEMORY:256*1024*1024,\n        });\n        var FS = SDCC.FS;\n        populateFiles(step, FS);\n        // load source file and preprocess\n        var code = getWorkFileAsString(step.path);\n        var preproc = preprocessMCPP(step, 'sdcc');\n        if (preproc.errors) {\n            return { errors: preproc.errors };\n        }\n        else code = preproc.code;\n        // pipe file to stdin\n        setupStdin(FS, code);\n        setupFS(FS, 'sdcc');\n        var args = ['--vc', '--std-sdcc99', '-mz80', //'-Wall',\n            '--c1mode',\n            //'--debug',\n            //'-S', 'main.c',\n            //'--asm=sdasz80',\n            //'--reserve-regs-iy',\n            '--less-pedantic',\n            ///'--fomit-frame-pointer',\n            //'--opt-code-speed',\n            //'--max-allocs-per-node', '1000',\n            //'--cyclomatic',\n            //'--nooverlay',\n            //'--nogcse',\n            //'--nolabelopt',\n            //'--noinvariant',\n            //'--noinduction',\n            //'--nojtbound',\n            //'--noloopreverse',\n            '-o', outpath];\n        // if \"#pragma opt_code\" found do not disable optimziations\n        if (!/^\\s*#pragma\\s+opt_code/m.exec(code)) {\n            args.push.apply(args, [\n                '--oldralloc',\n                '--no-peep',\n                '--nolospre'\n            ]);\n        }\n        if (params.extra_compile_args) {\n            args.push.apply(args, params.extra_compile_args);\n        }\n        execMain(step, SDCC, args);\n        // TODO: preprocessor errors w/ correct file\n        if (errors.length /* && nwarnings < msvc_errors.length*/) {\n            return { errors: errors };\n        }\n        // massage the asm output\n        var asmout = FS.readFile(outpath, { encoding: 'utf8' });\n        asmout = \" .area _HOME\\n .area _CODE\\n .area _INITIALIZER\\n .area _DATA\\n .area _INITIALIZED\\n .area _BSEG\\n .area _BSS\\n .area _HEAP\\n\" + asmout;\n        putWorkFile(outpath, asmout);\n    }\n    return {\n        nexttool: \"sdasz80\",\n        path: outpath,\n        args: [outpath],\n        files: [outpath],\n    };\n}\n", "\ntype Endian = 'big' | 'little';\n\ntype Symbol = {\n  value: number\n}\n\ntype AssemblerVar = {\n  bits : number,\n  toks : string[],\n  endian? : Endian,\n  iprel? : boolean,\n  ipofs? : number,\n  ipmul? : number,\n}\n\ntype AssemblerRuleSlice = {\n  a : number; // argument index\n  b : number; // bit index\n  n : number; // # of bits\n}\n\ntype AssemblerRule = {\n  fmt : string,\n  bits : (string | number | AssemblerRuleSlice)[],\n  // added at runtime\n  re? : RegExp,\n  prefix? : string,\n  varlist? : string[]\n}\n\ntype AssemblerVarList = {[name:string] : AssemblerVar};\n\ntype AssemblerLine = {line:number, offset:number, nbits:number, insns?:string};\n\ntype AssemblerFixup = {\n  sym:string,\n  ofs:number,\n  size:number;\n  srcofs:number,\n  dstofs:number,\n  dstlen:number,\n  line:number,\n  iprel:boolean,\n  ipofs:number,\n  ipmul:number,\n  endian:Endian\n};\n\ntype AssemblerSpec = {\n  name : string,\n  width : number,\n  vars : AssemblerVarList,\n  rules : AssemblerRule[]\n}\n\ntype AssemblerInstruction = {opcode:number, nbits : number};\ntype AssemblerErrorResult = {error:string};\ntype AssemblerLineResult = AssemblerErrorResult | AssemblerInstruction;\n\ntype AssemblerError = {msg:string, line:number};\n\ntype AssemblerState = {\n  ip: number,\n  line: number,\n  origin: number,\n  codelen: number,\n  intermediate: any,\n  output: number[],\n  lines: AssemblerLine[],\n  errors: AssemblerError[],\n  fixups: AssemblerFixup[]\n}\n\nconst isError = (o: AssemblerLineResult): o is AssemblerErrorResult => (<AssemblerErrorResult>o).error !== undefined\n\nfunction hex(v:number, nd:number) {\n  try {\n    if (!nd) nd = 2;\n    if (nd == 8) {\n      return hex((v>>16)&0xffff,4) + hex(v&0xffff,4);\n    }\n    var s = v.toString(16).toUpperCase();\n    while (s.length < nd)\n      s = \"0\" + s;\n    return s;\n  } catch (e) {\n    return v+\"\";\n  }\n}\n\nfunction stringToData(s:string) : number[] {\n  var data = [];\n  for (var i=0; i<s.length; i++) {\n    data[i] = s.charCodeAt(i);\n  }\n  return data;\n}\n\n\nexport class Assembler {\n  spec : AssemblerSpec;\n  ip = 0;\n  origin = 0;\n  linenum = 0;\n  symbols : {[name:string] : Symbol} = {};\n  errors : AssemblerError[] = [];\n  outwords : number[] = [];\n  asmlines : AssemblerLine[] = [];\n  fixups : AssemblerFixup[] = [];\n  width = 8;\n  codelen = 0;\n  aborted = false;\n  \n  constructor(spec? : AssemblerSpec) {\n    this.spec = spec;\n    if (spec) {\n      this.preprocessRules();\n    }\n  }\n\n  rule2regex(rule : AssemblerRule, vars : AssemblerVarList) {\n    var s = rule.fmt;\n    if (!s || !(typeof s === 'string'))\n      throw Error('Each rule must have a \"fmt\" string field');\n    if (!rule.bits || !(rule.bits instanceof Array))\n      throw Error('Each rule must have a \"bits\" array field');\n    var varlist = [];\n    rule.prefix = s.split(/\\s+/)[0];\n    s = s.replace(/\\+/g, '\\\\+');\n    s = s.replace(/\\*/g, '\\\\*');\n    s = s.replace(/\\s+/g, '\\\\s+');\n    s = s.replace(/\\[/g, '\\\\[');\n    s = s.replace(/\\]/g, '\\\\]');\n    s = s.replace(/\\(/g, '\\\\(');\n    s = s.replace(/\\)/g, '\\\\)');\n    s = s.replace(/\\./g, '\\\\.');\n    // TODO: more escapes?\n    s = s.replace(/~\\w+/g, (varname:string) => {\n      varname = varname.substr(1);\n      var v = vars[varname];\n      varlist.push(varname);\n      if (!v)\n        throw Error('Could not find variable definition for \"~' + varname + '\"');\n      else if (v.toks)\n        return '(\\\\w+)';\n      else\n        return '([0-9]+|[$][0-9a-f]+|\\\\w+)';\n    });\n    try {\n      rule.re = new RegExp('^'+s+'$', 'i');\n    } catch (e) {\n      throw Error(\"Bad regex for rule \\\"\" + rule.fmt + \"\\\": /\" + s + \"/ -- \" + e);\n    }\n    rule.varlist = varlist;\n    // TODO: check rule constraints\n    return rule;\n  }\n\n  preprocessRules() {\n    if (this.spec.width) {\n      this.width = this.spec.width || 8;\n    }\n    for (var rule of this.spec.rules) {\n      this.rule2regex(rule, this.spec.vars);\n    }\n  }\n  warning(msg:string, line?:number) {\n    this.errors.push({msg:msg, line:line?line:this.linenum});\n  }\n  fatal(msg:string, line?:number) {\n    this.warning(msg, line);\n    this.aborted = true;\n  }\n  fatalIf(msg?:string, line?:number) {\n    if (msg) this.fatal(msg, line);\n  }\n  addBytes(result:AssemblerInstruction) {\n    this.asmlines.push({\n      line:this.linenum,\n      offset:this.ip,\n      nbits:result.nbits\n    });\n    var op = result.opcode;\n    var nb = result.nbits/this.width;\n    for (var i=0; i<nb; i++) {\n      if (this.width < 32)\n        this.outwords[this.ip++ - this.origin] = (op >> (nb-1-i)*this.width) & ((1<<this.width)-1);\n      else\n        this.outwords[this.ip++ - this.origin] = op;\n    }\n  }\n  addWords(data:number[]) {\n    this.asmlines.push({\n      line:this.linenum,\n      offset:this.ip,\n      nbits:this.width*data.length\n    });\n    for (var i=0; i<data.length; i++) {\n      if (this.width < 32)\n        this.outwords[this.ip++ - this.origin] = data[i] & ((1<<this.width)-1);\n      else\n        this.outwords[this.ip++ - this.origin] = data[i];\n    }\n  }\n\n  parseData(toks:string[]) : number[] {\n    var data = [];\n    for (var i=0; i<toks.length; i++) {\n      data[i] = this.parseConst(toks[i]);\n    }\n    return data;\n  }\n\n  alignIP(align) {\n    if (align < 1 || align > this.codelen)\n      this.fatal(\"Invalid alignment value\");\n    else\n      this.ip = Math.floor((this.ip+align-1)/align)*align;\n  }\n\n  parseConst(s:string, nbits?:number) : number {\n    // TODO: check bit length\n    if (s && s[0] == '$')\n      return parseInt(s.substr(1), 16);\n    else\n      return parseInt(s);\n  }\n\n  swapEndian(x: number, nbits: number) {\n    var y = 0;\n    while (nbits > 0) {\n      var n = Math.min(nbits, this.width);\n      var mask = (1 << n) - 1;\n      y <<= n;\n      y |= (x & mask);\n      x >>>= n;\n      nbits -= n;\n    }\n    return y;\n  }\n\n  buildInstruction(rule:AssemblerRule, m:string[]) : AssemblerLineResult {\n    var opcode = 0;\n    var oplen = 0;\n    // iterate over each component of the rule output (\"bits\")\n    for (let b of rule.bits) {\n      let n,x;\n      // is a string? then it's a bit constant\n      // TODO\n      if (typeof b === \"string\") {\n        n = b.length;\n        x = parseInt(b,2);\n      } else {\n        // is it a slice {a,b,n} or just a number?\n        var index = typeof b === \"number\" ? b : b.a;\n        // it's an indexed variable, look up its variable\n        var id = m[index+1];\n        var v = this.spec.vars[rule.varlist[index]];\n        if (!v) {\n          return {error:`Could not find matching identifier for '${m[0]}' index ${index}`};\n        }\n        n = v.bits;\n        var shift = 0;\n        if (typeof b !== \"number\") {\n          n = b.n;\n          shift = b.b;\n        }\n        // is it an enumerated type? look up the index of its keyword\n        if (v.toks) {\n          x = v.toks.indexOf(id);\n          if (x < 0)\n            return {error:\"Can't use '\" + id + \"' here, only one of: \" + v.toks.join(', ')};\n        } else {\n          // otherwise, parse it as a constant\n          x = this.parseConst(id, n);\n          // is it a label? add fixup\n          if (isNaN(x)) {\n            this.fixups.push({\n              sym:id, ofs:this.ip, size:v.bits, line:this.linenum,\n              dstlen:n, dstofs:oplen, srcofs:shift,\n              endian:v.endian,\n              iprel:!!v.iprel, ipofs:(v.ipofs+0), ipmul:v.ipmul||1\n            });\n            x = 0;\n          } else {\n            var mask = (1<<v.bits)-1;\n            if ((x&mask) != x)\n              return {error:\"Value \" + x + \" does not fit in \" + v.bits + \" bits\"};\n          }\n        }\n        // if little endian, we need to swap ordering\n        if (v.endian == 'little') x = this.swapEndian(x, v.bits);\n        // is it an array slice? slice the bits\n        if (typeof b !== \"number\") {\n          x = (x >>> shift) & ((1 << b.n)-1);\n        }\n      }\n      opcode = (opcode << n) | x;\n      oplen += n;\n    }\n    if (oplen == 0)\n      this.warning(\"Opcode had zero length\");\n    else if (oplen > 32)\n      this.warning(\"Opcodes > 32 bits not supported\");\n    else if ((oplen % this.width) != 0)\n      this.warning(\"Opcode was not word-aligned (\" + oplen + \" bits)\");\n    return {opcode:opcode, nbits:oplen};\n  }\n\n  loadArch(arch:string) : string {\n    if (this.loadJSON) {\n      var json = this.loadJSON(arch + \".json\");\n      if (json && json.vars && json.rules) {\n        this.spec = json;\n        this.preprocessRules();\n      } else {\n        return (\"Could not load arch file '\" + arch + \".json'\");\n      }\n    }\n  }\n\n  parseDirective(tokens) {\n    var cmd = tokens[0].toLowerCase();\n    if (cmd == '.define')\n      this.symbols[tokens[1].toLowerCase()] = {value:tokens[2]};\n    else if (cmd == '.org')\n      this.ip = this.origin = parseInt(tokens[1]);\n    else if (cmd == '.len')\n      this.codelen = parseInt(tokens[1]);\n    else if (cmd == '.width')\n      this.width = parseInt(tokens[1]);\n    else if (cmd == '.arch')\n      this.fatalIf(this.loadArch(tokens[1]));\n    else if (cmd == '.include')\n      this.fatalIf(this.loadInclude(tokens[1]));\n    else if (cmd == '.module')\n      this.fatalIf(this.loadModule(tokens[1]));\n    else if (cmd == '.data')\n      this.addWords(this.parseData(tokens.slice(1)));\n    else if (cmd == '.string')\n      this.addWords(stringToData(tokens.slice(1).join(' ')));\n    else if (cmd == '.align')\n      this.alignIP(this.parseConst(tokens[1]));\n    else\n      this.warning(\"Unrecognized directive: \" + tokens);\n  }\n\n  assemble(line:string) : AssemblerInstruction {\n    this.linenum++;\n    // remove comments\n    line = line.replace(/[;].*/g, '').trim();\n    // is it a directive?\n    if (line[0] == '.') {\n      var tokens = line.split(/\\s+/);\n      this.parseDirective(tokens);\n      return;\n    }\n    // make it lowercase\n    line = line.toLowerCase();\n    // find labels\n    line = line.replace(/(\\w+):/, (_label, label) => {\n      this.symbols[label] = {value:this.ip};\n      return ''; // replace label with blank\n    });\n    line = line.trim();\n    if (line == '')\n      return; // empty line\n    // look at each rule in order\n    if (!this.spec) { this.fatal(\"Need to load .arch first\"); return; }\n    var lastError;\n    for (var rule of this.spec.rules) {\n      var m = rule.re.exec(line);\n      if (m) {\n        var result = this.buildInstruction(rule, m);\n        if (!isError(result)) {\n          this.addBytes(result);\n          return result;\n        } else {\n          lastError = result.error;\n        }\n      }\n    }\n    this.warning(lastError ? lastError : (\"Could not decode instruction: \" + line));\n  }\n\n  applyFixup(fix: AssemblerFixup, sym: Symbol) {\n    var ofs = fix.ofs + Math.floor(fix.dstofs/this.width);\n    var mask = ((1<<fix.size)-1);\n    var value = this.parseConst(sym.value+\"\", fix.dstlen);\n    if (fix.iprel)\n      value = (value - fix.ofs) * fix.ipmul - fix.ipofs;\n    if (fix.srcofs == 0 && (value > mask || value < -mask))\n      this.warning(\"Symbol \" + fix.sym + \" (\" + value + \") does not fit in \" + fix.dstlen + \" bits\", fix.line);\n    //console.log(hex(value,8), fix.srcofs, fix.dstofs, fix.dstlen);\n    if (fix.srcofs > 0)\n      value >>>= fix.srcofs;\n    value &= (1 << fix.dstlen) - 1;\n    // TODO: make it work for all widths\n    if (this.width == 32) {\n      var shift = 32 - fix.dstofs - fix.dstlen;\n      value <<= shift;\n    }\n    // TODO: check range\n    if (fix.size <= this.width) {\n      this.outwords[ofs - this.origin] ^= value;\n    } else {\n      // swap if we want big endian (we'll apply in LSB first order)\n      if (fix.endian == 'big') value = this.swapEndian(value, fix.size);\n      // apply multi-byte fixup\n      while (value) {\n        if (value & this.outwords[ofs - this.origin]) {\n          this.warning(\"Instruction bits overlapped: \" + hex(this.outwords[ofs - this.origin],8), hex(value,8));\n        } else {\n          this.outwords[ofs - this.origin] ^= value & ((1<<this.width)-1);\n        }\n        value >>>= this.width;\n        ofs++;\n      }\n    }\n  }\n\n  finish() : AssemblerState {\n    // apply fixups\n    for (var i=0; i<this.fixups.length; i++) {\n      var fix = this.fixups[i];\n      var sym = this.symbols[fix.sym];\n      if (sym) {\n        this.applyFixup(fix, sym);\n      } else {\n        this.warning(\"Symbol '\" + fix.sym + \"' not found\");\n      }\n    }\n    // update asmlines\n    for (var i=0; i<this.asmlines.length; i++) {\n      var al = this.asmlines[i];\n      al.insns = '';\n      for (var j=0; j<al.nbits/this.width; j++) {\n        var word = this.outwords[al.offset + j - this.origin];\n        if (j>0) al.insns += ' ';\n        al.insns += hex(word,this.width/4);\n      }\n    }\n    while (this.outwords.length < this.codelen) {\n      this.outwords.push(0);\n    }\n    this.fixups = [];\n    return this.state();\n  }\n\n  assembleFile(text) : AssemblerState {\n    var lines = text.split(/\\n/g);\n    for (var i=0; i<lines.length && !this.aborted; i++) {\n      try {\n        this.assemble(lines[i]);\n      } catch (e) {\n        console.log(e);\n        this.fatal(\"Exception during assembly: \" + e);\n      }\n    }\n    return this.finish();\n  }\n\n  state() : AssemblerState {\n    return {ip:this.ip, line:this.linenum, origin:this.origin, codelen:this.codelen,\n      intermediate:{}, // TODO: listing, symbols?\n      output:this.outwords,\n      lines:this.asmlines,\n      errors:this.errors,\n      fixups:this.fixups};\n  }\n  \n  // methods to implement in subclass\n  \n  loadJSON : (path : string) => any;\n  loadInclude : (path : string) => string;\n  loadModule : (path : string) => string;\n}\n\n", "import { SourceLocation } from \"../workertypes\";\n\nexport interface HDLModuleRunner {\n    state: any; // live state or proxy object\n    eval() : void;\n    tick() : void;\n    tick2(iters: number) : void;\n    powercycle() : void;\n    isFinished() : boolean;\n    isStopped() : boolean;\n    getGlobals() : {};\n    saveState() : {};\n    loadState(state: {}) : void;\n    dispose() : void;\n    getFileData : (filename : string) => string|Uint8Array;\n}\n\nexport interface HDLModuleTrace extends HDLModuleRunner {\n    trace: any;\n    resetTrace() : void;\n    nextTrace() : void;\n}\n\n///\n\nexport interface HDLLogicType extends HDLSourceObject {\n    left: number;\n    right: number;\n    signed: boolean;\n}\n\nexport interface HDLUnpackArray extends HDLSourceObject {\n    subtype: HDLDataType;\n    low: HDLConstant;\n    high: HDLConstant;\n}\n\nexport interface HDLNativeType extends HDLSourceObject {\n    jstype: string;\n}\n\nexport type HDLDataType = HDLLogicType | HDLUnpackArray | HDLNativeType;\n\nexport function isLogicType(arg:any): arg is HDLLogicType {\n    return typeof arg.left === 'number' && typeof arg.right === 'number';\n}\n\nexport function isArrayType(arg:any): arg is HDLUnpackArray {\n    return arg.subtype != null && arg.low != null && arg.high != null\n      && typeof arg.low.cvalue === 'number' && typeof arg.high.cvalue === 'number';\n}\n\nexport class HDLFile {\n    id: string;\n    filename: string;\n    isModule: boolean;\n}\n\nexport interface HDLSourceLocation extends SourceLocation {\n    hdlfile: HDLFile;\n    end_line?: number;\n}\n\nexport interface HDLSourceObject {\n    $loc?: HDLSourceLocation;\n}\n\nexport interface HDLDataTypeObject extends HDLSourceObject {\n    dtype: HDLDataType;\n}\n\nexport function hasDataType(arg: any) : arg is HDLDataTypeObject {\n    return typeof arg.dtype === 'object';\n}\n\nexport interface HDLModuleDef extends HDLSourceObject {\n    name: string;\n    origName: string;\n    blocks: HDLBlock[];\n    instances: HDLInstanceDef[];\n    vardefs: { [id:string] : HDLVariableDef };\n}\n\nexport interface HDLVariableDef extends HDLDataTypeObject {\n    name: string;\n    origName: string;\n    isInput: boolean;\n    isOutput: boolean;\n    isParam: boolean;\n    constValue?: HDLConstant;\n    initValue?: HDLBlock;\n}\n\nexport function isVarDecl(arg:any): arg is HDLVariableDef {\n    return typeof arg.isParam !== 'undefined';\n}\n\nexport interface HDLConstant extends HDLDataTypeObject {\n    cvalue: number;\n    bigvalue: bigint;\n}\n\nexport function isConstExpr(arg:any): arg is HDLConstant {\n    return typeof arg.cvalue === 'number';\n}\n\nexport function isBigConstExpr(arg:any): arg is HDLConstant {\n    return typeof arg.bigvalue === 'bigint';\n}\n\nexport interface HDLHierarchyDef extends HDLSourceObject {\n    name: string;\n    module: HDLModuleDef;\n    parent: HDLHierarchyDef;\n    children: HDLHierarchyDef[];\n}\n\nexport interface HDLInstanceDef extends HDLSourceObject {\n    name: string;\n    origName: string;\n    module: HDLModuleDef;\n    ports: HDLPort[];\n}\n\nexport interface HDLVarRef extends HDLDataTypeObject {\n    refname: string;\n    //TODO? vardef: HDLVariableDef;\n}\n\nexport function isVarRef(arg:any): arg is HDLVarRef {\n    return arg.refname != null;\n}\n\nexport interface HDLUnop extends HDLDataTypeObject {\n    op: string;\n    left: HDLExpr;\n}\n\nexport interface HDLExtendop extends HDLUnop {\n    width: number;\n    widthminv: number;\n}\n\nexport function isUnop(arg:any): arg is HDLUnop {\n    return arg.op != null && arg.left != null && arg.right == null;\n}\n\nexport interface HDLBinop extends HDLUnop {\n    right: HDLExpr;\n}\n\nexport function isBinop(arg:any): arg is HDLBinop {\n    return arg.op != null && arg.left != null && arg.right != null && arg.cond == null;\n}\n\nexport interface HDLTriop extends HDLBinop {\n    cond: HDLExpr;\n}\n\nexport function isTriop(arg:any): arg is HDLTriop {\n    return arg.op != null && arg.cond != null;\n}\n\nexport interface HDLWhileOp extends HDLDataTypeObject {\n    op: 'while';\n    precond: HDLExpr;\n    loopcond: HDLExpr;\n    body: HDLExpr;\n    inc: HDLExpr;\n}\n\nexport function isWhileop(arg:any): arg is HDLWhileOp {\n    return arg.op === 'while' && arg.loopcond != null;\n}\n\nexport interface HDLBlock extends HDLSourceObject {\n    blocktype: string;\n    name: string;\n    exprs: HDLExpr[];\n}\n\nexport function isBlock(arg:any): arg is HDLBlock {\n    return arg.blocktype != null;\n}\n\nexport interface HDLAlwaysBlock extends HDLBlock {\n    senlist: HDLSensItem[];\n}\n\nexport interface HDLSensItem extends HDLSourceObject {\n    edgeType : \"POS\" | \"NEG\";\n    expr: HDLExpr;\n}\n\nexport interface HDLPort extends HDLSourceObject {\n    name: string;\n    expr: HDLExpr;\n}\n\nexport interface HDLFuncCall extends HDLDataTypeObject {\n    funcname: string;\n    args: HDLExpr[];\n}\n\nexport function isFuncCall(arg:any): arg is HDLFuncCall {\n    return typeof arg.funcname === 'string';\n}\n\nexport interface HDLArrayItem {\n    index: number;\n    expr: HDLExpr;\n}\n\nexport function isArrayItem(arg:any): arg is HDLArrayItem {\n    return typeof arg.index === 'number' && arg.expr != null;\n}\n\nexport type HDLExpr = HDLVarRef | HDLUnop | HDLBinop | HDLTriop | HDLBlock | HDLVariableDef | HDLFuncCall | HDLConstant;\n\nexport interface HDLUnit {\n    files: { [id: string]: HDLFile };\n    dtypes: { [id: string]: HDLDataType };\n    modules: { [id: string]: HDLModuleDef };\n    hierarchies: { [id: string]: HDLHierarchyDef };\n}\n\nexport type HDLValue = number | bigint | Uint8Array | Uint16Array | Uint32Array | HDLValue[];\n\n", "\nimport { parseXMLPoorly, XMLNode } from \"../util\";\nimport { HDLAlwaysBlock, HDLArrayItem, HDLBinop, HDLBlock, HDLConstant, HDLDataType, HDLDataTypeObject, HDLExpr, HDLExtendop, HDLFile, HDLFuncCall, HDLHierarchyDef, HDLInstanceDef, HDLLogicType, HDLModuleDef, HDLNativeType, HDLPort, HDLSensItem, HDLSourceLocation, HDLSourceObject, HDLTriop, HDLUnit, HDLUnop, HDLUnpackArray, HDLValue, HDLVariableDef, HDLVarRef, HDLWhileOp, isArrayType, isBinop, isBlock, isConstExpr, isFuncCall, isLogicType, isTriop, isUnop, isVarDecl, isVarRef } from \"./hdltypes\";\n\n/**\n * Whaa?\n * \n * Each hierarchy takes (uint32[] -> uint32[])\n * - convert to/from js object\n * - JS or WASM\n * - Fixed-size packets\n * - state is another uint32[]\n * Find optimal packing of bits\n * Find clocks\n * Find pivots (reset, state) concat them together\n * Dependency cycles\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\n */\n\n export class CompileError extends Error implements HDLSourceObject {\n    $loc: HDLSourceLocation;\n    constructor($loc: HDLSourceLocation, msg: string) {\n        super(msg);\n        this.$loc = $loc;\n        Object.setPrototypeOf(this, CompileError.prototype);\n    }\n}\n\nexport class VerilogXMLParser implements HDLUnit {\n\n    files: { [id: string]: HDLFile } = {};\n    dtypes: { [id: string]: HDLDataType } = {};\n    modules: { [id: string]: HDLModuleDef } = {};\n    hierarchies: { [id: string]: HDLHierarchyDef } = {};\n\n    cur_node : XMLNode;\n    cur_module : HDLModuleDef;\n    cur_loc : HDLSourceLocation;\n    cur_loc_str : string;\n    cur_deferred = [];\n\n    constructor() {\n        // TODO: other types?\n        this.dtypes['QData'] = {left:63, right:0, signed:false};\n        this.dtypes['IData'] = {left:31, right:0, signed:false};\n        this.dtypes['SData'] = {left:15, right:0, signed:false};\n        this.dtypes['CData'] = {left:7, right:0, signed:false};\n        this.dtypes['byte'] = {left:7, right:0, signed:true};\n        this.dtypes['shortint'] = {left:15, right:0, signed:true};\n        this.dtypes['int'] = {left:31, right:0, signed:true};\n        this.dtypes['integer'] = {left:31, right:0, signed:true};\n        this.dtypes['longint'] = {left:63, right:0, signed:true};\n        this.dtypes['time'] = {left:63, right:0, signed:false};\n    }\n\n    defer(fn: () => void) {\n        this.cur_deferred.unshift(fn);\n    }\n\n    defer2(fn: () => void) {\n        this.cur_deferred.push(fn);\n    }\n\n    run_deferred() {\n        this.cur_deferred.forEach((fn) => fn());\n        this.cur_deferred = [];\n    }\n\n    name2js(s: string) {\n        if (s == null) throw new CompileError(this.cur_loc, `no name`);\n        return s.replace(/[^a-z0-9_]/gi, '$');\n    }\n\n    findChildren(node: XMLNode, type: string, required: boolean) : XMLNode[] {\n        var arr = node.children.filter((n) => n.type == type);\n        if (arr.length == 0 && required) throw new CompileError(this.cur_loc, `no child of type ${type}`);\n        return arr;\n    }\n\n    parseSourceLocation(node: XMLNode): HDLSourceLocation {\n        var loc = node.attrs['loc'];\n        if (loc) {\n            if (loc == this.cur_loc_str) {\n                return this.cur_loc; // cache last parsed $loc object\n            } else {\n                var [fileid, line, col, end_line, end_col] = loc.split(',');\n                var $loc = {\n                    hdlfile: this.files[fileid],\n                    path: this.files[fileid].filename,\n                    line: parseInt(line),\n                    start: parseInt(col)-1,\n                    end_line: parseInt(end_line),\n                    end: parseInt(end_col)-1,\n                }\n                this.cur_loc = $loc;\n                this.cur_loc_str = loc;\n                return $loc;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    open_module(node: XMLNode) {\n        var module: HDLModuleDef = {\n            $loc: this.parseSourceLocation(node),\n            name: node.attrs['name'],\n            origName: node.attrs['origName'],\n            blocks: [],\n            instances: [],\n            vardefs: {},\n        }\n        if (this.cur_module) throw new CompileError(this.cur_loc, `nested modules not supported`);\n        this.cur_module = module;\n        return module;\n    }\n\n    deferDataType(node: XMLNode, def: HDLDataTypeObject) {\n        var dtype_id = node.attrs['dtype_id'];\n        if (dtype_id != null) {\n            this.defer(() => {\n                def.dtype = this.dtypes[dtype_id];\n                if (!def.dtype) {\n                    throw new CompileError(this.cur_loc, `Unknown data type ${dtype_id} for ${node.type}`);\n                }\n            })\n        }\n    }\n\n    parseConstValue(s: string) : number | bigint {\n        const re_const = /(\\d+)'([s]?)h([0-9a-f]+)/i;\n        var m = re_const.exec(s);\n        if (m) {\n            var numstr = m[3];\n            if (numstr.length <= 8)\n                return parseInt(numstr, 16);\n            else\n                return BigInt('0x' + numstr);\n        } else {\n            throw new CompileError(this.cur_loc, `could not parse constant \"${s}\"`);\n        }\n    }\n    \n    resolveVar(s: string, mod: HDLModuleDef) : HDLVariableDef {\n        var def = mod.vardefs[s];\n        if (def == null) throw new CompileError(this.cur_loc, `could not resolve variable \"${s}\"`);\n        return def;\n    }\n\n    resolveModule(s: string) : HDLModuleDef {\n        var mod = this.modules[s];\n        if (mod == null) throw new CompileError(this.cur_loc, `could not resolve module \"${s}\"`);\n        return mod;\n    }\n\n    //\n\n    visit_verilator_xml(node: XMLNode) {\n    }\n\n    visit_package(node: XMLNode) { // TODO?\n    }\n\n    visit_module(node: XMLNode) {\n        this.findChildren(node, 'var', false).forEach((n) => {\n            if (isVarDecl(n.obj)) {\n                this.cur_module.vardefs[n.obj.name] = n.obj;\n            }\n        })\n        this.modules[this.cur_module.name] = this.cur_module;\n        this.cur_module = null;\n    }\n\n    visit_var(node: XMLNode) : HDLVariableDef {\n        var name = node.attrs['name'];\n        name = this.name2js(name);\n        var vardef: HDLVariableDef = {\n            $loc: this.parseSourceLocation(node),\n            name: name,\n            origName: node.attrs['origName'],\n            isInput: node.attrs['dir'] == 'input',\n            isOutput: node.attrs['dir'] == 'output',\n            isParam: node.attrs['param'] == 'true',\n            dtype: null,\n        }\n        this.deferDataType(node, vardef);\n        var const_nodes = this.findChildren(node, 'const', false);\n        if (const_nodes.length) {\n            vardef.constValue = const_nodes[0].obj;\n        }\n        var init_nodes = this.findChildren(node, 'initarray', false);\n        if (init_nodes.length) {\n            vardef.initValue = init_nodes[0].obj;\n        }\n        return vardef;\n    }\n\n    visit_const(node: XMLNode) : HDLConstant {\n        var name = node.attrs['name'];\n        var cvalue = this.parseConstValue(name); \n        var constdef: HDLConstant = {\n            $loc: this.parseSourceLocation(node),\n            dtype: null,\n            cvalue: typeof cvalue === 'number' ? cvalue : null,\n            bigvalue: typeof cvalue === 'bigint' ? cvalue : null,\n        }\n        this.deferDataType(node, constdef);\n        return constdef;\n    }\n\n    visit_varref(node: XMLNode) : HDLVarRef {\n        var name = node.attrs['name'];\n        name = this.name2js(name);\n        var varref: HDLVarRef = {\n            $loc: this.parseSourceLocation(node),\n            dtype: null,\n            refname: name\n        }\n        this.deferDataType(node, varref);\n        var mod = this.cur_module;\n        /*\n        this.defer2(() => {\n            varref.vardef = this.resolveVar(name, mod);\n        });\n        */\n        return varref;\n    }\n\n    visit_sentree(node: XMLNode) {\n        // TODO\n    }\n\n    visit_always(node: XMLNode) : HDLAlwaysBlock {\n        // TODO\n        var sentree : HDLSensItem[];\n        var expr : HDLExpr;\n        if (node.children.length == 2) {\n            sentree = node.children[0].obj as HDLSensItem[];\n            expr = node.children[1].obj as HDLExpr;\n            // TODO: check sentree\n        } else {\n            sentree = null;\n            expr = node.children[0].obj as HDLExpr;\n        }\n        var always: HDLAlwaysBlock = {\n            $loc: this.parseSourceLocation(node),\n            blocktype: node.type,\n            name: null,\n            senlist: sentree,\n            exprs: [expr],\n        };\n        this.cur_module.blocks.push(always);\n        return always;\n    }\n\n    visit_begin(node: XMLNode) : HDLBlock {\n        var exprs = [];\n        node.children.forEach((n) => exprs.push(n.obj));\n        return {\n            $loc: this.parseSourceLocation(node),\n            blocktype: node.type,\n            name: node.attrs['name'],\n            exprs: exprs,\n        }\n    }\n\n    visit_initarray(node: XMLNode) : HDLBlock {\n        return this.visit_begin(node);\n    }\n\n    visit_inititem(node: XMLNode) : HDLArrayItem {\n        this.expectChildren(node, 1, 1);\n        return {\n            index: parseInt(node.attrs['index']),\n            expr: node.children[0].obj\n        }\n    }\n\n    visit_cfunc(node: XMLNode) : HDLBlock {\n        if (this.cur_module == null) { // TODO?\n            //console.log('no module open, skipping', node);\n            return;\n        }\n        var block = this.visit_begin(node);\n        block.exprs = [];\n        node.children.forEach((n) => block.exprs.push(n.obj));\n        this.cur_module.blocks.push(block);\n        return block;\n    }\n\n    visit_cuse(node: XMLNode) { // TODO?\n    }\n\n    visit_instance(node: XMLNode) : HDLInstanceDef {\n        var instance : HDLInstanceDef = {\n            $loc: this.parseSourceLocation(node),\n            name: node.attrs['name'],\n            origName: node.attrs['origName'],\n            ports: [],\n            module: null,\n        }\n        node.children.forEach((child) => {\n            instance.ports.push(child.obj);\n        })\n        this.cur_module.instances.push(instance);\n        this.defer(() => {\n            instance.module = this.resolveModule(node.attrs['defName']);\n        })\n        return instance;\n    }\n\n    visit_iface(node: XMLNode) {\n        throw new CompileError(this.cur_loc, `interfaces not supported`);\n    }\n\n    visit_intfref(node: XMLNode) {\n        throw new CompileError(this.cur_loc, `interfaces not supported`);\n    }\n\n    visit_port(node: XMLNode) : HDLPort {\n        this.expectChildren(node, 1, 1);\n        var varref: HDLPort = {\n            $loc: this.parseSourceLocation(node),\n            name: node.attrs['name'],\n            expr: node.children[0].obj\n        }\n        return varref;\n    }\n\n    visit_netlist(node: XMLNode) {\n    }\n\n    visit_files(node: XMLNode) {\n    }\n\n    visit_module_files(node: XMLNode) {\n        node.children.forEach((n) => {\n            if (n.obj) {\n                var file = this.files[(n.obj as HDLFile).id];\n                if (file) file.isModule = true;\n            }\n        });\n    }\n\n    visit_file(node: XMLNode) {\n        return this.visit_file_or_module(node, false);\n    }\n\n    // TODO\n    visit_scope(node: XMLNode) {\n    }\n\n    visit_topscope(node: XMLNode) {\n    }\n\n    visit_file_or_module(node: XMLNode, isModule: boolean) : HDLFile {\n        var file : HDLFile = {\n            id: node.attrs['id'],\n            filename: node.attrs['filename'],\n            isModule: isModule,\n        }\n        this.files[file.id] = file;\n        return file;\n    }\n\n    visit_cells(node: XMLNode) {\n        this.expectChildren(node, 1, 9999);\n        var hier = node.children[0].obj as HDLHierarchyDef;\n        if (hier != null) {\n            var hiername = hier.name;\n            this.hierarchies[hiername] = hier;\n        }\n    }\n\n    visit_cell(node: XMLNode) : HDLHierarchyDef {\n        var hier = {\n            $loc: this.parseSourceLocation(node),\n            name: node.attrs['name'],\n            module: null,\n            parent: null,\n            children: node.children.map((n) => n.obj),\n        }\n        if (node.children.length > 0)\n            throw new CompileError(this.cur_loc, `multiple non-flattened modules not yet supported`);\n        node.children.forEach((n) => (n.obj as HDLHierarchyDef).parent = hier);\n        this.defer(() => {\n            hier.module = this.resolveModule(node.attrs['submodname']);\n        })\n        return hier;\n    }\n\n    visit_basicdtype(node: XMLNode): HDLDataType {\n        let id = node.attrs['id'];\n        var dtype: HDLDataType;\n        var dtypename = node.attrs['name'];\n        switch (dtypename) {\n            case 'logic':\n            case 'integer': // TODO?\n            case 'bit':\n                let dlogic: HDLLogicType = {\n                    $loc: this.parseSourceLocation(node),\n                    left: parseInt(node.attrs['left'] || \"0\"),\n                    right: parseInt(node.attrs['right'] || \"0\"),\n                    signed: node.attrs['signed'] == 'true'\n                }\n                dtype = dlogic;\n                break;\n            case 'string':\n                let dstring: HDLNativeType = {\n                    $loc: this.parseSourceLocation(node),\n                    jstype: 'string'\n                }\n                dtype = dstring;\n                break;\n            default:\n                dtype = this.dtypes[dtypename];\n                if (dtype == null) {\n                    throw new CompileError(this.cur_loc, `unknown data type ${dtypename}`);\n                }\n        }\n        this.dtypes[id] = dtype;\n        return dtype;\n    }\n\n    visit_refdtype(node: XMLNode) {\n    }\n\n    visit_enumdtype(node: XMLNode) {\n    }\n\n    visit_enumitem(node: XMLNode) {\n    }\n\n    visit_packarraydtype(node: XMLNode): HDLDataType {\n        // TODO: packed?\n        return this.visit_unpackarraydtype(node);\n    }\n\n    visit_memberdtype(node: XMLNode) {\n        throw new CompileError(null, `structs not supported`);\n    }\n\n    visit_constdtype(node: XMLNode) {\n        // TODO? throw new CompileError(null, `constant data types not supported`);\n    }\n\n    visit_paramtypedtype(node: XMLNode) {\n        // TODO? throw new CompileError(null, `constant data types not supported`);\n    }\n\n    visit_unpackarraydtype(node: XMLNode): HDLDataType {\n        let id = node.attrs['id'];\n        let sub_dtype_id = node.attrs['sub_dtype_id'];\n        let range = node.children[0].obj as HDLBinop;\n        if (isConstExpr(range.left) && isConstExpr(range.right)) {\n            var dtype: HDLUnpackArray = {\n                $loc: this.parseSourceLocation(node),\n                subtype: null,\n                low: range.left,\n                high: range.right,\n            }\n            this.dtypes[id] = dtype;\n            this.defer(() => {\n                dtype.subtype = this.dtypes[sub_dtype_id];\n                if (!dtype.subtype) throw new CompileError(this.cur_loc, `Unknown data type ${sub_dtype_id} for array`);\n            })\n            return dtype;\n        } else {\n            throw new CompileError(this.cur_loc, `could not parse constant exprs in array`)\n        }\n    }\n\n    visit_senitem(node: XMLNode) : HDLSensItem {\n        var edgeType = node.attrs['edgeType'];\n        if (edgeType != \"POS\" && edgeType != \"NEG\")\n            throw new CompileError(this.cur_loc, \"POS/NEG required\")\n        return {\n            $loc: this.parseSourceLocation(node),\n            edgeType: edgeType,\n            expr: node.obj\n        }\n    }\n\n    visit_text(node: XMLNode) {\n    }\n\n    visit_cstmt(node: XMLNode) {\n    }\n\n    visit_cfile(node: XMLNode) {\n    }\n\n    visit_typetable(node: XMLNode) {\n    }\n\n    visit_constpool(node: XMLNode) {\n    }\n\n    visit_comment(node: XMLNode) {\n    }\n\n    expectChildren(node: XMLNode, low: number, high: number) {\n        if (node.children.length < low || node.children.length > high)\n            throw new CompileError(this.cur_loc, `expected between ${low} and ${high} children`);\n    }\n\n    __visit_unop(node: XMLNode) : HDLUnop {\n        this.expectChildren(node, 1, 1);\n        var expr: HDLUnop = {\n            $loc: this.parseSourceLocation(node),\n            op: node.type,\n            dtype: null,\n            left: node.children[0].obj as HDLExpr,\n        }\n        this.deferDataType(node, expr);\n        return expr;\n    }\n\n    visit_extend(node: XMLNode) : HDLUnop {\n        var unop = this.__visit_unop(node) as HDLExtendop;\n        unop.width = parseInt(node.attrs['width']);\n        unop.widthminv = parseInt(node.attrs['widthminv']);\n        if (unop.width != 32) throw new CompileError(this.cur_loc, `extends width ${unop.width} != 32`)\n        return unop;\n    }\n\n    visit_extends(node: XMLNode) : HDLUnop {\n        return this.visit_extend(node);\n    }\n\n    __visit_binop(node: XMLNode) : HDLBinop {\n        this.expectChildren(node, 2, 2);\n        var expr: HDLBinop = {\n            $loc: this.parseSourceLocation(node),\n            op: node.type,\n            dtype: null,\n            left: node.children[0].obj as HDLExpr,\n            right: node.children[1].obj as HDLExpr,\n        }\n        this.deferDataType(node, expr);\n        return expr;\n    }\n\n    visit_if(node: XMLNode) : HDLTriop {\n        this.expectChildren(node, 2, 3);\n        var expr: HDLTriop = {\n            $loc: this.parseSourceLocation(node),\n            op: 'if',\n            dtype: null,\n            cond: node.children[0].obj as HDLExpr,\n            left: node.children[1].obj as HDLExpr,\n            right: node.children[2] && node.children[2].obj as HDLExpr,\n        }\n        return expr;\n    }\n\n    // while and for loops\n    visit_while(node: XMLNode) : HDLWhileOp {\n        this.expectChildren(node, 2, 4);\n        var expr: HDLWhileOp = {\n            $loc: this.parseSourceLocation(node),\n            op: 'while',\n            dtype: null,\n            precond: node.children[0].obj as HDLExpr,\n            loopcond: node.children[1].obj as HDLExpr,\n            body: node.children[2] && node.children[2].obj as HDLExpr,\n            inc: node.children[3] && node.children[3].obj as HDLExpr,\n        }\n        return expr;\n    }\n\n    __visit_triop(node: XMLNode) : HDLBinop {\n        this.expectChildren(node, 3, 3);\n        var expr: HDLTriop = {\n            $loc: this.parseSourceLocation(node),\n            op: node.type,\n            dtype: null,\n            cond: node.children[0].obj as HDLExpr,\n            left: node.children[1].obj as HDLExpr,\n            right: node.children[2].obj as HDLExpr,\n        }\n        this.deferDataType(node, expr);\n        return expr;\n    }\n\n    __visit_func(node: XMLNode) : HDLFuncCall {\n        var expr = {\n            $loc: this.parseSourceLocation(node),\n            dtype: null,\n            funcname: node.attrs['func'] || ('$' + node.type),\n            args: node.children.map(n => n.obj as HDLExpr)\n        }\n        this.deferDataType(node, expr);\n        return expr;\n    }\n\n    visit_not(node: XMLNode) { return this.__visit_unop(node); }\n    visit_negate(node: XMLNode) { return this.__visit_unop(node); }\n    visit_redand(node: XMLNode) { return this.__visit_unop(node); }\n    visit_redor(node: XMLNode) { return this.__visit_unop(node); }\n    visit_redxor(node: XMLNode) { return this.__visit_unop(node); }\n    visit_initial(node: XMLNode) { return this.__visit_unop(node); }\n    visit_ccast(node: XMLNode) { return this.__visit_unop(node); }\n    visit_creset(node: XMLNode) { return this.__visit_unop(node); }\n    visit_creturn(node: XMLNode) { return this.__visit_unop(node); }\n\n    visit_contassign(node: XMLNode) { return this.__visit_binop(node); }\n    visit_assigndly(node: XMLNode) { return this.__visit_binop(node); }\n    visit_assignpre(node: XMLNode) { return this.__visit_binop(node); }\n    visit_assignpost(node: XMLNode) { return this.__visit_binop(node); }\n    visit_assign(node: XMLNode) { return this.__visit_binop(node); }\n    visit_arraysel(node: XMLNode) { return this.__visit_binop(node); }\n    visit_wordsel(node: XMLNode) { return this.__visit_binop(node); }\n\n    visit_eq(node: XMLNode) { return this.__visit_binop(node); }\n    visit_neq(node: XMLNode) { return this.__visit_binop(node); }\n    visit_lte(node: XMLNode) { return this.__visit_binop(node); }\n    visit_gte(node: XMLNode) { return this.__visit_binop(node); }\n    visit_lt(node: XMLNode) { return this.__visit_binop(node); }\n    visit_gt(node: XMLNode) { return this.__visit_binop(node); }\n    visit_and(node: XMLNode) { return this.__visit_binop(node); }\n    visit_or(node: XMLNode) { return this.__visit_binop(node); }\n    visit_xor(node: XMLNode) { return this.__visit_binop(node); }\n    visit_add(node: XMLNode) { return this.__visit_binop(node); }\n    visit_sub(node: XMLNode) { return this.__visit_binop(node); }\n    visit_concat(node: XMLNode) { return this.__visit_binop(node); } // TODO?\n    visit_shiftl(node: XMLNode) { return this.__visit_binop(node); }\n    visit_shiftr(node: XMLNode) { return this.__visit_binop(node); }\n    visit_shiftrs(node: XMLNode) { return this.__visit_binop(node); }\n\n    visit_mul(node: XMLNode) { return this.__visit_binop(node); }\n    visit_div(node: XMLNode) { return this.__visit_binop(node); }\n    visit_moddiv(node: XMLNode) { return this.__visit_binop(node); }\n    visit_muls(node: XMLNode) { return this.__visit_binop(node); }\n    visit_divs(node: XMLNode) { return this.__visit_binop(node); }\n    visit_moddivs(node: XMLNode) { return this.__visit_binop(node); }\n    visit_gts(node: XMLNode) { return this.__visit_binop(node); }\n    visit_lts(node: XMLNode) { return this.__visit_binop(node); }\n    visit_gtes(node: XMLNode) { return this.__visit_binop(node); }\n    visit_ltes(node: XMLNode) { return this.__visit_binop(node); }\n    // TODO: more?\n\n    visit_range(node: XMLNode) { return this.__visit_binop(node); }\n\n    visit_cond(node: XMLNode) { return this.__visit_triop(node); }\n    visit_condbound(node: XMLNode) { return this.__visit_triop(node); }\n    visit_sel(node: XMLNode) { return this.__visit_triop(node); }\n\n    visit_changedet(node: XMLNode) : HDLBinop {\n        if (node.children.length == 0)\n            return null; //{ op: \"changedet\", dtype:null, left:null, right:null }\n        else\n            return this.__visit_binop(node);\n    }\n\n    visit_ccall(node: XMLNode) { return this.__visit_func(node); }\n    visit_finish(node: XMLNode) { return this.__visit_func(node); }\n    visit_stop(node: XMLNode) { return this.__visit_func(node); }\n    visit_rand(node: XMLNode) { return this.__visit_func(node); }\n    visit_time(node: XMLNode) { return this.__visit_func(node); }\n\n    visit_display(node: XMLNode) { return null; }\n    visit_sformatf(node: XMLNode) { return null; }\n    visit_scopename(node: XMLNode) { return null; }\n\n    visit_readmem(node: XMLNode) { return this.__visit_func(node); }\n\n    //\n\n    xml_open(node: XMLNode) {\n        this.cur_node = node;\n        var method = this[`open_${node.type}`];\n        if (method) {\n            return method.bind(this)(node);\n        }\n    }\n    \n    xml_close(node: XMLNode) {\n        this.cur_node = node;\n        var method = this[`visit_${node.type}`];\n        if (method) {\n            return method.bind(this)(node);\n        } else {\n            throw new CompileError(this.cur_loc, `no visitor for ${node.type}`)\n        }\n    }\n\n    parse(xmls: string) {\n        parseXMLPoorly(xmls, this.xml_open.bind(this), this.xml_close.bind(this));\n        this.cur_node = null;\n        this.run_deferred();\n    }\n}\n\n", "\n// TODO: must be a better way to do all this\n\nimport { WorkerError, CodeListingMap, SourceLocation } from \"../../common/workertypes\";\nimport { Assembler } from \"../assembler\";\nimport * as vxmlparser from '../../common/hdl/vxmlparser';\nimport { getWorkFileAsString, BuildStep, BuildStepResult, gatherFiles, loadNative, staleFiles, makeErrorMatcher, emglobal, moduleInstFn, print_fn, populateFiles, execMain, putWorkFile, anyTargetChanged, endtime, getWASMMemory, starttime, populateExtraFiles, setupFS } from \"../workermain\";\nimport { EmscriptenModule } from \"../workermain\"\n\nfunction detectModuleName(code: string) {\n    var m = /^\\s*module\\s+(\\w+_top)\\b/m.exec(code)\n        || /^\\s*module\\s+(top|t)\\b/m.exec(code)\n        || /^\\s*module\\s+(\\w+)\\b/m.exec(code);\n    return m ? m[1] : null;\n}\n\nfunction detectTopModuleName(code: string) {\n    var topmod = detectModuleName(code) || \"top\";\n    var m = /^\\s*module\\s+(\\w+?_top)/m.exec(code);\n    if (m && m[1]) topmod = m[1];\n    return topmod;\n}\n\n// cached stuff (TODO)\nvar jsasm_module_top;\nvar jsasm_module_output;\nvar jsasm_module_key;\n\nfunction compileJSASM(asmcode: string, platform, options, is_inline) {\n    var asm = new Assembler(null);\n    var includes = [];\n    asm.loadJSON = (filename: string) => {\n        var jsontext = getWorkFileAsString(filename);\n        if (!jsontext) throw Error(\"could not load \" + filename);\n        return JSON.parse(jsontext);\n    };\n    asm.loadInclude = (filename) => {\n        if (!filename.startsWith('\"') || !filename.endsWith('\"'))\n            return 'Expected filename in \"double quotes\"';\n        filename = filename.substr(1, filename.length - 2);\n        includes.push(filename);\n    };\n    var loaded_module = false;\n    asm.loadModule = (top_module: string) => {\n        // compile last file in list\n        loaded_module = true;\n        var key = top_module + '/' + includes;\n        if (jsasm_module_key != key) {\n            jsasm_module_key = key;\n            jsasm_module_output = null;\n        }\n        jsasm_module_top = top_module;\n        var main_filename = includes[includes.length - 1];\n        // TODO: take out .asm dependency\n        var voutput = compileVerilator({ platform: platform, files: includes, path: main_filename, tool: 'verilator' });\n        if (voutput)\n            jsasm_module_output = voutput;\n        return null; // no error\n    }\n    var result = asm.assembleFile(asmcode);\n    if (loaded_module && jsasm_module_output) {\n        // errors? return them\n        if (jsasm_module_output.errors && jsasm_module_output.errors.length)\n            return jsasm_module_output;\n        // return program ROM array\n        var asmout = result.output;\n        // TODO: unify\n        result.output = jsasm_module_output.output;\n        // TODO: typecheck this garbage\n        (result as any).output.program_rom = asmout;\n        // TODO: not cpu_platform__DOT__program_rom anymore, make const\n        (result as any).output.program_rom_variable = jsasm_module_top + \"$program_rom\";\n        (result as any).listings = {};\n        (result as any).listings[options.path] = { lines: result.lines };\n        return result;\n    } else {\n        return result;\n    }\n}\n\nexport function compileJSASMStep(step: BuildStep): BuildStepResult {\n    gatherFiles(step);\n    var code = getWorkFileAsString(step.path);\n    var platform = step.platform || 'verilog';\n    return compileJSASM(code, platform, step, false);\n}\n\nfunction compileInlineASM(code: string, platform, options, errors, asmlines) {\n    code = code.replace(/__asm\\b([\\s\\S]+?)\\b__endasm\\b/g, function (s, asmcode, index) {\n        var firstline = code.substr(0, index).match(/\\n/g).length;\n        var asmout = compileJSASM(asmcode, platform, options, true);\n        if (asmout.errors && asmout.errors.length) {\n            for (var i = 0; i < asmout.errors.length; i++) {\n                asmout.errors[i].line += firstline;\n                errors.push(asmout.errors[i]);\n            }\n            return \"\";\n        } else if (asmout.output) {\n            let s = \"\";\n            var out = asmout.output;\n            for (var i = 0; i < out.length; i++) {\n                if (i > 0) {\n                    s += \",\";\n                    if ((i & 0xff) == 0) s += \"\\n\";\n                }\n                s += 0 | out[i];\n            }\n            if (asmlines) {\n                var al = asmout.lines;\n                for (var i = 0; i < al.length; i++) {\n                    al[i].line += firstline;\n                    asmlines.push(al[i]);\n                }\n            }\n            return s;\n        }\n    });\n    return code;\n}\n\nexport function compileVerilator(step: BuildStep): BuildStepResult {\n    loadNative(\"verilator_bin\");\n    var platform = step.platform || 'verilog';\n    var errors: WorkerError[] = [];\n    gatherFiles(step);\n    // compile verilog if files are stale\n    if (staleFiles(step, [xmlPath])) {\n        // TODO: %Error: Specified --top-module 'ALU' isn't at the top level, it's under another cell 'cpu'\n        // TODO: ... Use \"/* verilator lint_off BLKSEQ */\" and lint_on around source to disable this message.\n        var match_fn = makeErrorMatcher(errors, /%(.+?): (.+?):(\\d+)?[:]?\\s*(.+)/i, 3, 4, step.path, 2);\n        var verilator_mod: EmscriptenModule = emglobal.verilator_bin({\n            instantiateWasm: moduleInstFn('verilator_bin'),\n            noInitialRun: true,\n            noExitRuntime: true,\n            print: print_fn,\n            printErr: match_fn,\n            wasmMemory: getWASMMemory(), // reuse memory\n            //INITIAL_MEMORY:256*1024*1024,\n        });\n        var code = getWorkFileAsString(step.path);\n        var topmod = detectTopModuleName(code);\n        var FS = verilator_mod.FS;\n        var listings: CodeListingMap = {};\n        // process inline assembly, add listings where found\n        populateFiles(step, FS, {\n            mainFilePath: step.path,\n            processFn: (path, code) => {\n                if (typeof code === 'string') {\n                    let asmlines = [];\n                    code = compileInlineASM(code, platform, step, errors, asmlines);\n                    if (asmlines.length) {\n                        listings[path] = { lines: asmlines };\n                    }\n                }\n                return code;\n            }\n        });\n        starttime();\n        var xmlPath = `obj_dir/V${topmod}.xml`;\n        try {\n            var args = [\"--cc\", \"-O3\",\n                \"-DEXT_INLINE_ASM\", \"-DTOPMOD__\" + topmod, \"-D__8BITWORKSHOP__\",\n                \"-Wall\",\n                \"-Wno-DECLFILENAME\", \"-Wno-UNUSED\", \"-Wno-EOFNEWLINE\", \"-Wno-PROCASSWIRE\",\n                \"--x-assign\", \"fast\", \"--noassert\", \"--pins-sc-biguint\",\n                \"--debug-check\", // for XML output\n                \"--top-module\", topmod, step.path]\n            execMain(step, verilator_mod, args);\n        } catch (e) {\n            console.log(e);\n            errors.push({ line: 0, msg: \"Compiler internal error: \" + e });\n        }\n        endtime(\"compile\");\n        // remove boring errors\n        errors = errors.filter(function (e) { return !/Exiting due to \\d+/.exec(e.msg); }, errors);\n        errors = errors.filter(function (e) { return !/Use [\"][/][*]/.exec(e.msg); }, errors);\n        if (errors.length) {\n            return { errors: errors };\n        }\n        starttime();\n        var xmlParser = new vxmlparser.VerilogXMLParser();\n        try {\n            var xmlContent = FS.readFile(xmlPath, { encoding: 'utf8' });\n            var xmlScrubbed = xmlContent.replace(/ fl=\".+?\" loc=\".+?\"/g, '');\n            // TODO: this squelches the .asm listing\n            //listings[step.prefix + '.xml'] = {lines:[],text:xmlContent};\n            putWorkFile(xmlPath, xmlScrubbed); // don't detect changes in source position\n            if (!anyTargetChanged(step, [xmlPath]))\n                return;\n            xmlParser.parse(xmlContent);\n        } catch (e) {\n            console.log(e, e.stack);\n            if (e.$loc != null) {\n                let $loc = e.$loc as SourceLocation;\n                errors.push({ msg: \"\" + e, path: $loc.path, line: $loc.line });\n            } else {\n                errors.push({ line: 0, msg: \"\" + e });\n            }\n            return { errors: errors, listings: listings };\n        } finally {\n            endtime(\"parse\");\n        }\n        return {\n            output: xmlParser,\n            errors: errors,\n            listings: listings,\n        };\n    }\n}\n\n// TODO: test\nexport function compileYosys(step: BuildStep): BuildStepResult {\n    loadNative(\"yosys\");\n    var code = step.code;\n    var errors = [];\n    var match_fn = makeErrorMatcher(errors, /ERROR: (.+?) in line (.+?[.]v):(\\d+)[: ]+(.+)/i, 3, 4, step.path);\n    starttime();\n    var yosys_mod: EmscriptenModule = emglobal.yosys({\n        instantiateWasm: moduleInstFn('yosys'),\n        noInitialRun: true,\n        print: print_fn,\n        printErr: match_fn,\n    });\n    endtime(\"create module\");\n    var topmod = detectTopModuleName(code);\n    var FS = yosys_mod.FS;\n    FS.writeFile(topmod + \".v\", code);\n    starttime();\n    try {\n        execMain(step, yosys_mod, [\"-q\", \"-o\", topmod + \".json\", \"-S\", topmod + \".v\"]);\n    } catch (e) {\n        console.log(e);\n        endtime(\"compile\");\n        return { errors: errors };\n    }\n    endtime(\"compile\");\n    //TODO: filename in errors\n    if (errors.length) return { errors: errors };\n    try {\n        var json_file = FS.readFile(topmod + \".json\", { encoding: 'utf8' });\n        var json = JSON.parse(json_file);\n        console.log(json);\n        return { output: json, errors: errors }; // TODO\n    } catch (e) {\n        console.log(e);\n        return { errors: errors };\n    }\n}\n\nexport function compileSilice(step: BuildStep): BuildStepResult {\n    loadNative(\"silice\");\n    var params = step.params;\n    gatherFiles(step, { mainFilePath: \"main.ice\" });\n    var destpath = step.prefix + '.v';\n    var errors: WorkerError[] = [];\n    var errfile: string;\n    var errline: number;\n    if (staleFiles(step, [destpath])) {\n        //[preprocessor] 97]  attempt to concatenate a nil value (global 'addrW')\n        var match_fn = (s: string) => {\n            s = (s as any).replaceAll(/\\033\\[\\d+\\w/g, '');\n            var mf = /file:\\s*(\\w+)/.exec(s);\n            var ml = /line:\\s+(\\d+)/.exec(s);\n            var preproc = /\\[preprocessor\\] (\\d+)\\] (.+)/.exec(s);\n            if (mf) errfile = mf[1];\n            else if (ml) errline = parseInt(ml[1]);\n            else if (preproc) {\n                errors.push({ path: step.path, line: parseInt(preproc[1]), msg: preproc[2] });\n            }\n            else if (errfile && errline && s.length > 1) {\n                if (s.length > 2) {\n                    errors.push({ path: errfile + \".ice\", line: errline, msg: s });\n                } else {\n                    errfile = null;\n                    errline = null;\n                }\n            }\n            else console.log(s);\n        }\n        var silice: EmscriptenModule = emglobal.silice({\n            instantiateWasm: moduleInstFn('silice'),\n            noInitialRun: true,\n            print: match_fn,\n            printErr: match_fn,\n        });\n        var FS = silice.FS;\n        setupFS(FS, 'Silice');\n        populateFiles(step, FS);\n        populateExtraFiles(step, FS, params.extra_compile_files);\n        const FWDIR = '/share/frameworks';\n        var args = [\n            '-D', 'NTSC=1',\n            '--frameworks_dir', FWDIR,\n            '-f', `/8bitworkshop.v`,\n            '-o', destpath,\n            step.path];\n        execMain(step, silice, args);\n        if (errors.length)\n            return { errors: errors };\n        var vout = FS.readFile(destpath, { encoding: 'utf8' });\n        putWorkFile(destpath, vout);\n    }\n    return {\n        nexttool: \"verilator\",\n        path: destpath,\n        args: [destpath],\n        files: [destpath],\n    };\n}\n\n", "import { CodeListingMap, WorkerError } from \"../../common/workertypes\";\nimport { BuildStep, BuildStepResult, load, emglobal, print_fn, populateFiles, execMain, putWorkFile, parseListing, loadNative, gatherFiles, staleFiles, moduleInstFn, getWorkFileAsString, preprocessMCPP, fixParamsWithDefines, msvcErrorMatcher, populateExtraFiles, anyTargetChanged, parseSourceLines } from \"../workermain\";\nimport { EmscriptenModule } from \"../workermain\";\n\n// http://datapipe-blackbeltsystems.com/windows/flex/asm09.html\nexport function assembleXASM6809(step: BuildStep): BuildStepResult {\n    load(\"xasm6809\");\n    var alst = \"\";\n    var lasterror = null;\n    var errors = [];\n    function match_fn(s) {\n        alst += s;\n        alst += \"\\n\";\n        if (lasterror) {\n            var line = parseInt(s.slice(0, 5)) || 0;\n            errors.push({\n                line: line,\n                msg: lasterror\n            });\n            lasterror = null;\n        }\n        else if (s.startsWith(\"***** \")) {\n            lasterror = s.slice(6);\n        }\n    }\n    var Module: EmscriptenModule = emglobal.xasm6809({\n        noInitialRun: true,\n        //logReadFiles:true,\n        print: match_fn,\n        printErr: print_fn\n    });\n    var FS = Module.FS;\n    //setupFS(FS);\n    populateFiles(step, FS, {\n        mainFilePath: 'main.asm'\n    });\n    var binpath = step.prefix + '.bin';\n    var lstpath = step.prefix + '.lst'; // in stdout\n    execMain(step, Module, [\"-c\", \"-l\", \"-s\", \"-y\", \"-o=\" + binpath, step.path]);\n    if (errors.length)\n        return { errors: errors };\n    var aout = FS.readFile(binpath, { encoding: 'binary' });\n    if (aout.length == 0) {\n        errors.push({ line: 0, msg: \"Empty output file\" });\n        return { errors: errors };\n    }\n    putWorkFile(binpath, aout);\n    putWorkFile(lstpath, alst);\n    // TODO: symbol map\n    //mond09     0000     \n    var symbolmap = {};\n    //00005  W 0003 [ 8] A6890011            lda   >PALETTE,x\n    //00012    0011      0C0203              fcb   12,2,3\n    var asmlines = parseListing(alst, /^\\s*([0-9]+) .+ ([0-9A-F]+)\\s+\\[([0-9 ]+)\\]\\s+([0-9A-F]+) (.*)/i, 1, 2, 4, 3);\n    var listings: CodeListingMap = {};\n    listings[step.prefix + '.lst'] = { lines: asmlines, text: alst };\n    return {\n        output: aout,\n        listings: listings,\n        errors: errors,\n        symbolmap: symbolmap,\n    };\n}\n\nexport function compileCMOC(step: BuildStep): BuildStepResult {\n    loadNative(\"cmoc\");\n    var params = step.params;\n    // stderr\n    var re_err1 = /^[/]*([^:]*):(\\d+): (.+)$/;\n    var errors: WorkerError[] = [];\n    var errline = 0;\n    function match_fn(s) {\n        var matches = re_err1.exec(s);\n        if (matches) {\n            errors.push({\n                line: parseInt(matches[2]),\n                msg: matches[3],\n                path: matches[1] || step.path\n            });\n        } else {\n            console.log(s);\n        }\n    }\n    gatherFiles(step, { mainFilePath: \"main.c\" });\n    var destpath = step.prefix + '.s';\n    if (staleFiles(step, [destpath])) {\n        var args = ['-S', '-Werror', '-V',\n            '-I/share/include',\n            '-I.',\n            step.path];\n        var CMOC: EmscriptenModule = emglobal.cmoc({\n            instantiateWasm: moduleInstFn('cmoc'),\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: match_fn,\n            printErr: match_fn,\n        });\n        // load source file and preprocess\n        var code = getWorkFileAsString(step.path);\n        var preproc = preprocessMCPP(step, null);\n        if (preproc.errors) {\n            return { errors: preproc.errors }\n        }\n        else code = preproc.code;\n        // set up filesystem\n        var FS = CMOC.FS;\n        //setupFS(FS, '65-'+getRootBasePlatform(step.platform));\n        populateFiles(step, FS);\n        FS.writeFile(step.path, code);\n        fixParamsWithDefines(step.path, params);\n        if (params.extra_compile_args) {\n            args.unshift.apply(args, params.extra_compile_args);\n        }\n        execMain(step, CMOC, args);\n        if (errors.length)\n            return { errors: errors };\n        var asmout = FS.readFile(destpath, { encoding: 'utf8' });\n        if (step.params.set_stack_end)\n            asmout = asmout.replace('stack space in bytes', `\\n lds #${step.params.set_stack_end}\\n`)\n        putWorkFile(destpath, asmout);\n    }\n    return {\n        nexttool: \"lwasm\",\n        path: destpath,\n        args: [destpath],\n        files: [destpath],\n    };\n}\n\nexport function assembleLWASM(step: BuildStep): BuildStepResult {\n    loadNative(\"lwasm\");\n    var errors = [];\n    gatherFiles(step, { mainFilePath: \"main.s\" });\n    var objpath = step.prefix + \".o\";\n    var lstpath = step.prefix + \".lst\";\n    const isRaw = step.path.endsWith('.asm');\n    if (staleFiles(step, [objpath, lstpath])) {\n        var objout, lstout;\n        var args = ['-9', '-I/share/asminc', '-o' + objpath, '-l' + lstpath, step.path];\n        args.push(isRaw ? '-r' : '--obj');\n        var LWASM: EmscriptenModule = emglobal.lwasm({\n            instantiateWasm: moduleInstFn('lwasm'),\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: print_fn,\n            printErr: msvcErrorMatcher(errors),\n        });\n        var FS = LWASM.FS;\n        //setupFS(FS, '65-'+getRootBasePlatform(step.platform));\n        populateFiles(step, FS);\n        fixParamsWithDefines(step.path, step.params);\n        execMain(step, LWASM, args);\n        if (errors.length)\n            return { errors: errors };\n        objout = FS.readFile(objpath, { encoding: 'binary' });\n        lstout = FS.readFile(lstpath, { encoding: 'utf8' });\n        putWorkFile(objpath, objout);\n        putWorkFile(lstpath, lstout);\n        if (isRaw) {\n            return {\n                output: objout\n            };\n        }\n    }\n    return {\n        linktool: \"lwlink\",\n        files: [objpath, lstpath],\n        args: [objpath]\n    };\n}\n\nexport function linkLWLINK(step: BuildStep): BuildStepResult {\n    loadNative(\"lwlink\");\n    var params = step.params;\n    gatherFiles(step);\n    var binpath = \"main\";\n    if (staleFiles(step, [binpath])) {\n        var errors = [];\n        var LWLINK: EmscriptenModule = emglobal.lwlink({\n            instantiateWasm: moduleInstFn('lwlink'),\n            noInitialRun: true,\n            //logReadFiles:true,\n            print: print_fn,\n            printErr: function (s) {\n                if (s.startsWith(\"Warning:\"))\n                    console.log(s);\n                else\n                    errors.push({ msg: s, line: 0 });\n            }\n        });\n        var FS = LWLINK.FS;\n        //setupFS(FS, '65-'+getRootBasePlatform(step.platform));\n        populateFiles(step, FS);\n        populateExtraFiles(step, FS, params.extra_link_files);\n        var libargs = params.extra_link_args || [];\n        var args = [\n            '-L.',\n            '--entry=program_start',\n            '--raw',\n            '--output=main',\n            '--map=main.map'].concat(libargs, step.args);\n        console.log(args);\n        execMain(step, LWLINK, args);\n        if (errors.length)\n            return { errors: errors };\n        var aout = FS.readFile(\"main\", { encoding: 'binary' });\n        var mapout = FS.readFile(\"main.map\", { encoding: 'utf8' });\n        putWorkFile(\"main\", aout);\n        putWorkFile(\"main.map\", mapout);\n        // return unchanged if no files changed\n        if (!anyTargetChanged(step, [\"main\", \"main.map\"]))\n            return;\n        // parse symbol map\n        //console.log(mapout);\n        var symbolmap = {};\n        var segments = [];\n        for (var s of mapout.split(\"\\n\")) {\n            var toks = s.split(\" \");\n            // TODO: use regex\n            if (toks[0] == 'Symbol:') {\n                let ident = toks[1];\n                let ofs = parseInt(toks[4], 16);\n                if (ident && ofs >= 0 \n                  && !ident.startsWith(\"l_\") \n                  //&& !/^L\\d+$/.test(ident)\n                  && !ident.startsWith('funcsize_')\n                  && !ident.startsWith('funcend_')) {\n                    symbolmap[ident] = ofs;\n                }\n            }\n            else if (toks[0] == 'Section:') {\n                let seg = toks[1];\n                let segstart = parseInt(toks[5], 16);\n                let segsize = parseInt(toks[7], 16);\n                segments.push({ name: seg, start: segstart, size: segsize });\n            }\n        }\n        // build listings\n        const re_segment = /\\s*SECTION\\s+(\\w+)/i;\n        const re_function = /\\s*([0-9a-f]+).+?(\\w+)\\s+EQU\\s+[*]/i;\n        var listings: CodeListingMap = {};\n        for (var fn of step.files) {\n            if (fn.endsWith('.lst')) {\n                // TODO\n                var lstout = FS.readFile(fn, { encoding: 'utf8' });\n                var asmlines = parseListing(lstout, /^([0-9A-F]+)\\s+([0-9A-F]+)\\s+[(]\\s*(.+?)[)]:(\\d+) (.*)/i, 4, 1, 2, 3, re_function, re_segment);\n                for (let l of asmlines) {\n                    l.offset += symbolmap[l.func] || 0;\n                }\n                // * Line //threed.c:117: init of variable e\n                var srclines = parseSourceLines(lstout, /Line .+?:(\\d+)/i, /^([0-9A-F]{4})/i, re_function, re_segment);\n                for (let l of srclines) {\n                    l.offset += symbolmap[l.func] || 0;\n                }\n                putWorkFile(fn, lstout);\n                // strip out left margin\n                lstout = lstout.split('\\n').map(l => l.substring(0,15) + l.substring(56)).join('\\n')\n                // TODO: you have to get rid of all source lines to get asm listing\n                listings[fn] = {\n                    asmlines: srclines.length ? asmlines : null,\n                    lines: srclines.length ? srclines : asmlines,\n                    text: lstout\n                };\n            }\n        }\n        return {\n            output: aout, //.slice(0),\n            listings: listings,\n            errors: errors,\n            symbolmap: symbolmap,\n            segments: segments\n        };\n    }\n}\n\n", "\nimport { WorkerError, CodeListingMap } from \"../../common/workertypes\";\nimport { anyTargetChanged, BuildStep, BuildStepResult, emglobal, EmscriptenModule, execMain, gatherFiles, loadNative, makeErrorMatcher, moduleInstFn, parseListing, populateFiles, print_fn, putWorkFile, staleFiles } from \"../workermain\"\n\n\n// http://www.nespowerpak.com/nesasm/\nexport function assembleNESASM(step: BuildStep): BuildStepResult {\n    loadNative(\"nesasm\");\n    var re_filename = /\\#\\[(\\d+)\\]\\s+(\\S+)/;\n    var re_insn = /\\s+(\\d+)\\s+([0-9A-F]+):([0-9A-F]+)/;\n    var re_error = /\\s+(.+)/;\n    var errors: WorkerError[] = [];\n    var state = 0;\n    var lineno = 0;\n    var filename;\n    function match_fn(s) {\n        var m;\n        switch (state) {\n            case 0:\n                m = re_filename.exec(s);\n                if (m) {\n                    filename = m[2];\n                }\n                m = re_insn.exec(s);\n                if (m) {\n                    lineno = parseInt(m[1]);\n                    state = 1;\n                }\n                break;\n            case 1:\n                m = re_error.exec(s);\n                if (m) {\n                    errors.push({ path: filename, line: lineno, msg: m[1] });\n                    state = 0;\n                }\n                break;\n        }\n    }\n    var Module: EmscriptenModule = emglobal.nesasm({\n        instantiateWasm: moduleInstFn('nesasm'),\n        noInitialRun: true,\n        print: match_fn\n    });\n    var FS = Module.FS;\n    populateFiles(step, FS, {\n        mainFilePath: 'main.a'\n    });\n    var binpath = step.prefix + '.nes';\n    var lstpath = step.prefix + '.lst';\n    var sympath = step.prefix + '.fns';\n    execMain(step, Module, [step.path, '-s', \"-l\", \"2\"]);\n    // parse main listing, get errors and listings for each file\n    var listings: CodeListingMap = {};\n    try {\n        var alst = FS.readFile(lstpath, { 'encoding': 'utf8' });\n        //   16  00:C004  8E 17 40    STX $4017    ; disable APU frame IRQ\n        var asmlines = parseListing(alst, /^\\s*(\\d+)\\s+([0-9A-F]+):([0-9A-F]+)\\s+([0-9A-F ]+?)  (.*)/i, 1, 3, 4);\n        putWorkFile(lstpath, alst);\n        listings[lstpath] = {\n            lines: asmlines,\n            text: alst\n        };\n    } catch (e) {\n        //\n    }\n    if (errors.length) {\n        return { errors: errors };\n    }\n    // read binary rom output and symbols\n    var aout, asym;\n    aout = FS.readFile(binpath);\n    try {\n        asym = FS.readFile(sympath, { 'encoding': 'utf8' });\n    } catch (e) {\n        console.log(e);\n        errors.push({ line: 0, msg: \"No symbol table generated, maybe missing ENDM or segment overflow?\" });\n        return { errors: errors }\n    }\n    putWorkFile(binpath, aout);\n    putWorkFile(sympath, asym);\n    if (alst) putWorkFile(lstpath, alst); // listing optional (use LIST)\n    // return unchanged if no files changed\n    if (!anyTargetChanged(step, [binpath, sympath]))\n        return;\n    // parse symbols\n    var symbolmap = {};\n    for (var s of asym.split(\"\\n\")) {\n        if (!s.startsWith(';')) {\n            var m = /(\\w+)\\s+=\\s+[$]([0-9A-F]+)/.exec(s);\n            if (m) {\n                symbolmap[m[1]] = parseInt(m[2], 16);\n            }\n        }\n    }\n    return {\n        output: aout,\n        listings: listings,\n        errors: errors,\n        symbolmap: symbolmap,\n    };\n}\n\n\n/*\n------+-------------------+-------------+----+---------+------+-----------------------+-------------------------------------------------------------------\nLine | # File       Line | Line Type   | MX |  Reloc  | Size | Address   Object Code |  Source Code                                                      \n------+-------------------+-------------+----+---------+------+-----------------------+-------------------------------------------------------------------\n  1 |  1 zap.asm      1 | Unknown     | ?? |         |   -1 | 00/FFFF               |             broak                       \n  2 |  1 zap.asm      2 | Comment     | ?? |         |   -1 | 00/FFFF               | * SPACEGAME\n  \n    => [Error] Impossible to decode address mode for instruction 'BNE  KABOOM!' (line 315, file 'zap.asm') : The number of element in 'KABOOM!' is even (should be value [operator value [operator value]...]).\n    => [Error] Unknown line 'foo' in source file 'zap.asm' (line 315)\n        => Creating Object file 'pcs.bin'\n        => Creating Output file 'pcs.bin_S01__Output.txt'\n\n*/\nexport function assembleMerlin32(step: BuildStep): BuildStepResult {\n    loadNative(\"merlin32\");\n    var errors = [];\n    var lstfiles = [];\n    gatherFiles(step, { mainFilePath: \"main.lnk\" });\n    var objpath = step.prefix + \".bin\";\n    if (staleFiles(step, [objpath])) {\n        var args = ['-v', step.path];\n        var merlin32: EmscriptenModule = emglobal.merlin32({\n            instantiateWasm: moduleInstFn('merlin32'),\n            noInitialRun: true,\n            print: (s: string) => {\n                var m = /\\s*=>\\s*Creating Output file '(.+?)'/.exec(s);\n                if (m) {\n                    lstfiles.push(m[1]);\n                }\n                var errpos = s.indexOf('Error');\n                if (errpos >= 0) {\n                    s = s.slice(errpos + 6).trim();\n                    var mline = /\\bline (\\d+)\\b/.exec(s);\n                    var mpath = /\\bfile '(.+?)'/.exec(s);\n                    errors.push({\n                        line: parseInt(mline[1]) || 0,\n                        msg: s,\n                        path: mpath[1] || step.path,\n                    });\n                }\n            },\n            printErr: print_fn,\n        });\n        var FS = merlin32.FS;\n        populateFiles(step, FS);\n        execMain(step, merlin32, args);\n        if (errors.length)\n            return { errors: errors };\n\n        var errout = null;\n        try {\n            errout = FS.readFile(\"error_output.txt\", { encoding: 'utf8' });\n        } catch (e) {\n            //\n        }\n\n        var objout = FS.readFile(objpath, { encoding: 'binary' });\n        putWorkFile(objpath, objout);\n        if (!anyTargetChanged(step, [objpath]))\n            return;\n\n        var symbolmap = {};\n        var segments = [];\n        var listings: CodeListingMap = {};\n        lstfiles.forEach((lstfn) => {\n            var lst = FS.readFile(lstfn, { encoding: 'utf8' }) as string;\n            lst.split('\\n').forEach((line) => {\n                var toks = line.split(/\\s*\\|\\s*/);\n                if (toks && toks[6]) {\n                    var toks2 = toks[1].split(/\\s+/);\n                    var toks3 = toks[6].split(/[:/]/, 4);\n                    var path = toks2[1];\n                    if (path && toks2[2] && toks3[1]) {\n                        var lstline = {\n                            line: parseInt(toks2[2]),\n                            offset: parseInt(toks3[1].trim(), 16),\n                            insns: toks3[2],\n                            cycles: null,\n                            iscode: false // TODO\n                        };\n                        var lst = listings[path];\n                        if (!lst) listings[path] = lst = { lines: [] };\n                        lst.lines.push(lstline);\n                        //console.log(path,toks2,toks3);\n                    }\n                }\n            });\n        });\n        return {\n            output: objout, //.slice(0),\n            listings: listings,\n            errors: errors,\n            symbolmap: symbolmap,\n            segments: segments\n        };\n    }\n}\n\n// README.md:2:5: parse error, expected: statement or variable assignment, integer variable, variable assignment\nexport function compileFastBasic(step: BuildStep): BuildStepResult {\n    // TODO: fastbasic-fp?\n    loadNative(\"fastbasic-int\");\n    var params = step.params;\n    gatherFiles(step, { mainFilePath: \"main.fb\" });\n    var destpath = step.prefix + '.s';\n    var errors = [];\n    if (staleFiles(step, [destpath])) {\n        var fastbasic: EmscriptenModule = emglobal.fastbasic({\n            instantiateWasm: moduleInstFn('fastbasic-int'),\n            noInitialRun: true,\n            print: print_fn,\n            printErr: makeErrorMatcher(errors, /(.+?):(\\d+):(\\d+):\\s*(.+)/, 2, 4, step.path, 1),\n        });\n        var FS = fastbasic.FS;\n        populateFiles(step, FS);\n        var libfile = 'fastbasic-int.lib'\n        params.libargs = [libfile];\n        params.cfgfile = params.fastbasic_cfgfile;\n        //params.extra_compile_args = [\"--asm-define\", \"NO_SMCODE\"];\n        params.extra_link_files = [libfile, params.cfgfile];\n        //fixParamsWithDefines(step.path, params);\n        var args = [step.path, destpath];\n        execMain(step, fastbasic, args);\n        if (errors.length)\n            return { errors: errors };\n        var asmout = FS.readFile(destpath, { encoding: 'utf8' });\n        putWorkFile(destpath, asmout);\n    }\n    return {\n        nexttool: \"ca65\",\n        path: destpath,\n        args: [destpath],\n        files: [destpath],\n    };\n}\n\n", "\nimport { CodeListingMap } from \"../../common/workertypes\";\nimport { anyTargetChanged, BuildStep, BuildStepResult, emglobal, EmscriptenModule, execMain, gatherFiles, loadNative, makeErrorMatcher, moduleInstFn, parseListing, populateFiles, print_fn, putWorkFile, staleFiles } from \"../workermain\"\n\n\nexport function assembleZMAC(step: BuildStep): BuildStepResult {\n  loadNative(\"zmac\");\n  var hexout, lstout, binout;\n  var errors = [];\n  var params = step.params;\n  gatherFiles(step, { mainFilePath: \"main.asm\" });\n  var lstpath = step.prefix + \".lst\";\n  var binpath = step.prefix + \".cim\";\n  if (staleFiles(step, [binpath, lstpath])) {\n    /*\n  error1.asm(4) : 'l18d4' Undeclared\n         JP      L18D4\n  \n  error1.asm(11): warning: 'foobar' treated as label (instruction typo?)\n      Add a colon or move to first column to stop this warning.\n  1 errors (see listing if no diagnostics appeared here)\n    */\n    var ZMAC: EmscriptenModule = emglobal.zmac({\n      instantiateWasm: moduleInstFn('zmac'),\n      noInitialRun: true,\n      //logReadFiles:true,\n      print: print_fn,\n      printErr: makeErrorMatcher(errors, /([^( ]+)\\s*[(](\\d+)[)]\\s*:\\s*(.+)/, 2, 3, step.path),\n    });\n    var FS = ZMAC.FS;\n    populateFiles(step, FS);\n    // TODO: don't know why CIM (hexary) doesn't work\n    execMain(step, ZMAC, ['-z', '-c', '--oo', 'lst,cim', step.path]);\n    if (errors.length) {\n      return { errors: errors };\n    }\n    lstout = FS.readFile(\"zout/\" + lstpath, { encoding: 'utf8' });\n    binout = FS.readFile(\"zout/\" + binpath, { encoding: 'binary' });\n    putWorkFile(binpath, binout);\n    putWorkFile(lstpath, lstout);\n    if (!anyTargetChanged(step, [binpath, lstpath]))\n      return;\n    //  230: 1739+7+x   017A  1600      L017A: LD      D,00h\n    var lines = parseListing(lstout, /\\s*(\\d+):\\s*([0-9a-f]+)\\s+([0-9a-f]+)\\s+(.+)/i, 1, 2, 3);\n    var listings: CodeListingMap = {};\n    listings[lstpath] = { lines: lines };\n    // parse symbol table\n    var symbolmap = {};\n    var sympos = lstout.indexOf('Symbol Table:');\n    if (sympos > 0) {\n      var symout = lstout.slice(sympos + 14);\n      symout.split('\\n').forEach(function (l) {\n        var m = l.match(/(\\S+)\\s+([= ]*)([0-9a-f]+)/i);\n        if (m) {\n          symbolmap[m[1]] = parseInt(m[3], 16);\n        }\n      });\n    }\n    return {\n      output: binout,\n      listings: listings,\n      errors: errors,\n      symbolmap: symbolmap\n    };\n  }\n}\n\n", "import { WorkerError, CodeListingMap } from \"../../common/workertypes\";\nimport { BuildStep, BuildStepResult, loadNative, gatherFiles, staleFiles, emglobal, moduleInstFn, getWorkFileAsString, preprocessMCPP, populateFiles, fixParamsWithDefines, execMain, putWorkFile, print_fn, msvcErrorMatcher, anyTargetChanged, parseListing } from \"../workermain\";\nimport { EmscriptenModule } from \"../workermain\"\n\n// http://www.techhelpmanual.com/829-program_startup___exit.html\nexport function compileSmallerC(step: BuildStep): BuildStepResult {\n  loadNative(\"smlrc\");\n  var params = step.params;\n  // stderr\n  var re_err1 = /^Error in \"[/]*(.+)\" [(](\\d+):(\\d+)[)]/;\n  var errors: WorkerError[] = [];\n  var errline = 0;\n  var errpath = step.path;\n  function match_fn(s) {\n    var matches = re_err1.exec(s);\n    if (matches) {\n      errline = parseInt(matches[2]);\n      errpath = matches[1];\n    } else {\n      errors.push({\n        line: errline,\n        msg: s,\n        path: errpath,\n      });\n    }\n  }\n  gatherFiles(step, { mainFilePath: \"main.c\" });\n  var destpath = step.prefix + '.asm';\n  if (staleFiles(step, [destpath])) {\n    var args = ['-seg16',\n      //'-nobss',\n      '-no-externs',\n      step.path, destpath];\n    var smlrc: EmscriptenModule = emglobal.smlrc({\n      instantiateWasm: moduleInstFn('smlrc'),\n      noInitialRun: true,\n      //logReadFiles:true,\n      print: match_fn,\n      printErr: match_fn,\n    });\n    // load source file and preprocess\n    var code = getWorkFileAsString(step.path);\n    var preproc = preprocessMCPP(step, null);\n    if (preproc.errors) {\n      return { errors: preproc.errors };\n    }\n    else code = preproc.code;\n    // set up filesystem\n    var FS = smlrc.FS;\n    //setupFS(FS, '65-'+getRootBasePlatform(step.platform));\n    populateFiles(step, FS);\n    FS.writeFile(step.path, code);\n    fixParamsWithDefines(step.path, params);\n    if (params.extra_compile_args) {\n      args.unshift.apply(args, params.extra_compile_args);\n    }\n    execMain(step, smlrc, args);\n    if (errors.length)\n      return { errors: errors };\n    var asmout = FS.readFile(destpath, { encoding: 'utf8' });\n    putWorkFile(destpath, asmout);\n  }\n  return {\n    nexttool: \"yasm\",\n    path: destpath,\n    args: [destpath],\n    files: [destpath],\n  };\n}\n\nexport function assembleYASM(step: BuildStep): BuildStepResult {\n  loadNative(\"yasm\");\n  var errors = [];\n  gatherFiles(step, { mainFilePath: \"main.asm\" });\n  var objpath = step.prefix + \".exe\";\n  var lstpath = step.prefix + \".lst\";\n  var mappath = step.prefix + \".map\";\n  if (staleFiles(step, [objpath])) {\n    var args = ['-X', 'vc',\n      '-a', 'x86', '-f', 'dosexe', '-p', 'nasm',\n      '-D', 'freedos',\n      //'-g', 'dwarf2',\n      //'-I/share/asminc',\n      '-o', objpath, '-l', lstpath, '--mapfile=' + mappath,\n      step.path];\n    // return yasm/*.ready*/\n    var YASM: EmscriptenModule = emglobal.yasm({\n      instantiateWasm: moduleInstFn('yasm'),\n      noInitialRun: true,\n      //logReadFiles:true,\n      print: print_fn,\n      printErr: msvcErrorMatcher(errors),\n    });\n    var FS = YASM.FS;\n    //setupFS(FS, '65-'+getRootBasePlatform(step.platform));\n    populateFiles(step, FS);\n    //fixParamsWithDefines(step.path, step.params);\n    execMain(step, YASM, args);\n    if (errors.length)\n      return { errors: errors };\n    var objout, lstout, mapout;\n    objout = FS.readFile(objpath, { encoding: 'binary' });\n    lstout = FS.readFile(lstpath, { encoding: 'utf8' });\n    mapout = FS.readFile(mappath, { encoding: 'utf8' });\n    putWorkFile(objpath, objout);\n    putWorkFile(lstpath, lstout);\n    //putWorkFile(mappath, mapout);\n    if (!anyTargetChanged(step, [objpath]))\n      return;\n    var symbolmap = {};\n    var segments = [];\n    var lines = parseListing(lstout, /\\s*(\\d+)\\s+([0-9a-f]+)\\s+([0-9a-f]+)\\s+(.+)/i, 1, 2, 3);\n    var listings: CodeListingMap = {};\n    listings[lstpath] = { lines: lines, text: lstout };\n    return {\n      output: objout, //.slice(0),\n      listings: listings,\n      errors: errors,\n      symbolmap: symbolmap,\n      segments: segments\n    };\n  }\n}\n\n", "\nimport { hex } from \"../../common/util\";\nimport { WorkerResult, CodeListingMap, WorkerError, SourceLine } from \"../../common/workertypes\";\nimport { anyTargetChanged, BuildStep, BuildStepResult, emglobal, EmscriptenModule, execMain, gatherFiles, getPrefix, getWorkFileAsString, loadNative, makeErrorMatcher, moduleInstFn, populateFiles, putWorkFile, re_crlf, staleFiles } from \"../workermain\"\n\nexport function assembleARMIPS(step: BuildStep): WorkerResult {\n    loadNative(\"armips\");\n    var errors = [];\n    gatherFiles(step, { mainFilePath: \"main.asm\" });\n    var objpath = \"main.bin\";\n    var lstpath = step.prefix + \".lst\";\n    var sympath = step.prefix + \".sym\";\n    //test.armips(3) error: Parse error '.arm'\n    var error_fn = makeErrorMatcher(errors, /^(.+?)\\((\\d+)\\)\\s+(fatal error|error|warning):\\s+(.+)/, 2, 4, step.path, 1);\n\n    if (staleFiles(step, [objpath])) {\n        var args = [step.path, '-temp', lstpath, '-sym', sympath, '-erroronwarning'];\n        var armips: EmscriptenModule = emglobal.armips({\n            instantiateWasm: moduleInstFn('armips'),\n            noInitialRun: true,\n            print: error_fn,\n            printErr: error_fn,\n        });\n\n        var FS = armips.FS;\n        var code = getWorkFileAsString(step.path);\n        code = `.arm.little :: .create \"${objpath}\",0 :: ${code}\n  .close`;\n        putWorkFile(step.path, code);\n        populateFiles(step, FS);\n        execMain(step, armips, args);\n        if (errors.length)\n            return { errors: errors };\n\n        var objout = FS.readFile(objpath, { encoding: 'binary' }) as Uint8Array;\n        putWorkFile(objpath, objout);\n        if (!anyTargetChanged(step, [objpath]))\n            return;\n\n        var symbolmap = {};\n        var segments = [];\n        var listings: CodeListingMap = {};\n        var lstout = FS.readFile(lstpath, { encoding: 'utf8' }) as string;\n        var lines = lstout.split(re_crlf);\n        //00000034 .word 0x11223344                                             ; /vidfill.armips line 25\n        var re_asmline = /^([0-9A-F]+) (.+?); [/](.+?) line (\\d+)/;\n        var lastofs = -1;\n        for (var line of lines) {\n            var m;\n            if (m = re_asmline.exec(line)) {\n                var path = m[3];\n                var path2 = getPrefix(path) + '.lst'; // TODO: don't rename listing\n                var lst = listings[path2];\n                if (lst == null) { lst = listings[path2] = { lines: [] }; }\n                var ofs = parseInt(m[1], 16);\n                if (lastofs == ofs) {\n                    lst.lines.pop(); // get rid of duplicate offset\n                } else if (ofs > lastofs) {\n                    var lastline = lst.lines[lst.lines.length - 1];\n                    if (lastline && !lastline.insns) {\n                        var insns = objout.slice(lastofs, ofs).reverse();\n                        lastline.insns = Array.from(insns).map((b) => hex(b, 2)).join('');\n                    }\n                }\n                lst.lines.push({\n                    path: path,\n                    line: parseInt(m[4]),\n                    offset: ofs\n                });\n                lastofs = ofs;\n            }\n        }\n        //listings[lstpath] = {lines:lstlines, text:lstout};\n\n        var symout = FS.readFile(sympath, { encoding: 'utf8' }) as string;\n        //0000000C loop2\n        //00000034 .dbl:0004\n        var re_symline = /^([0-9A-F]+)\\s+(.+)/;\n        for (var line of symout.split(re_crlf)) {\n            var m;\n            if (m = re_symline.exec(line)) {\n                symbolmap[m[2]] = parseInt(m[1], 16);\n            }\n        }\n\n        return {\n            output: objout, //.slice(0),\n            listings: listings,\n            errors: errors,\n            symbolmap: symbolmap,\n            segments: segments\n        };\n    }\n}\n\nexport function assembleVASMARM(step: BuildStep): BuildStepResult {\n    loadNative(\"vasmarm_std\");\n    /// error 2 in line 8 of \"gfxtest.c\": unknown mnemonic <ew>\n    /// error 3007: undefined symbol <XXLOOP>\n    /// TODO: match undefined symbols\n    var re_err1 = /^(fatal error|error|warning)? (\\d+) in line (\\d+) of \"(.+)\": (.+)/;\n    var re_err2 = /^(fatal error|error|warning)? (\\d+): (.+)/;\n    var re_undefsym = /symbol <(.+?)>/;\n    var errors: WorkerError[] = [];\n    var undefsyms = [];\n    function findUndefinedSymbols(line: string) {\n        // find undefined symbols in line\n        undefsyms.forEach((sym) => {\n            if (line.indexOf(sym) >= 0) {\n                errors.push({\n                    path: curpath,\n                    line: curline,\n                    msg: \"Undefined symbol: \" + sym,\n                })\n            }\n        });\n    }\n    function match_fn(s) {\n        let matches = re_err1.exec(s);\n        if (matches) {\n            errors.push({\n                line: parseInt(matches[3]),\n                path: matches[4],\n                msg: matches[5],\n            });\n        } else {\n            matches = re_err2.exec(s);\n            if (matches) {\n                let m = re_undefsym.exec(matches[3]);\n                if (m) {\n                    undefsyms.push(m[1]);\n                } else {\n                    errors.push({\n                        line: 0,\n                        msg: s,\n                    });\n                }\n            } else {\n                console.log(s);\n            }\n        }\n    }\n\n    gatherFiles(step, { mainFilePath: \"main.asm\" });\n    var objpath = step.prefix + \".bin\";\n    var lstpath = step.prefix + \".lst\";\n\n    if (staleFiles(step, [objpath])) {\n        var args = ['-Fbin', '-m7tdmi', '-x', '-wfail', step.path, '-o', objpath, '-L', lstpath];\n        var vasm: EmscriptenModule = emglobal.vasm({\n            instantiateWasm: moduleInstFn('vasmarm_std'),\n            noInitialRun: true,\n            print: match_fn,\n            printErr: match_fn,\n        });\n\n        var FS = vasm.FS;\n        populateFiles(step, FS);\n        execMain(step, vasm, args);\n        if (errors.length) {\n            return { errors: errors };\n        }\n\n        if (undefsyms.length == 0) {\n            var objout = FS.readFile(objpath, { encoding: 'binary' });\n            putWorkFile(objpath, objout);\n            if (!anyTargetChanged(step, [objpath]))\n                return;\n        }\n\n        var lstout = FS.readFile(lstpath, { encoding: 'utf8' });\n        // 00:00000018 023020E0        \t    14:  eor r3, r0, r2\n        // Source: \"vidfill.vasm\"\n        // 00: \".text\" (0-40)\n        // LOOP                            00:00000018\n        // STACK                            S:20010000\n        var symbolmap = {};\n        var segments = []; // TODO\n        var listings: CodeListingMap = {};\n        // TODO: parse listings\n        var re_asmline = /^(\\d+):([0-9A-F]+)\\s+([0-9A-F ]+)\\s+(\\d+)([:M])/;\n        var re_secline = /^(\\d+):\\s+\"(.+)\"/;\n        var re_nameline = /^Source:\\s+\"(.+)\"/;\n        var re_symline = /^(\\w+)\\s+(\\d+):([0-9A-F]+)/;\n        var re_emptyline = /^\\s+(\\d+)([:M])/;\n        var curpath = step.path;\n        var curline = 0;\n        var sections = {};\n        // map file and section indices -> names\n        var lines: string[] = lstout.split(re_crlf);\n        // parse lines\n        var lstlines: SourceLine[] = [];\n        for (var line of lines) {\n            var m;\n            if (m = re_secline.exec(line)) {\n                sections[m[1]] = m[2];\n            } else if (m = re_nameline.exec(line)) {\n                curpath = m[1];\n            } else if (m = re_symline.exec(line)) {\n                symbolmap[m[1]] = parseInt(m[3], 16);\n            } else if (m = re_asmline.exec(line)) {\n                if (m[5] == ':') {\n                    curline = parseInt(m[4]);\n                } else {\n                    // TODO: macro line\n                }\n                lstlines.push({\n                    path: curpath,\n                    line: curline,\n                    offset: parseInt(m[2], 16),\n                    insns: m[3].replaceAll(' ', '')\n                });\n                findUndefinedSymbols(line);\n            } else if (m = re_emptyline.exec(line)) {\n                curline = parseInt(m[1]);\n                findUndefinedSymbols(line);\n            } else {\n                //console.log(line);\n            }\n        }\n        listings[lstpath] = { lines: lstlines, text: lstout };\n        // catch-all if no error generated\n        if (undefsyms.length && errors.length == 0) {\n            errors.push({\n                line: 0,\n                msg: 'Undefined symbols: ' + undefsyms.join(', ')\n            })\n        }\n\n        return {\n            output: objout, //.slice(0x34),\n            listings: listings,\n            errors: errors,\n            symbolmap: symbolmap,\n            segments: segments\n        };\n    }\n}\n\n", "\nimport type { SourceLocation, SourceLine, WorkerError, SourceLocated } from \"./workertypes\";\n\nexport class CompileError extends Error {\n    $loc: SourceLocation;\n    constructor(msg: string, loc: SourceLocation) {\n        super(msg);\n        Object.setPrototypeOf(this, CompileError.prototype);\n        this.$loc = loc;\n    }\n}\n\nexport function mergeLocs(a: SourceLocation, b: SourceLocation): SourceLocation {\n    return {\n        line: Math.min(a.line, b.line),\n        start: Math.min(a.start, b.start),\n        end: Math.max(a.end, b.end),\n        label: a.label || b.label,\n        path: a.path || b.path,\n    }\n}\n\nexport enum TokenType {\n    EOF = 'eof',\n    EOL = 'eol',\n    Ident = 'ident',\n    Comment = 'comment',\n    Ignore = 'ignore',\n    CatchAll = 'catch-all',\n}\n\nexport class Token implements SourceLocated {\n    str: string;\n    type: string;\n    eol: boolean;   // end of line?\n    $loc: SourceLocation;\n}\n\nexport class TokenRule {\n    type: string;\n    regex: RegExp;\n}\n\nconst CATCH_ALL_RULES: TokenRule[] = [\n    { type: TokenType.CatchAll, regex: /.+?/ }\n]\n\nfunction re_escape(rule: TokenRule): string {\n    return `(${rule.regex.source})`;\n}\n\nexport class TokenizerRuleSet {\n    rules: TokenRule[];\n    regex: RegExp;\n    constructor(rules: TokenRule[]) {\n        this.rules = rules.concat(CATCH_ALL_RULES);\n        var pattern = this.rules.map(re_escape).join('|');\n        this.regex = new RegExp(pattern, \"gs\"); // global, dotall\n    }\n}\n\nexport class Tokenizer {\n    ruleset: TokenizerRuleSet;\n    lineindex: number[];\n    path: string;\n    lineno: number;\n    tokens: Token[];\n    lasttoken: Token;\n    errors: WorkerError[];\n    curlabel: string;\n    eof: Token;\n    errorOnCatchAll = false;\n    deferred: (() => void)[] = [];\n\n    constructor() {\n        this.errors = [];\n        this.lineno = 0;\n        this.lineindex = [];\n        this.tokens = [];\n    }\n    setTokenRuleSet(ruleset: TokenizerRuleSet) {\n        this.ruleset = ruleset;\n    }\n    setTokenRules(rules: TokenRule[]) {\n        this.setTokenRuleSet(new TokenizerRuleSet(rules));\n    }\n    tokenizeFile(contents: string, path: string) {\n        this.path = path;\n        let m;\n        let re = /\\n|\\r\\n?/g;\n        this.lineindex.push(0);\n        while (m = re.exec(contents)) {\n            this.lineindex.push(m.index);\n        }\n        this._tokenize(contents);\n        this.eof = { type: TokenType.EOF, str: \"\", eol: true, $loc: { path: this.path, line: this.lineno } };\n        this.pushToken(this.eof);\n    }\n    _tokenize(text: string): void {\n        // iterate over each token via re_toks regex\n        let m: RegExpMatchArray;\n        this.lineno = 0;\n        while (m = this.ruleset.regex.exec(text)) {\n            let found = false;\n            // find line #\n            while (m.index >= this.lineindex[this.lineno]) {\n                this.lineno++;\n            }\n            // find out which capture group was matched, and thus token type\n            let rules = this.ruleset.rules;\n            for (let i = 0; i < rules.length; i++) {\n                let s: string = m[i + 1];\n                if (s != null) {\n                    found = true;\n                    let col = m.index - (this.lineindex[this.lineno-1] || -1) - 1;\n                    let loc = { path: this.path, line: this.lineno, start: col, end: col + s.length };\n                    let rule = rules[i];\n                    // add token to list\n                    switch (rule.type) {\n                        case TokenType.CatchAll:\n                            if (this.errorOnCatchAll) {\n                                this.compileError(`I didn't expect the character \"${m[0]}\" here.`, loc);\n                            }\n                        default:\n                            this.pushToken({ str: s, type: rule.type, $loc: loc, eol: false });\n                            break;\n                        case TokenType.EOL:\n                            // set EOL for last token\n                            if (this.tokens.length)\n                                this.tokens[this.tokens.length-1].eol = true;\n                        case TokenType.Comment:\n                        case TokenType.Ignore:\n                            break;\n                    }\n                    break;\n                }\n            }\n            if (!found) {\n                this.compileError(`Could not parse token: <<${m[0]}>>`)\n            }\n        }\n    }\n    pushToken(token: Token) {\n        this.tokens.push(token);\n    }\n    addError(msg: string, loc?: SourceLocation) {\n        let tok = this.lasttoken || this.peekToken();\n        if (!loc) loc = tok.$loc;\n        this.errors.push({ path: loc.path, line: loc.line, label: this.curlabel, start: loc.start, end: loc.end, msg: msg });\n    }\n    internalError() {\n        return this.compileError(\"Internal error.\");\n    }\n    notImplementedError() {\n        return this.compileError(\"Not yet implemented.\");\n    }\n    compileError(msg: string, loc?: SourceLocation, loc2?: SourceLocation) : CompileError {\n        this.addError(msg, loc);\n        //if (loc2 != null) this.addError(`...`, loc2);\n        let e = new CompileError(msg, loc);\n        throw e;\n        return e;\n    }\n    peekToken(lookahead?: number): Token {\n        let tok = this.tokens[lookahead || 0];\n        return tok ? tok : this.eof;\n    }\n    consumeToken(): Token {\n        let tok = this.lasttoken = (this.tokens.shift() || this.eof);\n        return tok;\n    }\n    ifToken(match: string): Token | undefined {\n        if (this.peekToken().str == match) return this.consumeToken();\n    }\n    expectToken(str: string, msg?: string): Token {\n        let tok = this.consumeToken();\n        let tokstr = tok.str;\n        if (str != tokstr) {\n            this.compileError(msg || `There should be a \"${str}\" here.`);\n        }\n        return tok;\n    }\n    expectTokens(strlist: readonly string[], msg?: string): Token {\n        let tok = this.consumeToken();\n        let tokstr = tok.str;\n        if (!strlist.includes(tokstr)) {\n            this.compileError(msg || `These keywords are valid here: ${strlist.join(', ')}`);\n        }\n        return tok;\n    }\n    parseModifiers(modifiers: string[]): { [modifier: string]: boolean } {\n        let result = {};\n        do {\n            var tok = this.peekToken();\n            if (modifiers.indexOf(tok.str) < 0)\n                return result;\n            this.consumeToken();\n            result[tok.str] = true;\n        } while (tok != null);\n    }\n    expectIdent(msg?: string): Token {\n        let tok = this.consumeToken();\n        if (tok.type != TokenType.Ident)\n            this.compileError(msg || `There should be an identifier here.`);\n        return tok;\n    }\n    pushbackToken(tok: Token) {\n        this.tokens.unshift(tok);\n    }\n    isEOF() {\n        return this.tokens.length == 0 || this.peekToken().type == 'eof'; // TODO?\n    }\n    expectEOL(msg?: string) {\n        let tok = this.consumeToken();\n        if (tok.type != TokenType.EOL)\n            this.compileError(msg || `There's too much stuff on this line.`);\n    }\n    skipBlankLines() {\n        this.skipTokenTypes(['eol']);\n    }\n    skipTokenTypes(types: string[]) {\n        while (types.includes(this.peekToken().type))\n            this.consumeToken();\n    }\n    expectTokenTypes(types: string[], msg?: string) {\n        let tok = this.consumeToken();\n        if (!types.includes(tok.type))\n            this.compileError(msg || `There should be a ${types.map((s) => `\"${s}\"`).join(' or ')} here. not a \"${tok.type}\".`);\n        return tok;\n    }\n    parseList<T>(parseFunc:()=>T, delim:string): T[] {\n        var sep;\n        var list = [];\n        do {\n            var el = parseFunc.bind(this)(); // call parse function\n            if (el != null) list.push(el); // add parsed element to list\n            sep = this.consumeToken(); // consume seperator token\n        } while (sep.str == delim);\n        this.pushbackToken(sep);\n        return list;\n    }\n    runDeferred() {\n        while (this.deferred.length) {\n            this.deferred.shift()();\n        }\n    }\n}\n", "\nvar debug = false;\n\nexport interface BoxConstraints {\n    left?: number;\n    top?: number;\n    width: number;\n    height: number;\n    box?: PlacedBox;\n    label?: string;\n}\n\nenum BoxPlacement {\n    TopLeft=0, TopRight=1, BottomLeft=2, BottomRight=3\n}\n\nexport interface Box {\n    left: number;\n    top: number;\n    right: number;\n    bottom: number;\n}\n\nexport interface PlacedBox extends Box {\n    bin: Bin;\n    parents: Box[];\n    place: BoxPlacement;\n}\n\nfunction boxesIntersect(a: Box, b: Box) : boolean {\n    return !(b.left >= a.right || b.right <= a.left || b.top >= a.bottom || b.bottom <= a.top);\n}\n\nfunction boxesContain(a: Box, b: Box) : boolean {\n    return b.left >= a.left && b.top >= a.top && b.right <= a.right && b.bottom <= a.bottom;\n}\n\nexport class Bin {\n    boxes: Box[] = [];\n    free: Box[] = [];\n    extents: Box = {left:0,top:0,right:0,bottom:0};\n\n    constructor(public readonly binbounds: Box) {\n        this.free.push(binbounds);\n    }\n    getBoxes(bounds: Box, limit: number, boxes?: Box[]) : Box[] {\n        let result = [];\n        if (!boxes) boxes = this.boxes;\n        for (let box of boxes) {\n            //console.log(bounds, box, boxesIntersect(bounds, box))\n            if (boxesIntersect(bounds, box)) {\n                result.push(box);\n                if (result.length >= limit) break;\n            }\n        }\n        return result;\n    }\n    fits(b: Box) {\n        if (!boxesContain(this.binbounds, b)) {\n            if (debug) console.log('out of bounds!', b.left,b.top,b.right,b.bottom);\n            return false;\n        }\n        if (this.getBoxes(b, 1).length > 0) {\n            if (debug) console.log('intersect!', b.left,b.top,b.right,b.bottom);\n            return false;\n        }\n        return true;\n    }\n    bestFit(b: BoxConstraints) : Box | null {\n        let bestscore = 0;\n        let best = null;\n        for (let f of this.free) {\n            if (b.left != null && b.left < f.left) continue;\n            if (b.left != null && b.left + b.width > f.right) continue;\n            if (b.top != null && b.top < f.top) continue;\n            if (b.top != null && b.top + b.height > f.bottom) continue;\n            let dx = (f.right - f.left) - b.width;\n            let dy = (f.bottom - f.top) - b.height;\n            if (dx >= 0 && dy >= 0) {\n                let score = 1 / (1 + dx + dy + f.left * 0.001);\n                if (score > bestscore) {\n                    best = f;\n                    bestscore = score;\n                    if (score == 1) break;\n                }\n            }\n        }\n        return best;\n    }\n    anyFit(b: BoxConstraints) : Box | null {\n        let bestscore = 0;\n        let best = null;\n        for (let f of this.free) {\n            let box : Box = { \n                left: b.left != null ? b.left : f.left, \n                right: f.left + b.width,\n                top: b.top != null ? b.top : f.top,\n                bottom: f.top + b.height };\n            if (this.fits(box)) {\n                let score = 1 / (1 + box.left + box.top);\n                if (score > bestscore) {\n                    best = f;\n                    if (score == 1) break;\n                }\n            }\n        }\n        return best;\n    }\n    add(b: PlacedBox) {\n        if (debug) console.log('add', b.left,b.top,b.right,b.bottom);\n        if (!this.fits(b)) {\n            //console.log('collided with', this.getBoxes(b, 1));\n            throw new Error(`bad fit ${b.left} ${b.top} ${b.right} ${b.bottom}`)\n        }\n        // add box to list\n        this.boxes.push(b);\n        this.extents.right = Math.max(this.extents.right, b.right);\n        this.extents.bottom = Math.max(this.extents.bottom, b.bottom);\n        // delete bin\n        for (let p of b.parents) {\n            let i = this.free.indexOf(p);\n            if (i < 0) throw new Error('cannot find parent');\n            if (debug) console.log('removed',p.left,p.top,p.right,p.bottom);\n            this.free.splice(i, 1);\n            // split into new bins\n            // make long columns\n            this.addFree(p.left, p.top, b.left, p.bottom);\n            this.addFree(b.right, p.top, p.right, p.bottom);\n            // make top caps\n            this.addFree(b.left, p.top, b.right, b.top);\n            this.addFree(b.left, b.bottom, b.right, p.bottom);\n        }\n    }\n    addFree(left: number, top: number, right: number, bottom: number) {\n        if (bottom > top && right > left) {\n            let b = { left, top, right, bottom };\n            if (debug) console.log('free',b.left,b.top,b.right,b.bottom);\n            this.free.push(b);\n        }\n        // TODO: merge free boxes?\n    }\n}\n\nexport class Packer {\n    bins : Bin[] = [];\n    boxes : BoxConstraints[] = [];\n    defaultPlacement : BoxPlacement = BoxPlacement.TopLeft; //TODO\n\n    pack() : boolean {\n        for (let bc of this.boxes) {\n            let box = this.bestPlacement(bc);\n            if (!box) return false;\n            box.bin.add(box);\n            bc.box = box;\n        }\n        return true;\n    }\n    bestPlacement(b: BoxConstraints) : PlacedBox | null {\n        for (let bin of this.bins) {\n            let parent = bin.bestFit(b);\n            let approx = false;\n            if (!parent) {\n                parent = bin.anyFit(b);\n                approx = true;\n                if (debug) console.log('anyfit',parent?.left,parent?.top);\n            }\n            if (parent) {\n                let place = this.defaultPlacement;\n                let box = {\n                    left: parent.left,\n                    top: parent.top,\n                    right: parent.left + b.width,\n                    bottom: parent.top + b.height\n                };\n                if (b.left != null) {\n                    box.left = b.left;\n                    box.right = b.left + b.width;\n                }\n                if (b.top != null) {\n                    box.top = b.top;\n                    box.bottom = b.top + b.height;\n                }\n                if (place == BoxPlacement.BottomLeft || place == BoxPlacement.BottomRight) {\n                    let h = box.bottom - box.top;\n                    box.top = parent.bottom - h;\n                    box.bottom = parent.bottom;\n                }\n                if (place == BoxPlacement.TopRight || place == BoxPlacement.BottomRight) {\n                    let w = box.right - box.left;\n                    box.left = parent.right - w;\n                    box.right = parent.right;\n                }\n                if (debug) console.log('place',b.label,box.left,box.top,box.right,box.bottom,parent?.left,parent?.top);\n                let parents = [parent];\n                // if approx match, might overlap multiple free boxes\n                if (approx) parents = bin.getBoxes(box, 100, bin.free);\n                return { parents, place, bin, ...box };\n            }\n        }\n        if (debug) console.log('cannot place!',  b.left,b.top,b.width,b.height);\n        return null;\n    }\n    toSVG() {\n        let s = '';\n        let r = {width:100,height:70}\n        for (let bin of this.bins) {\n            r.width = Math.max(r.width, bin.binbounds.right);\n            r.height = Math.max(r.height, bin.binbounds.bottom);\n        }\n        s += `<svg viewBox=\"0 0 ${r.width} ${r.height}\" xmlns=\"http://www.w3.org/2000/svg\"><style><![CDATA[text {font: 1px sans-serif;}]]></style>`;\n        for (let bin of this.bins) {\n            let be = bin.extents;\n            s += '<g>'\n            s += `<rect width=\"${be.right-be.left}\" height=\"${be.bottom-be.top}\" stroke=\"black\" stroke-width=\"0.5\" fill=\"none\"/>`;\n            let textx = be.right+1;\n            let texty = 0;\n            for (let box of this.boxes) {\n                let b = box.box;\n                if (b) {\n                    if (b.bin == bin) s += `<rect width=\"${b.right-b.left}\" height=\"${b.bottom-b.top}\" x=\"${b.left}\" y=\"${b.top}\" stroke=\"black\" stroke-width=\"0.25\" fill=\"#ccc\"/>`;\n                    if (b.top == texty) textx += 10; else textx = be.right+1;\n                    texty = b.top;\n                    if (box.label) s += `<text x=\"${textx}\" y=\"${texty}\" height=\"1\">${box.label}</text>`;\n                }\n            }\n            /*\n            for (let b of bin.free) {\n                s += `<rect width=\"${b.right-b.left}\" height=\"${b.bottom-b.top}\" x=\"${b.left}\" y=\"${b.top}\" stroke=\"red\" stroke-width=\"0.1\" fill=\"none\"/>`;\n            }\n            */\n            s += '</g>'\n        }\n        s += `</svg>`;\n        return s;\n    }\n    toSVGUrl() {\n        return `data:image/svg+xml;base64,${btoa(this.toSVG())}`;\n    }\n}\n", "\nimport { Token } from \"../tokenizer\";\nimport { SourceLocated, SourceLocation } from \"../workertypes\";\nimport { Bin, Packer } from \"./binpack\";\n\nexport class ECSError extends Error implements SourceLocated {\n    $loc: SourceLocation;\n    $sources: SourceLocated[] = [];\n\n    constructor(msg: string, obj?: SourceLocation | SourceLocated) {\n        super(msg);\n        Object.setPrototypeOf(this, ECSError.prototype);\n        if (obj) this.$loc = (obj as SourceLocated).$loc || (obj as SourceLocation);\n    }\n}\n\nfunction mksymbol(c: ComponentType, fieldName: string) {\n    return c.name + '_' + fieldName;\n}\nfunction mkscopesymbol(s: EntityScope, c: ComponentType, fieldName: string) {\n    return s.name + '_' + c.name + '_' + fieldName;\n}\n\nexport interface Entity extends SourceLocated {\n    id: number;\n    name?: string;\n    etype: EntityArchetype;\n    consts: { [component_field: string]: DataValue };\n    // TODO: need scope scoping?\n    inits: { [scope_component_field: string]: DataValue };\n}\n\nexport interface EntityConst {\n    component: ComponentType;\n    name: string;\n    value: DataValue;\n}\n\nexport interface EntityArchetype {\n    components: ComponentType[];\n}\n\nexport interface ComponentType extends SourceLocated {\n    name: string;\n    fields: DataField[];\n    optional?: boolean;\n}\n\nexport interface Query extends SourceLocated {\n    include: ComponentType[];\n    exclude?: ComponentType[];\n    entities?: Entity[];\n    limit?: number;\n}\n\nexport class SystemStats {\n    tempstartseq: number | undefined;\n    tempendseq: number | undefined;\n}\n\nexport interface System extends SourceLocated {\n    name: string;\n    actions: Action[];\n    tempbytes?: number;\n}\n\nexport interface SystemInstanceParameters {\n    query?: Query;\n    refEntity?: Entity;\n    refField?: ComponentFieldPair;\n}\n\nexport interface SystemInstance extends SourceLocated {\n    system: System;\n    params: SystemInstanceParameters;\n    id: number;\n}\n\nexport const SELECT_TYPE = ['once', 'foreach', 'join', 'with', 'if', 'select', 'unroll'] as const;\n\nexport type SelectType = typeof SELECT_TYPE[number];\n\n// TODO?\nexport interface ActionContext {\n    system: System\n    scope: EntityScope | null\n}\n\nexport class ActionNode implements SourceLocated {\n    constructor(\n        public readonly owner: ActionContext,\n        public readonly $loc: SourceLocation\n    ) { }\n\n    children?: ActionNode[];\n}\n\nexport class CodeLiteralNode extends ActionNode {\n    constructor(\n        owner: ActionContext,\n        $loc: SourceLocation,\n        public readonly text: string\n    ) {\n        super(owner, $loc);\n    }\n}\n\nexport class CodePlaceholderNode extends ActionNode {\n    constructor(\n        owner: ActionContext,\n        $loc: SourceLocation,\n        public readonly args: string[]\n    ) {\n        super(owner, $loc);\n    }\n}\n\nexport interface Action extends SourceLocated {\n    event: string;\n    expr: Statement;\n    critical?: boolean;\n    fitbytes?: number;\n}\n\nexport type DataValue = number | boolean | Uint8Array | Uint16Array | Uint32Array;\n\nexport type DataField = { name: string; $loc: SourceLocation } & DataType;\n\nexport type DataType = IntType | ArrayType | RefType;\n\nexport interface IntType {\n    dtype: 'int'\n    lo: number\n    hi: number\n    defvalue?: number\n    enums?: { [name: string] : number }\n}\n\nexport interface ArrayType {\n    dtype: 'array'\n    elem: DataType\n    index?: DataType\n    baseoffset?: number\n}\n\nexport interface RefType {\n    dtype: 'ref'\n    query: Query\n}\n\ninterface FieldArray {\n    component: ComponentType;\n    field: DataField;\n    elo: number;\n    ehi: number;\n    access?: FieldAccess[];\n}\n\ninterface FieldAccess {\n    symbol: string;\n    bit: number;\n    width: number;\n}\n\ninterface ConstByte {\n    symbol: string;\n    bitofs: number;\n}\n\nexport interface ComponentFieldPair {\n    c: ComponentType;\n    f: DataField;\n}\n\n// Expressions\n\nexport interface ForwardRef extends SourceLocated {\n    reftype: RefType | undefined\n    token: Token\n}\n\nexport type LExpr = IndOp | EntityFieldOp;\nexport type Statement = InlineCode | BlockExpr | QueryExpr;\nexport type Expr = BinOp | UnOp | Literal | ForwardRef | LExpr | Statement;\nexport type Opcode = string;\n\nexport interface ExprBase extends SourceLocated {\n    valtype: DataType;\n}\n\nexport interface Literal extends ExprBase {\n    value: DataValue;\n}\n\nexport interface LiteralInt extends Literal {\n    value: number;\n    valtype: IntType;\n}\n\nexport interface BinOp extends ExprBase {\n    op: Opcode;\n    left: Expr;\n    right: Expr;\n}\n\nexport interface UnOp extends ExprBase {\n    op: 'neg' | 'lnot' | 'bnot';\n    expr: Expr;\n}\n\nexport interface IndOp extends ExprBase {\n    name: string;\n    args: Expr[];\n}\n\nexport interface CondOp extends ExprBase {\n    cond: Expr;\n    iftrue?: Expr;\n    iffalse?: Expr;\n}\n\nexport interface BranchOp extends ExprBase {\n    branch: BlockExpr;\n}\n\nexport interface EntityFieldOp extends ExprBase {\n    entities: Entity[];\n    field: DataField;\n}\n\nexport interface EntityContextOp extends ExprBase {\n    entities: Entity[];\n}\n\nexport interface InlineCode extends ExprBase {\n    code: string;\n}\n\nexport interface BlockExpr extends ExprBase {\n    loop?: boolean;\n    stmts: Expr[];\n}\n\nexport interface QueryExpr extends BlockExpr {\n    select: SelectType\n    query: Query\n    direction?: 'asc' | 'desc'\n    join?: Query\n    all?: boolean\n}\n\n\nexport function isLiteral(arg: Expr): arg is Literal {\n    return (arg as any).value != null;\n}\nexport function isLiteralInt(arg: Expr): arg is LiteralInt {\n    return isLiteral(arg) && arg.valtype.dtype == 'int';\n}\nexport function isLookup(arg: Expr): arg is IndOp {\n    return (arg as any).name != null;\n}\nexport function isBinOp(arg: Expr): arg is BinOp {\n    return (arg as any).op != null && (arg as any).left != null && (arg as any).right != null;\n}\nexport function isUnOp(arg: Expr): arg is UnOp {\n    return (arg as any).op != null && (arg as any).expr != null;\n}\nexport function isBlockStmt(arg: Expr): arg is BlockExpr {\n    return (arg as any).stmts != null;\n}\nexport function isInlineCode(arg: Expr): arg is InlineCode {\n    return (arg as any).code != null;\n}\nexport function isQueryExpr(arg: Expr): arg is QueryExpr {\n    return (arg as any).query != null;\n}\n\n\n/// DIALECT\n\nexport class Dialect_CA65 {\n\n    ASM_ITERATE_EACH_ASC = `\n    ldx #0\n@__each:\n    {{%code}}\n    inx\n    cpx #{{%ecount}}\n    jne @__each\n@__exit:\n`;\n\n    ASM_ITERATE_EACH_DESC = `\n    ldx #{{%ecount}}-1\n@__each:\n    {{%code}}\n    dex\n    jpl @__each\n@__exit:\n`;\n\n    ASM_ITERATE_JOIN_ASC = `\n    ldy #0\n@__each:\n    ldx {{%joinfield}},y\n    {{%code}}\n    iny\n    cpy #{{%ecount}}\n    jne @__each\n@__exit:\n`;\n\n    ASM_ITERATE_JOIN_DESC = `\n    ldy #{{%ecount}}-1\n@__each:\n    ldx {{%joinfield}},y\n    {{%code}}\n    dey\n    jpl @__each\n@__exit:\n`;\n\n    ASM_FILTER_RANGE_LO_X = `\n    cpx #{{%xofs}}\n    jcc @__skipxlo\n    {{%code}}\n@__skipxlo:\n`\n\n    ASM_FILTER_RANGE_HI_X = `\n    cpx #{{%xofs}}+{{%ecount}}\n    jcs @__skipxhi\n    {{%code}}\n@__skipxhi:\n`\n\n    ASM_LOOKUP_REF_X = `\n    ldx {{%reffield}}\n    {{%code}}\n`\n\n    INIT_FROM_ARRAY = `\n    ldy #{{%nbytes}}\n:   lda {{%src}}-1,y\n    sta {{%dest}}-1,y\n    dey\n    bne :-\n`\n\n    comment(s: string) {\n        return `\\n;;; ${s}\\n`;\n    }\n    absolute(ident: string, offset?: number) {\n        return this.addOffset(ident, offset || 0);\n    }\n    addOffset(ident: string, offset: number) {\n        if (offset > 0) return `${ident}+${offset}`;\n        if (offset < 0) return `${ident}-${-offset}`;\n        return ident;\n    }\n    indexed_x(ident: string, offset: number) {\n        return this.addOffset(ident, offset) + ',x';\n    }\n    indexed_y(ident: string, offset: number) {\n        return this.addOffset(ident, offset) + ',y';\n    }\n    fieldsymbol(component: ComponentType, field: DataField, bitofs: number) {\n        return `${component.name}_${field.name}_b${bitofs}`;\n    }\n    datasymbol(component: ComponentType, field: DataField, eid: number, bitofs: number) {\n        return `${component.name}_${field.name}_e${eid}_b${bitofs}`;\n    }\n    debug_file(path: string) {\n        return `.dbg file, \"${path}\", 0, 0`\n    }\n    debug_line(path: string, line: number) {\n        return `.dbg line, \"${path}\", ${line}`\n    }\n    startScope(name: string) {\n        return `.scope ${name}`\n    }\n    endScope(name: string) {\n        return `.endscope\\n${this.scopeSymbol(name)} = ${name}::__Start`\n    }\n    scopeSymbol(name: string) {\n        return `${name}__Start`;\n    }\n    align(value: number) {\n        return `.align ${value}`;\n    }\n    alignSegmentStart() {\n        return this.label('__ALIGNORIGIN');\n    }\n    warningIfPageCrossed(startlabel: string) {\n        return `\n.assert >(${startlabel}) = >(*), error, \"${startlabel} crosses a page boundary!\"`\n    }\n    warningIfMoreThan(bytes: number, startlabel: string) {\n        return `\n.assert (* - ${startlabel}) <= ${bytes}, error, .sprintf(\"${startlabel} does not fit in ${bytes} bytes, it took %d!\", (* - ${startlabel}))`\n    }\n    alignIfLessThan(bytes: number) {\n        return `\n.if <(* - __ALIGNORIGIN) > 256-${bytes}\n.align $100\n.endif`\n    }\n    segment(segtype: 'rodata' | 'bss' | 'code') {\n        if (segtype == 'bss') {\n            return `.zeropage`;\n        } else if (segtype == 'rodata') {\n            return '.rodata';\n        } else {\n            return `.code`;\n        }\n    }\n    label(sym: string) {\n        return `${sym}:`;\n    }\n    byte(b: number | ConstByte | undefined) {\n        if (b === undefined) {\n            return `.res 1`\n        } else if (typeof b === 'number') {\n            if (b < 0 || b > 255) throw new ECSError(`out of range byte ${b}`);\n            return `.byte ${b}`\n        } else {\n            if (b.bitofs == 0) return `.byte <${b.symbol}`\n            else if (b.bitofs == 8) return `.byte >${b.symbol}`\n            else return `.byte ((${b.symbol} >> ${b.bitofs})&255)`\n        }\n    }\n    tempLabel(inst: SystemInstance) {\n        return `${inst.system.name}__${inst.id}__tmp`;\n    }\n    equate(symbol: string, value: string): string {\n        return `${symbol} = ${value}`;\n    }\n    define(symbol: string, value?: string): string {\n        if (value) return `.define ${symbol} ${value}`;\n        else return `.define ${symbol}`;\n    }\n    call(symbol: string) {\n        return ` jsr ${symbol}`;\n    }\n    jump(symbol: string) {\n        return ` jmp ${symbol}`;\n    }\n    return() {\n        return ' rts';\n    }\n}\n\n// TODO: merge with Dialect?\nexport class SourceFileExport {\n    lines: string[] = [];\n\n    line(s: string) {\n        this.text(s);\n    }\n    text(s: string) {\n        for (let l of s.split('\\n'))\n            this.lines.push(l);\n    }\n    toString() {\n        return this.lines.join('\\n');\n    }\n}\n\nclass CodeSegment {\n    codefrags: string[] = [];\n\n    addCodeFragment(code: string) {\n        this.codefrags.push(code);\n    }\n    dump(file: SourceFileExport) {\n        for (let code of this.codefrags) {\n            file.text(code);\n        }\n    }\n}\n\nclass DataSegment {\n    symbols: { [sym: string]: number } = {};\n    equates: { [sym: string]: string } = {};\n    ofs2sym = new Map<number, string[]>();\n    fieldranges: { [cfname: string]: FieldArray } = {};\n    size: number = 0;\n    initdata: (number | ConstByte | undefined)[] = [];\n\n    allocateBytes(name: string, bytes: number) {\n        let ofs = this.symbols[name];\n        if (ofs == null) {\n            ofs = this.size;\n            this.declareSymbol(name, ofs);\n            this.size += bytes;\n        }\n        return ofs;\n    }\n    declareSymbol(name: string, ofs: number) {\n        this.symbols[name] = ofs;\n        if (!this.ofs2sym.has(ofs))\n            this.ofs2sym.set(ofs, []);\n        this.ofs2sym.get(ofs)?.push(name);\n    }\n    // TODO: ordering should not matter, but it does\n    findExistingInitData(bytes: Uint8Array) {\n        for (let i=0; i<this.size - bytes.length; i++) {\n            for (var j=0; j<bytes.length; j++) {\n                if (this.initdata[i+j] !== bytes[j]) break;\n            }\n            if (j == bytes.length) return i;\n        }\n        return -1;\n    }\n    allocateInitData(name: string, bytes: Uint8Array) {\n        let ofs = this.findExistingInitData(bytes);\n        if (ofs >= 0) {\n            this.declareSymbol(name, ofs);\n        } else {\n            ofs = this.allocateBytes(name, bytes.length);\n            for (let i = 0; i < bytes.length; i++) {\n                this.initdata[ofs + i] = bytes[i];\n            }\n        }\n    }\n    dump(file: SourceFileExport, dialect: Dialect_CA65) {\n        // TODO: fewer lines\n        for (let i = 0; i < this.size; i++) {\n            let syms = this.ofs2sym.get(i);\n            if (syms) {\n                for (let sym of syms)\n                    file.line(dialect.label(sym));\n            }\n            file.line(dialect.byte(this.initdata[i]));\n        }\n        for (let [symbol,value] of Object.entries(this.equates)) {\n            file.line(dialect.equate(symbol, value));\n        }\n    }\n    // TODO: move cfname functions in here too\n    getFieldRange(component: ComponentType, fieldName: string) {\n        return this.fieldranges[mksymbol(component, fieldName)];\n    }\n    getByteOffset(range: FieldArray, access: FieldAccess, entityID: number) {\n        if (entityID < range.elo) throw new ECSError(`entity ID ${entityID} too low for ${access.symbol}`);\n        if (entityID > range.ehi) throw new ECSError(`entity ID ${entityID} too high for ${access.symbol}`);\n        let ofs = this.symbols[access.symbol];\n        if (ofs !== undefined) {\n            return ofs + entityID - range.elo;\n        }\n        throw new ECSError(`cannot find field access for ${access.symbol}`);\n    }\n    getOriginSymbol() {\n        let a = this.ofs2sym.get(0);\n        if (!a) throw new ECSError('getOriginSymbol(): no symbol at offset 0'); // TODO\n        return a[0];\n    }\n}\n\nclass UninitDataSegment extends DataSegment {\n}\n\nclass ConstDataSegment extends DataSegment {\n}\n\n// TODO: none of this makes sense\nfunction getFieldBits(f: IntType) {\n    //let n = Math.abs(f.lo) + f.hi + 1;\n    let n = f.hi - f.lo + 1;\n    return Math.ceil(Math.log2(n));\n}\n\nfunction getFieldLength(f: DataType) {\n    if (f.dtype == 'int') {\n        return f.hi - f.lo + 1;\n    } else {\n        return 1; //TODO?\n    }\n}\n\nfunction getPackedFieldSize(f: DataType, constValue?: DataValue): number {\n    if (f.dtype == 'int') {\n        return getFieldBits(f);\n    } if (f.dtype == 'array' && f.index) {\n        return 0; // TODO? getFieldLength(f.index) * getPackedFieldSize(f.elem);\n    } if (f.dtype == 'array' && constValue != null && Array.isArray(constValue)) {\n        return constValue.length * getPackedFieldSize(f.elem);\n    } if (f.dtype == 'ref') {\n        return 8; // TODO: > 256 entities?\n    }\n    return 0;\n}\n\nclass EntitySet {\n    atypes: EntityArchetype[];\n    entities: Entity[];\n    scope;\n\n    constructor(scope: EntityScope, query?: Query, e?: Entity[]) {\n        this.scope = scope;\n        if (query) {\n            if (query.entities) {\n                this.entities = query.entities.slice(0);\n            } else {\n                this.atypes = scope.em.archetypesMatching(query);\n                this.entities = scope.entitiesMatching(this.atypes);\n            }\n            // TODO: desc?\n            if (query.limit) {\n                this.entities = this.entities.slice(0, query.limit);\n            }\n        } else if (e) {\n            this.entities = e;\n        } else {\n            throw new ECSError('invalid EntitySet constructor')\n        }\n        if (!this.atypes) {\n            let at = new Set<EntityArchetype>();\n            for (let e of this.entities) at.add(e.etype);\n            this.atypes = Array.from(at.values());\n        }\n    }\n    contains(c: ComponentType, f: DataField, where: SourceLocated) {\n        // TODO: action for error msg\n        return this.scope.em.singleComponentWithFieldName(this.atypes, f.name, where);\n    }\n    intersection(qr: EntitySet) {\n        let ents = this.entities.filter(e => qr.entities.includes(e));\n        return new EntitySet(this.scope, undefined, ents);\n    }\n    union(qr: EntitySet) {\n        // TODO: remove dups\n        let ents = this.entities.concat(qr.entities);\n        let atypes = this.atypes.concat(qr.atypes);\n        return new EntitySet(this.scope, undefined, ents);\n    }\n    isContiguous() {\n        if (this.entities.length == 0) return true;\n        let id = this.entities[0].id;\n        for (let i = 1; i < this.entities.length; i++) {\n            if (this.entities[i].id != ++id) return false;\n        }\n        return true;\n    }\n}\n\nclass IndexRegister {\n    lo: number | null;\n    hi: number | null;\n    elo: number;\n    ehi: number;\n    eset: EntitySet | undefined;\n\n    constructor(\n        public readonly scope: EntityScope,\n        eset?: EntitySet\n    ) {\n        this.elo = 0;\n        this.ehi = scope.entities.length - 1;\n        this.lo = null;\n        this.hi = null;\n        if (eset) { this.narrowInPlace(eset); }\n    }\n    entityCount() {\n        return this.ehi - this.elo + 1;\n    }\n    clone() {\n        return Object.assign(new IndexRegister(this.scope), this);\n    }\n    narrow(eset: EntitySet, action?: SourceLocated) {\n        let i = this.clone();\n        return i.narrowInPlace(eset, action) ? i : null;\n    }\n    narrowInPlace(eset: EntitySet, action?: SourceLocated): boolean {\n        if (this.scope != eset.scope) throw new ECSError(`scope mismatch`, action);\n        if (!eset.isContiguous()) throw new ECSError(`entities are not contiguous`, action);\n        if (this.eset) {\n            this.eset = this.eset.intersection(eset);\n        } else {\n            this.eset = eset;\n        }\n        if (this.eset.entities.length == 0) {\n            return false;\n        }\n        let newelo = this.eset.entities[0].id;\n        let newehi = this.eset.entities[this.eset.entities.length - 1].id;\n        if (this.lo === null || this.hi === null) {\n            this.lo = 0;\n            this.hi = newehi - newelo;\n            this.elo = newelo;\n            this.ehi = newehi;\n        } else {\n            //if (action) console.log((action as any).event, this.elo, '-', this.ehi, '->', newelo, '..', newehi);\n            this.lo += newelo - this.elo;\n            this.hi += newehi - this.ehi;\n        }\n        return true;\n    }\n    // TODO: removegi\n    offset() {\n        return this.lo || 0;\n    }\n}\n\n// todo: generalize\nclass ActionCPUState {\n    working: EntitySet;\n    props: {[key: string] : string};\n    xreg: IndexRegister | null = null;\n    yreg: IndexRegister | null = null;\n}\n\nclass ActionEval {\n    em : EntityManager;\n    dialect : Dialect_CA65;\n    tmplabel = '';\n    label : string;\n    seq : number;\n    //used = new Set<string>(); // TODO\n\n    constructor(\n        readonly scope: EntityScope,\n        readonly instance: SystemInstance,\n        readonly action: Action,\n        readonly eventargs: string[])\n    {\n        this.em = scope.em;\n        this.dialect = scope.em.dialect;\n        this.tmplabel = this.dialect.tempLabel(this.instance);\n        //let query = (this.action as ActionWithQuery).query;\n        //TODO? if (query && this.entities.length == 0)\n            //throw new ECSError(`query doesn't match any entities`, query); // TODO \n        this.seq = this.em.seq++;\n        this.label = `${this.instance.system.name}__${action.event}__${this.seq}`;\n    }\n    begin() {\n    }\n    end() {\n    }\n    codeToString(): string {\n        let code = this.exprToCode(this.action.expr);\n        return code;\n    }\n    private replaceTags(code: string, action: Action, props: { [name: string]: string; }) {\n        const tag_re = /\\{\\{(.+?)\\}\\}/g;\n        code = code.replace(tag_re, (entire, group: string) => {\n            let toks = group.split(/\\s+/);\n            if (toks.length == 0)\n                throw new ECSError(`empty command`, action);\n            let cmd = group.charAt(0);\n            let arg0 = toks[0].substring(1).trim();\n            let args = [arg0].concat(toks.slice(1));\n            switch (cmd) {\n                case '!': return this.__emit(args);\n                case '$': return this.__local(args);\n                case '^': return this.__use(args);\n                case '#': return this.__arg(args);\n                case '&': return this.__eid(args);\n                case '<': return this.__get([arg0, '0']);\n                case '>': return this.__get([arg0, '8']);\n                default:\n                    let value = props[toks[0]];\n                    if (value)\n                        return value;\n                    let fn = (this as any)['__' + toks[0]];\n                    if (fn)\n                        return fn.bind(this)(toks.slice(1));\n                    throw new ECSError(`unrecognized command {{${toks[0]}}}`, action);\n            }\n        });\n        return code;\n    }\n    private replaceLabels(code: string) {\n        const label_re = /@(\\w+)\\b/g;\n        let seq = this.em.seq++;\n        let label = `${this.instance.system.name}__${this.action.event}__${seq}`;\n        code = code.replace(label_re, (s: string, a: string) => `${label}__${a}`);\n        return code;\n    }\n\n    __get(args: string[]) {\n        return this.getset(args, false);\n    }\n    __set(args: string[]) {\n        return this.getset(args, true);\n    }\n    getset(args: string[], canwrite: boolean) {\n        let fieldName = args[0];\n        let bitofs = parseInt(args[1] || '0');\n        return this.generateCodeForField(fieldName, bitofs, canwrite);\n    }\n    parseFieldArgs(args: string[]) {\n        let fieldName = args[0];\n        let bitofs = parseInt(args[1] || '0');\n        let component = this.em.singleComponentWithFieldName(this.scope.state.working.atypes, fieldName, this.action);\n        let field = component.fields.find(f => f.name == fieldName);\n        if (field == null) throw new ECSError(`no field named \"${fieldName}\" in component`, this.action);\n        return { component, field, bitofs };\n    }\n    __base(args: string[]) {\n        let { component, field, bitofs } = this.parseFieldArgs(args);\n        return this.dialect.fieldsymbol(component, field, bitofs);\n    }\n    __data(args: string[]) {\n        let { component, field, bitofs } = this.parseFieldArgs(args);\n        let entities = this.scope.state.working.entities;\n        if (entities.length != 1) throw new ECSError(`data operates on exactly one entity`, this.action); // TODO?\n        let eid = entities[0].id; // TODO?\n        return this.dialect.datasymbol(component, field, eid, bitofs);\n    }\n    __const(args: string[]) {\n        let { component, field, bitofs } = this.parseFieldArgs(args);\n        let entities = this.scope.state.working.entities;\n        if (entities.length != 1) throw new ECSError(`const operates on exactly one entity`, this.action); // TODO?\n        let constVal = entities[0].consts[mksymbol(component, field.name)];\n        if (constVal === undefined)  throw new ECSError(`field is not constant`, this.action); // TODO?\n        if (typeof constVal !== 'number')  throw new ECSError(`field is not numeric`, this.action); // TODO?\n        return constVal << bitofs;\n    }\n    __index(args: string[]) {\n        // TODO: check select type and if we actually have an index...\n        let ident = args[0];\n        let index = parseInt(args[1] || '0');\n        let entities = this.scope.state.working.entities;\n        if (entities.length == 1) {\n            return this.dialect.absolute(ident);\n        } else {\n            return this.dialect.indexed_x(ident, index); //TODO?\n        }\n    }\n    __eid(args: string[]) {\n        let e = this.scope.getEntityByName(args[0] || '?');\n        if (!e) throw new ECSError(`can't find entity named \"${args[0]}\"`, this.action);\n        return e.id.toString();\n    }\n    __use(args: string[]) {\n        return this.scope.includeResource(args[0]);\n    }\n    __emit(args: string[]) {\n        let event = args[0];\n        let eventargs = args.slice(1);\n        try {\n            return this.scope.generateCodeForEvent(event, eventargs);\n        } catch (e) {\n            if (e.$sources) e.$sources.push(this.action);\n            throw e;\n        }\n    }\n    __local(args: string[]) {\n        let tempinc = parseInt(args[0]);\n        let tempbytes = this.instance.system.tempbytes;\n        if (isNaN(tempinc)) throw new ECSError(`bad temporary offset`, this.action);\n        if (!tempbytes) throw new ECSError(`this system has no locals`, this.action);\n        if (tempinc < 0 || tempinc >= tempbytes) throw new ECSError(`this system only has ${tempbytes} locals`, this.action);\n        this.scope.updateTempLiveness(this.instance);\n        return `${this.tmplabel}+${tempinc}`;\n    }\n    __arg(args: string[]) {\n        let argindex = parseInt(args[0] || '0');\n        let argvalue = this.eventargs[argindex] || '';\n        //this.used.add(`arg_${argindex}_${argvalue}`);\n        return argvalue;\n    }\n    __start(args: string[]) {\n        let startSymbol = this.dialect.scopeSymbol(args[0]);\n        return this.dialect.jump(startSymbol);\n    }\n    generateCodeForField(fieldName: string, bitofs: number, canWrite: boolean): string {\n        const action = this.action;\n        const qr = this.scope.state.working;\n\n        var component: ComponentType;\n        var baseLookup = false;\n        var entityLookup = false;\n        let entities: Entity[];\n        // is qualified field?\n        if (fieldName.indexOf('.') > 0) {\n            let [entname, fname] = fieldName.split('.');\n            let ent = this.scope.getEntityByName(entname);\n            if (ent == null) throw new ECSError(`no entity named \"${entname}\" in this scope`, action);\n            component = this.em.singleComponentWithFieldName([ent.etype], fname, action);\n            fieldName = fname;\n            entities = [ent];\n            entityLookup = true;\n        } else if (fieldName.indexOf(':') > 0) {\n            let [cname, fname] = fieldName.split(':');\n            component = this.em.getComponentByName(cname);\n            if (component == null) throw new ECSError(`no component named \"${cname}\"`, action)\n            entities = this.scope.state.working.entities;\n            fieldName = fname;\n            baseLookup = true;\n        } else {\n            component = this.em.singleComponentWithFieldName(qr.atypes, fieldName, action);\n            entities = this.scope.state.working.entities;\n        }\n        // find archetypes\n        let field = component.fields.find(f => f.name == fieldName);\n        if (field == null) throw new ECSError(`no field named \"${fieldName}\" in component`, action);\n        let ident = this.dialect.fieldsymbol(component, field, bitofs);\n        // see if all entities have the same constant value\n        // TODO: should be done somewhere else?\n        let constValues = new Set<DataValue>();\n        let isConst = false;\n        for (let e of entities) {\n            let constVal = e.consts[mksymbol(component, fieldName)];\n            if (constVal !== undefined) isConst = true;\n            constValues.add(constVal); // constVal === undefined is allowed\n        }\n        // can't write to constant\n        if (isConst && canWrite)\n            throw new ECSError(`can't write to constant field ${fieldName}`, action);\n        // is it a constant?\n        if (constValues.size == 1) {\n            let value = constValues.values().next().value as DataValue;\n            // TODO: what about symbols?\n            // TODO: use dialect\n            if (typeof value === 'number') {\n                return `#${(value >> bitofs) & 0xff}`;\n            }\n        }\n        // TODO: offset > 0?\n        // TODO: don't mix const and init data\n        let range = this.scope.getFieldRange(component, field.name);\n        if (!range) throw new ECSError(`couldn't find field for ${component.name}:${fieldName}, maybe no entities?`); // TODO\n        // TODO: dialect\n        // TODO: doesnt work for entity.field\n        // TODO: array field baseoffset?\n        if (baseLookup) {\n            return this.dialect.absolute(ident);\n        } else if (entities.length == 1) {\n            // TODO: qr or this.entites?\n            let eidofs = entities[0].id - range.elo; // TODO: negative?\n            return this.dialect.absolute(ident, eidofs);\n        } else {\n            let ir;\n            let int;\n            let eidofs;\n            let xreg = this.scope.state.xreg;\n            let yreg = this.scope.state.yreg;\n            if (xreg && (int = xreg.eset?.intersection(qr))) {\n                //console.log(eidofs,'x',qr.entities[0].id,xreg.elo,int.entities[0].id,xreg.offset(),range.elo);\n                ir = xreg.eset;\n                //eidofs -= xreg.offset();\n                //eidofs -= int.entities[0].id - xreg.elo;\n                eidofs = xreg.elo - range.elo;\n                // TODO? if (xreg.ehi > range.ehi) throw new ECSError(`field \"${field.name}\" could overflow`, action);\n            } else if (yreg && (int = yreg.eset?.intersection(qr))) {\n                ir = yreg.eset;\n                //eidofs -= yreg.offset();\n                eidofs = yreg.elo - range.elo;\n            } else {\n                ir = null;\n                eidofs = 0;\n            }\n            if (!ir) {\n                throw new ECSError(`no intersection for index register`, action);\n            }\n            if (ir.entities.length == 0) throw new ECSError(`no common entities for index register`, action);\n            if (!ir.isContiguous()) throw new ECSError(`entities in query are not contiguous`, action);\n            if (ir == this.scope.state.xreg?.eset)\n                return this.dialect.indexed_x(ident, eidofs);\n            if (ir == this.scope.state.yreg?.eset)\n                return this.dialect.indexed_y(ident, eidofs);\n            throw new ECSError(`cannot find \"${component.name}:${field.name}\" in state`, action);\n        }\n    }\n    getJoinField(action: Action, atypes: EntityArchetype[], jtypes: EntityArchetype[]): ComponentFieldPair {\n        let refs = Array.from(this.scope.iterateArchetypeFields(atypes, (c, f) => f.dtype == 'ref'));\n        // TODO: better error message\n        if (refs.length == 0) throw new ECSError(`cannot find join fields`, action);\n        if (refs.length > 1) throw new ECSError(`cannot join multiple fields (${refs.map(r => r.f.name).join(' ')})`, action);\n        // TODO: check to make sure join works\n        return refs[0]; // TODO\n        /* TODO\n        let match = refs.map(ref => this.em.archetypesMatching((ref.f as RefType).query));\n        for (let ref of refs) {\n            let m = this.em.archetypesMatching((ref.f as RefType).query);\n            for (let a of m) {\n                if (jtypes.includes(a.etype)) {\n                    console.log(a,m);\n                }\n            }\n        }\n        */\n    }\n    isSubroutineSized(code: string) {\n        // TODO?\n        if (code.length > 20000) return false;\n        if (code.split('\\n ').length >= 4) return true; // TODO: :^/\n        return false;\n    }\n    exprToCode(expr: Expr) : string {\n        if (isQueryExpr(expr)) {\n            return this.queryExprToCode(expr);\n        }\n        if (isBlockStmt(expr)) {\n            return this.blockStmtToCode(expr);\n        }\n        if (isInlineCode(expr)) {\n            return this.evalInlineCode(expr.code);\n        }\n        throw new ECSError(`cannot convert expression to code`, expr);\n    }\n    evalInlineCode(code: string) {\n        let props = this.scope.state.props || {};\n        // replace @labels\n        code = this.replaceLabels(code);\n        // replace {{...}} tags\n        // TODO: use nodes instead\n        code = this.replaceTags(code, this.action, props);\n        return code;\n    }\n    blockStmtToCode(expr: BlockExpr) {\n        return expr.stmts.map(node => this.exprToCode(node)).join('\\n');\n    }\n    queryExprToCode(qexpr: QueryExpr) : string {\n        //console.log('query', this.action.event, qexpr.select, qexpr.query.include);\n        let q = this.startQuery(qexpr);\n        // TODO: move elsewhere? is \"foreach\" and \"join\" part of the empty set?\n        const allowEmpty = ['if','foreach','join'];\n        if (q.working.entities.length == 0 && allowEmpty.includes(qexpr.select)) {\n            //console.log('empty', this.action.event);\n            this.endQuery(q);\n            return '';\n        } else {\n            this.scope.state.working = q.working;\n            this.scope.state.props = q.props;\n            //console.log('begin', this.action.event, this.scope.state);\n            q.code = this.evalInlineCode(q.code);\n            let body = this.blockStmtToCode(qexpr);\n            this.endQuery(q);\n            //console.log('end', this.action.event, this.scope.state);\n            body = q.code.replace('%%CODE%%', body);\n            return body;\n        }\n    }\n    queryWorkingSet(qexpr: QueryExpr) {\n        const scope = this.scope;\n        const instance = this.instance;\n        let select = qexpr.select;\n        let q = qexpr.query;\n        let qr = new EntitySet(scope, q);\n        // narrow query w/ working set?\n        if (!(qexpr.all || q.entities)) {\n            let ir = qr.intersection(scope.state.working);\n            // if intersection is empty, take the global set\n            // if doing otherwise would generate an error (execpt for \"if\")\n            // TODO: ambiguous?\n            if (ir.entities.length || select == 'if') {\n                qr = ir;\n            }\n        }\n        // TODO? error if none?\n        if (instance.params.refEntity && instance.params.refField) {\n            let rf = instance.params.refField;\n            if (rf.f.dtype == 'ref') {\n                let rq = rf.f.query;\n                qr = qr.intersection(new EntitySet(scope, rq));\n                //console.log('with', instance.params, rq, this.qr);\n            }\n        } else if (instance.params.query) {\n            qr = qr.intersection(new EntitySet(scope, instance.params.query));\n        }\n        return qr;\n    }\n    updateIndexRegisters(qr: EntitySet, jr: EntitySet | null, select: SelectType) {\n        const action = this.action;\n        const scope = this.scope;\n        const instance = this.instance;\n        const state = this.scope.state;\n        // TODO: generalize to other cpus/langs\n        if (qr.entities.length > 1) {\n            switch (select) {\n                case 'once':\n                    break;\n                case 'foreach':\n                case 'unroll':\n                    if (state.xreg && state.yreg) throw new ECSError('no more index registers', action);\n                    if (state.xreg) state.yreg = new IndexRegister(scope, qr);\n                    else state.xreg = new IndexRegister(scope, qr);\n                    break;\n                case 'join':\n                    // TODO: Joins don't work in superman (arrays offset?)\n                    // ignore the join query, use the ref\n                    if (state.xreg || state.yreg) throw new ECSError('no free index registers for join', action);\n                    if (jr) state.xreg = new IndexRegister(scope, jr);\n                    state.yreg = new IndexRegister(scope, qr);\n                    break;\n                case 'if':\n                case 'with':\n                    // TODO: what if not in X because 1 element?\n                    if (state.xreg && state.xreg.eset) {\n                        state.xreg = state.xreg.narrow(qr, action);\n                    } else if (select == 'with') {\n                        if (instance.params.refEntity && instance.params.refField) {\n                            if (state.xreg)\n                                state.xreg.eset = qr;\n                            else\n                                state.xreg = new IndexRegister(scope, qr);\n                            // ???\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n    getCodeAndProps(qexpr: QueryExpr, qr: EntitySet, jr: EntitySet|null, \n        oldState: ActionCPUState)\n    {\n        // get properties and code\n        const entities = qr.entities;\n        const select = qexpr.select;\n        let code = '%%CODE%%';\n        let props: { [name: string]: string } = {};\n        // TODO: detect cycles\n        // TODO: \"source\"?\n        // TODO: what if only 1 item?\n        // TODO: what if join is subset of items?\n        if (select == 'join' && jr) {\n            //let jentities = this.jr.entities;\n            // TODO? \n                // TODO? throw new ECSError(`join query doesn't match any entities`, (action as ActionWithJoin).join); // TODO \n            //console.log('join', qr, jr);\n            if (qr.entities.length) {\n                let joinfield = this.getJoinField(this.action, qr.atypes, jr.atypes);\n                // TODO: what if only 1 item?\n                // TODO: should be able to access fields via Y reg\n                code = this.wrapCodeInLoop(code, qexpr, qr.entities, joinfield);\n                props['%joinfield'] = this.dialect.fieldsymbol(joinfield.c, joinfield.f, 0); //TODO?\n            }\n        }\n        // select subset of entities\n        let fullEntityCount = qr.entities.length; //entities.length.toString();\n        // TODO: let loopreduce = !loopents || entities.length < loopents.length;\n        //console.log(action.event, entities.length, loopents.length);\n        // filter entities from loop?\n        // TODO: when to ignore if entities.length == 1 and not in for loop?\n        if (select == 'with') {\n            // TODO? when to load x?\n            if (this.instance.params.refEntity && this.instance.params.refField) {\n                let re = this.instance.params.refEntity;\n                let rf = this.instance.params.refField;\n                code = this.wrapCodeInRefLookup(code);\n                // TODO: only fetches 1st entity in list, need offset\n                let range = this.scope.getFieldRange(rf.c, rf.f.name);\n                let eidofs = re.id - range.elo;\n                props['%reffield'] = `${this.dialect.fieldsymbol(rf.c, rf.f, 0)}+${eidofs}`;\n            } else {\n                code = this.wrapCodeInFilter(code, qr, oldState, props);\n            }\n        }\n        if (select == 'if') {\n            code = this.wrapCodeInFilter(code, qr, oldState, props);\n        }\n        if (select == 'foreach' && entities.length > 1) {\n            code = this.wrapCodeInLoop(code, qexpr, qr.entities);\n        }\n        if (select == 'unroll' && entities.length > 1) {\n            throw new ECSError('unroll is not yet implemented');\n        }\n        // define properties\n        if (entities.length) {\n            props['%elo'] = entities[0].id.toString();\n            props['%ehi'] = entities[entities.length - 1].id.toString();\n        }\n        props['%ecount'] = entities.length.toString();\n        props['%efullcount'] = fullEntityCount.toString();\n        //console.log('working', action.event, working.entities.length, entities.length);\n        return { code, props };\n    }\n    startQuery(qexpr: QueryExpr) {\n        const scope = this.scope;\n        const action = this.action;\n        const select = qexpr.select;\n\n        // save old state and make clone\n        const oldState = this.scope.state;\n        this.scope.state = Object.assign(new ActionCPUState(), oldState);\n\n        // get working set for this query\n        const qr = this.queryWorkingSet(qexpr);\n        \n        // is it a join? query that too\n        const jr = qexpr.join && qr.entities.length ? new EntitySet(scope, qexpr.join) : null;\n\n        // update x, y state\n        this.updateIndexRegisters(qr, jr, select);\n\n        const { code, props } = this.getCodeAndProps(qexpr, qr, jr, oldState);\n\n        // if join, working set is union of both parts\n        let working = jr ? qr.union(jr) : qr;\n        \n        return { working, oldState, props, code };\n    }\n    endQuery(q : { oldState: ActionCPUState }) {\n        this.scope.state = q.oldState;\n    }\n    wrapCodeInLoop(code: string, qexpr: QueryExpr, ents: Entity[], joinfield?: ComponentFieldPair): string {\n        // TODO: check ents\n        // TODO: check segment bounds\n        // TODO: what if 0 or 1 entitites?\n        // TODO: check > 127 or > 255\n        let dir = qexpr.direction;\n        let s = dir == 'desc' ? this.dialect.ASM_ITERATE_EACH_DESC : this.dialect.ASM_ITERATE_EACH_ASC;\n        if (joinfield) s = dir == 'desc' ? this.dialect.ASM_ITERATE_JOIN_DESC : this.dialect.ASM_ITERATE_JOIN_ASC;\n        s = s.replace('{{%code}}', code);\n        return s;\n    }\n    wrapCodeInFilter(code: string, qr: EntitySet, oldState: ActionCPUState, props: any) {\n        // TODO: :-p filters too often?\n        const ents = qr.entities;\n        const ents2 = oldState.xreg?.eset?.entities;\n        if (ents && ents.length && ents2) {\n            let lo = ents[0].id;\n            let hi = ents[ents.length - 1].id;\n            let lo2 = ents2[0].id;\n            let hi2 = ents2[ents2.length - 1].id;\n            if (lo != lo2) {\n                code = this.dialect.ASM_FILTER_RANGE_LO_X.replace('{{%code}}', code);\n                props['%xofs'] = lo - lo2;\n            }\n            if (hi != hi2) {\n                code = this.dialect.ASM_FILTER_RANGE_HI_X.replace('{{%code}}', code);\n            }\n        }\n        return code;\n    }\n    wrapCodeInRefLookup(code: string) {\n        code = this.dialect.ASM_LOOKUP_REF_X.replace('{{%code}}', code);\n        return code;\n    }\n}\n\nclass EventCodeStats {\n    constructor(\n        public readonly inst: SystemInstance,\n        public readonly action: Action,\n        public readonly eventcode: string\n    ) { }\n    labels : string[] = [];\n    count : number = 0;\n}\n\nexport class EntityScope implements SourceLocated {\n    $loc: SourceLocation;\n    childScopes: EntityScope[] = [];\n    instances: SystemInstance[] = [];\n    entities: Entity[] = [];\n    fieldtypes: { [name: string]: 'init' | 'const' } = {};\n    sysstats = new Map<SystemInstance, SystemStats>();\n    bss = new UninitDataSegment();\n    rodata = new ConstDataSegment();\n    code = new CodeSegment();\n    componentsInScope = new Set();\n    resources = new Set<string>();\n    state;\n    isDemo = false;\n    filePath = '';\n\n    eventSeq : number;\n    eventCodeStats : { [code:string] : EventCodeStats };\n    inCritical = 0;\n\n    constructor(\n        public readonly em: EntityManager,\n        public readonly dialect: Dialect_CA65,\n        public readonly name: string,\n        public readonly parent: EntityScope | undefined\n    ) {\n        parent?.childScopes.push(this);\n        this.state = new ActionCPUState();\n        // TODO: parent scope entities too?\n        this.state.working = new EntitySet(this, undefined, this.entities); // working set = all entities\n    }\n    newEntity(etype: EntityArchetype, name: string): Entity {\n        // TODO: add parent ID? lock parent scope?\n        // TODO: name identical check?\n        if (name && this.getEntityByName(name))\n            throw new ECSError(`already an entity named \"${name}\"`);\n        let id = this.entities.length;\n        etype = this.em.addArchetype(etype);\n        let entity: Entity = { id, etype, consts: {}, inits: {} };\n        for (let c of etype.components) {\n            this.componentsInScope.add(c.name);\n        }\n        entity.name = name;\n        this.entities.push(entity);\n        return entity;\n    }\n    newSystemInstance(inst: SystemInstance) {\n        if (!inst) throw new Error();\n        inst.id = this.instances.length+1;\n        this.instances.push(inst);\n        this.em.registerSystemEvents(inst.system);\n        return inst;\n    }\n    newSystemInstanceWithDefaults(system: System) {\n        return this.newSystemInstance({ system, params: {}, id:0 });\n    }\n    getSystemInstanceNamed(name: string) {\n        return this.instances.find(sys => sys.system.name == name);\n    }\n    getEntityByName(name: string) {\n        return this.entities.find(e => e.name == name);\n    }\n    *iterateEntityFields(entities: Entity[]) {\n        for (let i = 0; i < entities.length; i++) {\n            let e = entities[i];\n            for (let c of e.etype.components) {\n                for (let f of c.fields) {\n                    yield { i, e, c, f, v: e.consts[mksymbol(c, f.name)] };\n                }\n            }\n        }\n    }\n    *iterateArchetypeFields(arch: EntityArchetype[], filter?: (c: ComponentType, f: DataField) => boolean) {\n        for (let i = 0; i < arch.length; i++) {\n            let a = arch[i];\n            for (let c of a.components) {\n                for (let f of c.fields) {\n                    if (!filter || filter(c, f))\n                        yield { i, c, f };\n                }\n            }\n        }\n    }\n    *iterateChildScopes() {\n        for (let scope of this.childScopes) {\n            yield scope;\n        }\n    }\n    entitiesMatching(atypes: EntityArchetype[]) {\n        let result: Entity[] = [];\n        for (let e of this.entities) {\n            for (let a of atypes) {\n                // TODO: what about subclasses?\n                // TODO: very scary identity ocmpare\n                if (e.etype === a) {\n                    result.push(e);\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    hasComponent(ctype: ComponentType) {\n        return this.componentsInScope.has(ctype.name);\n    }\n    buildSegments() {\n        // build FieldArray for each component/field pair\n        // they will be different for bss/rodata segments\n        let iter = this.iterateEntityFields(this.entities);\n        for (var o = iter.next(); o.value; o = iter.next()) {\n            let { i, e, c, f, v } = o.value;\n            // constants and array pointers go into rodata\n            let cfname = mksymbol(c, f.name);\n            let ftype = this.fieldtypes[cfname];\n            let isConst = ftype == 'const';\n            let segment = isConst ? this.rodata : this.bss;\n            if (v === undefined && isConst)\n                throw new ECSError(`no value for const field ${cfname}`, e);\n            // determine range of indices for entities\n            let array = segment.fieldranges[cfname];\n            if (!array) {\n                array = segment.fieldranges[cfname] = { component: c, field: f, elo: i, ehi: i };\n            } else {\n                array.ehi = i;\n                if (array.ehi - array.elo + 1 >= 256)\n                    throw new ECSError(`too many entities have field ${cfname}, limit is 256`);\n            }\n            // set default values for entity/field\n            if (!isConst) {\n                if (f.dtype == 'int' && f.defvalue !== undefined) {\n                    let ecfname = mkscopesymbol(this, c, f.name);\n                    if (e.inits[ecfname] == null) {\n                        this.setInitValue(e, c, f, f.defvalue);\n                    }\n                }\n            }\n        }\n    }\n    // TODO: cull unused entity fields\n    allocateSegment(segment: DataSegment, alloc: boolean, type: 'init' | 'const' | undefined) {\n        let fields: FieldArray[] = Object.values(segment.fieldranges);\n        // TODO: fields.sort((a, b) => (a.ehi - a.elo + 1) * getPackedFieldSize(a.field));\n        for (let f of fields) {\n            if (this.fieldtypes[mksymbol(f.component, f.field.name)] == type) {\n                //console.log(f.component.name, f.field.name, type);\n                let rangelen = (f.ehi - f.elo + 1);\n                // TODO: doesn't work for packed arrays too well\n                let bits = getPackedFieldSize(f.field);\n                // variable size? make it a pointer\n                if (bits == 0) bits = 16; // TODO?\n                let bytesperelem = Math.ceil(bits / 8);\n                // TODO: packing bits\n                // TODO: split arrays\n                let access = [];\n                for (let i = 0; i < bits; i += 8) {\n                    let symbol = this.dialect.fieldsymbol(f.component, f.field, i);\n                    access.push({ symbol, bit: i, width: 8 }); // TODO\n                    if (alloc) {\n                        segment.allocateBytes(symbol, rangelen); // TODO\n                    }\n                }\n                f.access = access;\n            }\n        }\n    }\n    allocateROData(segment: DataSegment) {\n        let iter = this.iterateEntityFields(this.entities);\n        for (var o = iter.next(); o.value; o = iter.next()) {\n            let { i, e, c, f, v } = o.value;\n            let cfname = mksymbol(c, f.name);\n            // TODO: what if mix of var, const, and init values?\n            if (this.fieldtypes[cfname] == 'const') {\n                let range = segment.fieldranges[cfname];\n                let entcount = range ? range.ehi - range.elo + 1 : 0;\n                if (v == null && f.dtype == 'int') v = 0;\n                if (v == null && f.dtype == 'ref') v = 0;\n                if (v == null && f.dtype == 'array')\n                    throw new ECSError(`no default value for array ${cfname}`, e);\n                //console.log(c.name, f.name, '#'+e.id, '=', v);\n                // this is a constant\n                // is it a byte array?\n                //TODO? if (ArrayBuffer.isView(v) && f.dtype == 'array') {\n                if (v instanceof Uint8Array && f.dtype == 'array') {\n                    let ptrlosym = this.dialect.fieldsymbol(c, f, 0);\n                    let ptrhisym = this.dialect.fieldsymbol(c, f, 8);\n                    let loofs = segment.allocateBytes(ptrlosym, entcount);\n                    let hiofs = segment.allocateBytes(ptrhisym, entcount);\n                    let datasym = this.dialect.datasymbol(c, f, e.id, 0);\n                    segment.allocateInitData(datasym, v);\n                    if (f.baseoffset) datasym = `(${datasym}+${f.baseoffset})`;\n                    segment.initdata[loofs + e.id - range.elo] = { symbol: datasym, bitofs: 0 };\n                    segment.initdata[hiofs + e.id - range.elo] = { symbol: datasym, bitofs: 8 };\n                } else if (typeof v === 'number') {\n                    // more than 1 entity, add an array\n                    // TODO: infer need for array by usage\n                    /*if (entcount > 1)*/ {\n                        if (!range.access) throw new ECSError(`no access for field ${cfname}`)\n                        for (let a of range.access) {\n                            segment.allocateBytes(a.symbol, entcount);\n                            let ofs = segment.getByteOffset(range, a, e.id);\n                            // TODO: this happens if you forget a const field on an object?\n                            if (e.id < range.elo) throw new ECSError('entity out of range ' + c.name + ' ' + f.name, e);\n                            if (segment.initdata[ofs] !== undefined) throw new ECSError('initdata already set ' + ofs), e;\n                            segment.initdata[ofs] = (v >> a.bit) & 0xff;\n                        }\n                    }\n                } else if (v == null && f.dtype == 'array' && f.index) {\n                    // TODO\n                    let datasym = this.dialect.datasymbol(c, f, e.id, 0);\n                    let databytes = getFieldLength(f.index);\n                    let offset = this.bss.allocateBytes(datasym, databytes);\n                    // TODO? this.allocatePointerArray(c, f, datasym, entcount);\n                    let ptrlosym = this.dialect.fieldsymbol(c, f, 0);\n                    let ptrhisym = this.dialect.fieldsymbol(c, f, 8);\n                    // TODO: what if we don't need a pointer array?\n                    let loofs = segment.allocateBytes(ptrlosym, entcount);\n                    let hiofs = segment.allocateBytes(ptrhisym, entcount);\n                    if (f.baseoffset) datasym = `(${datasym}+${f.baseoffset})`;\n                    segment.initdata[loofs + e.id - range.elo] = { symbol: datasym, bitofs: 0 };\n                    segment.initdata[hiofs + e.id - range.elo] = { symbol: datasym, bitofs: 8 };\n                } else {\n                    // TODO: bad error message - should say \"wrong type, should be array\"\n                    throw new ECSError(`unhandled constant ${e.id}:${cfname} -- ${typeof v}`);\n                }\n            }\n        }\n        //console.log(segment.initdata)\n    }\n    allocateInitData(segment: DataSegment) {\n        if (segment.size == 0) return '';\n        let initbytes = new Uint8Array(segment.size);\n        let iter = this.iterateEntityFields(this.entities);\n        for (var o = iter.next(); o.value; o = iter.next()) {\n            let { i, e, c, f, v } = o.value;\n            let scfname = mkscopesymbol(this, c, f.name);\n            let initvalue = e.inits[scfname];\n            if (initvalue !== undefined) {\n                let range = segment.getFieldRange(c, f.name);\n                if (!range) throw new ECSError(`no init range for ${scfname}`, e);  \n                if (!range.access) throw new ECSError(`no init range access for ${scfname}`, e);\n                if (typeof initvalue === 'number') {\n                    for (let a of range.access) {\n                        let offset = segment.getByteOffset(range, a, e.id);\n                        initbytes[offset] = (initvalue >> a.bit) & ((1 << a.width) - 1);\n                    }\n                } else if (initvalue instanceof Uint8Array) {\n                    // TODO: 16/32...\n                    let datasym = this.dialect.datasymbol(c, f, e.id, 0);\n                    let ofs = this.bss.symbols[datasym];\n                    initbytes.set(initvalue, ofs);\n                } else {\n                    // TODO: init arrays?\n                    throw new ECSError(`cannot initialize ${scfname} = ${initvalue}`); // TODO??\n                }\n            }\n        }\n        // build the final init buffer\n        // TODO: compress 0s?\n        let bufsym = this.name + '__INITDATA';\n        let bufofs = this.rodata.allocateInitData(bufsym, initbytes);\n        let code = this.dialect.INIT_FROM_ARRAY;\n        //TODO: function to repalce from dict?\n        code = code.replace('{{%nbytes}}', initbytes.length.toString())\n        code = code.replace('{{%src}}', bufsym);\n        code = code.replace('{{%dest}}', segment.getOriginSymbol());\n        return code;\n    }\n    getFieldRange(c: ComponentType, fn: string) {\n        return this.bss.getFieldRange(c, fn) || this.rodata.getFieldRange(c, fn);\n    }\n    setConstValue(e: Entity, component: ComponentType, field: DataField, value: DataValue) {\n        this.setConstInitValue(e, component, field, value, 'const');\n    }\n    setInitValue(e: Entity, component: ComponentType, field: DataField, value: DataValue) {\n        this.setConstInitValue(e, component, field, value, 'init');\n    }\n    setConstInitValue(e: Entity, component: ComponentType, field: DataField, value: DataValue,\n        type: 'const'|'init')\n    {\n        this.checkFieldValue(field, value);\n        let fieldName = field.name;\n        let cfname = mksymbol(component, fieldName);\n        let ecfname = mkscopesymbol(this, component, fieldName);\n        if (e.consts[cfname] !== undefined) throw new ECSError(`\"${fieldName}\" is already defined as a constant`, e);\n        if (e.inits[ecfname] !== undefined) throw new ECSError(`\"${fieldName}\" is already defined as a variable`, e);\n        if (type == 'const') e.consts[cfname] = value;\n        if (type == 'init') e.inits[ecfname] = value;\n        this.fieldtypes[cfname] = type;\n    }\n    isConstOrInit(component: ComponentType, fieldName: string) : 'const' | 'init' {\n        return this.fieldtypes[mksymbol(component, fieldName)];\n    }\n    getConstValue(entity: Entity, fieldName: string) {\n        let component = this.em.singleComponentWithFieldName([entity.etype], fieldName, entity);\n        let cfname = mksymbol(component, fieldName);\n        return entity.consts[cfname];\n    }\n    checkFieldValue(field: DataField, value: DataValue) {\n        if (field.dtype == 'array') {\n            if (!(value instanceof Uint8Array))\n                throw new ECSError(`This \"${field.name}\" value should be an array.`);\n        } else if (typeof value !== 'number') {\n            throw new ECSError(`This \"${field.name}\" ${field.dtype} value should be an number.`);\n        } else {\n            if (field.dtype == 'int') {\n                if (value < field.lo || value > field.hi)\n                    throw new ECSError(`This \"${field.name}\" value is out of range, should be between ${field.lo} and ${field.hi}.`);\n            } else if (field.dtype == 'ref') {\n                // TODO: allow override if number\n                let eset = new EntitySet(this, field.query);\n                if (value < 0 || value >= eset.entities.length)\n                    throw new ECSError(`This \"${field.name}\" value is out of range for this ref type.`);\n            }\n        }\n    }\n    generateCodeForEvent(event: string, args?: string[], codelabel?: string): string {\n        // find systems that respond to event\n        // and have entities in this scope\n        let systems = this.em.event2systems[event];\n        if (!systems || systems.length == 0) {\n            // TODO: error or warning?\n            //throw new ECSError(`warning: no system responds to \"${event}\"`);\n            console.log(`warning: no system responds to \"${event}\"`);\n            return '';\n        }\n        this.eventSeq++;\n        // generate code\n        let code = '';\n        // is there a label? generate it first\n        if (codelabel) { code += this.dialect.label(codelabel) + '\\n'; }\n        // if \"start\" event, initialize data segment\n        if (event == 'start') {\n            code += this.allocateInitData(this.bss);\n        }\n        // iterate all instances and generate matching events\n        let eventCount = 0;\n        let instances = this.instances.filter(inst => systems.includes(inst.system));\n        for (let inst of instances) {\n            let sys = inst.system;\n            for (let action of sys.actions) {\n                if (action.event == event) {\n                    eventCount++;\n                    // TODO: use Tokenizer so error msgs are better\n                    // TODO: keep event tree\n                    let codeeval = new ActionEval(this, inst, action, args || []);\n                    codeeval.begin();\n                    if (action.critical) this.inCritical++;\n                    let eventcode = codeeval.codeToString();\n                    if (action.critical) this.inCritical--;\n                    if (!this.inCritical && codeeval.isSubroutineSized(eventcode)) {\n                        let normcode = this.normalizeCode(eventcode, action);\n                        let estats = this.eventCodeStats[normcode];\n                        if (!estats) {\n                            estats = this.eventCodeStats[normcode] = new EventCodeStats(\n                                inst, action, eventcode);\n                        }\n                        estats.labels.push(codeeval.label);\n                        estats.count++;\n                        if (action.critical) estats.count++; // always make critical event subroutines\n                    }\n                    let s = '';\n                    s += this.dialect.comment(`start action ${codeeval.label}`);\n                    s += eventcode;\n                    s += this.dialect.comment(`end action ${codeeval.label}`);\n                    code += s;\n                    // TODO: check that this happens once?\n                    codeeval.end();\n                }\n            }\n        }\n        if (eventCount == 0) {\n            console.log(`warning: event ${event} not handled`);\n        }\n        return code;\n    }\n    normalizeCode(code: string, action: Action) {\n        // TODO: use dialect to help with this\n        code = code.replace(/\\b(\\w+__\\w+__)(\\d+)__(\\w+)\\b/g, (z,a,b,c) => a+c);\n        return code;\n    }\n    getSystemStats(inst: SystemInstance) : SystemStats {\n        let stats = this.sysstats.get(inst);\n        if (!stats) {\n            stats = new SystemStats();\n            this.sysstats.set(inst, stats);\n        }\n        return stats;\n    }\n    updateTempLiveness(inst: SystemInstance) {\n        let stats = this.getSystemStats(inst);\n        let n = this.eventSeq;\n        if (stats.tempstartseq && stats.tempendseq) {\n            stats.tempstartseq = Math.min(stats.tempstartseq, n);\n            stats.tempendseq = Math.max(stats.tempendseq, n);\n        } else {\n            stats.tempstartseq = stats.tempendseq = n;\n        }\n    }\n    includeResource(symbol: string): string {\n        this.resources.add(symbol);\n        return symbol;\n    }\n    private allocateTempVars() {\n        let pack = new Packer();\n        let maxTempBytes = 128 - this.bss.size; // TODO: multiple data segs\n        let bssbin = new Bin({ left:0, top:0, bottom: this.eventSeq+1, right: maxTempBytes });\n        pack.bins.push(bssbin);\n        for (let instance of this.instances) {\n            let stats = this.getSystemStats(instance);\n            if (instance.system.tempbytes && stats.tempstartseq && stats.tempendseq) {\n                let v = {\n                    inst: instance,\n                    top: stats.tempstartseq,\n                    bottom: stats.tempendseq+1,\n                    width: instance.system.tempbytes,\n                    height: stats.tempendseq - stats.tempstartseq + 1,\n                    label: instance.system.name\n                };\n                pack.boxes.push(v);\n            }\n        }\n        if (!pack.pack()) console.log('cannot pack temporary local vars'); // TODO\n        //console.log('tempvars', pack);\n        if (bssbin.extents.right > 0) {\n            let tempofs = this.bss.allocateBytes('TEMP', bssbin.extents.right);\n            for (let b of pack.boxes) {\n                let inst : SystemInstance = (b as any).inst;\n                //console.log(inst.system.name, b.box?.left);\n                if (b.box) this.bss.declareSymbol(this.dialect.tempLabel(inst), tempofs + b.box.left);\n                //this.bss.equates[this.dialect.tempLabel(inst)] = `TEMP+${b.box?.left}`;\n            }\n        }\n        console.log(pack.toSVGUrl());\n    }\n    private analyzeEntities() {\n        this.buildSegments();\n        this.allocateSegment(this.bss, true, 'init');  // initialized vars\n        this.allocateSegment(this.bss, true, undefined);   // uninitialized vars\n        this.allocateSegment(this.rodata, false, 'const'); // constants\n        this.allocateROData(this.rodata);\n    }\n    private generateCode() {\n        this.eventSeq = 0;\n        this.eventCodeStats = {};\n        let isMainScope = this.parent == null;\n        let start;\n        let initsys = this.em.getSystemByName('Init');\n        if (isMainScope && initsys) {\n            this.newSystemInstanceWithDefaults(initsys); //TODO: what if none?\n            start = this.generateCodeForEvent('main_init');\n        } else {\n            start = this.generateCodeForEvent('start');\n        }\n        start = this.replaceSubroutines(start);\n        this.code.addCodeFragment(start);\n        for (let sub of Array.from(this.resources.values())) {\n            if (!this.getSystemInstanceNamed(sub)) {\n                let sys = this.em.getSystemByName(sub);\n                if (!sys) throw new ECSError(`cannot find resource named \"${sub}\"`);\n                this.newSystemInstanceWithDefaults(sys);\n            }\n            let code = this.generateCodeForEvent(sub, [], sub);\n            this.code.addCodeFragment(code); // TODO: should be rodata?\n        }\n        //this.showStats();\n    }\n    replaceSubroutines(code: string) {\n        // TODO: bin-packing for critical code\n        // TODO: doesn't work with nested subroutines?\n        // TODO: doesn't work between scopes\n        let allsubs : string[] = [];\n        for (let stats of Object.values(this.eventCodeStats)) {\n            if (stats.count > 1) {\n                if (allsubs.length == 0) {\n                    allsubs = [\n                        this.dialect.segment('rodata'),\n                        this.dialect.alignSegmentStart()\n                    ]\n                } else if (stats.action.fitbytes) {\n                    allsubs.push(this.dialect.alignIfLessThan(stats.action.fitbytes));\n                }\n                let subcall = this.dialect.call(stats.labels[0]);\n                for (let label of stats.labels) {\n                    let startdelim = this.dialect.comment(`start action ${label}`).trim();\n                    let enddelim = this.dialect.comment(`end action ${label}`).trim();\n                    let istart = code.indexOf(startdelim);\n                    let iend = code.indexOf(enddelim, istart);\n                    if (istart >= 0 && iend > istart) {\n                        code = code.substring(0, istart) + subcall + code.substring(iend + enddelim.length);\n                    }\n                }\n                let substart = stats.labels[0];\n                let sublines = [\n                    this.dialect.segment('rodata'),\n                    this.dialect.label(substart),\n                    stats.eventcode,\n                    this.dialect.return(),\n                ];\n                if (stats.action.critical) {\n                    sublines.push(this.dialect.warningIfPageCrossed(substart));\n                }\n                if (stats.action.fitbytes) {\n                    sublines.push(this.dialect.warningIfMoreThan(stats.action.fitbytes, substart));\n                }\n                allsubs = allsubs.concat(sublines);\n            }\n        }\n        code += allsubs.join('\\n');\n        return code;\n    }\n    showStats() {\n        for (let inst of this.instances) {\n            // TODO?\n            console.log(inst.system.name, this.getSystemStats(inst));\n        }\n    }\n    private dumpCodeTo(file: SourceFileExport) {\n        let dialect = this.dialect;\n        file.line(dialect.startScope(this.name));\n        file.line(dialect.segment('bss'));\n        this.bss.dump(file, dialect);\n        file.line(dialect.segment('code')); // TODO: rodata for aligned?\n        this.rodata.dump(file, dialect);\n        //file.segment(`${this.name}_CODE`, 'code');\n        file.line(dialect.label('__Start'));\n        this.code.dump(file);\n        for (let subscope of this.childScopes) {\n            // TODO: overlay child BSS segments\n            subscope.dump(file);\n        }\n        file.line(dialect.endScope(this.name));\n    }\n    dump(file: SourceFileExport) {\n        this.analyzeEntities();\n        this.generateCode();\n        this.allocateTempVars();\n        this.dumpCodeTo(file);\n    }\n}\n\nexport class EntityManager {\n    archetypes: { [key: string]: EntityArchetype } = {};\n    components: { [name: string]: ComponentType } = {};\n    systems: { [name: string]: System } = {};\n    topScopes: { [name: string]: EntityScope } = {};\n    event2systems: { [event: string]: System[] } = {};\n    name2cfpairs: { [cfname: string]: ComponentFieldPair[] } = {};\n    mainPath: string = '';\n    imported: { [path: string]: boolean } = {};\n    seq = 1;\n\n    constructor(public readonly dialect: Dialect_CA65) {\n    }\n    newScope(name: string, parent?: EntityScope) {\n        let existing = this.topScopes[name];\n        if (existing && !existing.isDemo)\n            throw new ECSError(`scope ${name} already defined`, existing);\n        let scope = new EntityScope(this, this.dialect, name, parent);\n        if (!parent) this.topScopes[name] = scope;\n        return scope;\n    }\n    deferComponent(name: string) {\n        this.components[name] = { name, fields: [] };\n    }\n    defineComponent(ctype: ComponentType) {\n        let existing = this.components[ctype.name];\n        // we can defer component definitions, just declare a component with 0 fields?\n        if (existing && existing.fields.length > 0)\n            throw new ECSError(`component ${ctype.name} already defined`, existing);\n        if (existing) {\n            existing.fields = ctype.fields;\n            ctype = existing;\n        }\n        for (let field of ctype.fields) {\n            let list = this.name2cfpairs[field.name];\n            if (!list) list = this.name2cfpairs[field.name] = [];\n            list.push({ c: ctype, f: field });\n        }\n        this.components[ctype.name] = ctype;\n        return ctype;\n    }\n    defineSystem(system: System) {\n        let existing = this.systems[system.name];\n        if (existing) throw new ECSError(`system ${system.name} already defined`, existing);\n        return this.systems[system.name] = system;\n    }\n    registerSystemEvents(system: System) {\n        for (let a of system.actions) {\n            let event = a.event;\n            let list = this.event2systems[event];\n            if (list == null) list = this.event2systems[event] = [];\n            if (!list.includes(system)) list.push(system);\n        }\n    }\n    addArchetype(atype: EntityArchetype): EntityArchetype {\n        let key = atype.components.map(c => c.name).join(',');\n        if (this.archetypes[key])\n            return this.archetypes[key];\n        else\n            return this.archetypes[key] = atype;\n    }\n    componentsMatching(q: Query, etype: EntityArchetype) {\n        let list = [];\n        for (let c of etype.components) {\n            if (q.exclude?.includes(c)) {\n                return [];\n            }\n            // TODO: 0 includes == all entities?\n            if (q.include.length == 0 || q.include.includes(c)) {\n                list.push(c);\n            }\n        }\n        return list.length == q.include.length ? list : [];\n    }\n    archetypesMatching(q: Query) {\n        let result = new Set<EntityArchetype>();\n        for (let etype of Object.values(this.archetypes)) {\n            let cmatch = this.componentsMatching(q, etype);\n            if (cmatch.length > 0) {\n                result.add(etype);\n            }\n        }\n        return Array.from(result.values());\n    }\n    componentsWithFieldName(atypes: EntityArchetype[], fieldName: string) {\n        // TODO???\n        let comps = new Set<ComponentType>();\n        for (let at of atypes) {\n            for (let c of at.components) {\n                for (let f of c.fields) {\n                    if (f.name == fieldName)\n                        comps.add(c);\n                }\n            }\n        }\n        return Array.from(comps);\n    }\n    getComponentByName(name: string): ComponentType {\n        return this.components[name];\n    }\n    getSystemByName(name: string): System {\n        return this.systems[name];\n    }\n    singleComponentWithFieldName(atypes: EntityArchetype[], fieldName: string, where: SourceLocated) {\n        let cfpairs = this.name2cfpairs[fieldName];\n        if (!cfpairs) throw new ECSError(`cannot find field named \"${fieldName}\"`, where);\n        let filtered = cfpairs.filter(cf => atypes.find(a => a.components.includes(cf.c)));\n        if (filtered.length == 0) {\n            throw new ECSError(`cannot find component with field \"${fieldName}\" in this context`, where);\n        }\n        if (filtered.length > 1) {\n            throw new ECSError(`ambiguous field name \"${fieldName}\"`, where);\n        }\n        return filtered[0].c;\n    }\n    toJSON() {\n        return JSON.stringify({\n            components: this.components,\n            systems: this.systems\n        })\n    }\n    exportToFile(file: SourceFileExport) {\n        for (let event of Object.keys(this.event2systems)) {\n            file.line(this.dialect.equate(`EVENT__${event}`, '1'))\n        }\n        for (let scope of Object.values(this.topScopes)) {\n            if (!scope.isDemo || scope.filePath == this.mainPath) {\n                scope.dump(file);\n            }\n        }\n    }\n    *iterateScopes() {\n        for (let scope of Object.values(this.topScopes)) {\n            yield scope;\n            scope.iterateChildScopes();\n        }\n    }\n    getDebugTree() : {} {\n        let scopes = this.topScopes;\n        let components = this.components;\n        let fields = this.name2cfpairs;\n        let systems = this.systems;\n        let events = this.event2systems;\n        let entities : {[key:string]:Entity} = {};\n        for (let scope of Array.from(this.iterateScopes())) {\n            for (let e of scope.entities)\n                entities[e.name || '#'+e.id.toString()] = e;\n        }\n        return { scopes, components, fields, systems, events, entities };\n    }\n\n    // expression stuff\n\n    evalExpr(expr: Expr, scope: EntityScope | null) : Expr {\n        if (isLiteral(expr)) return expr;\n        if (isBinOp(expr) || isUnOp(expr)) {\n            var fn = (this as any)['evalop__' + expr.op];\n            if (!fn) throw new ECSError(`no eval function for \"${expr.op}\"`);\n        }\n        if (isBinOp(expr)) {\n            expr.left = this.evalExpr(expr.left, scope);\n            expr.right = this.evalExpr(expr.right, scope);\n            let e = fn(expr.left, expr.right);\n            return e || expr;\n        }\n        if (isUnOp(expr)) {\n            expr.expr = this.evalExpr(expr.expr, scope);\n            let e = fn(expr.expr);\n            return e || expr;\n        }\n        return expr;\n    }\n    evalop__neg(arg: Expr) : Expr | undefined {\n        if (isLiteralInt(arg)) {\n            let valtype : IntType = { dtype:'int',\n                lo: -arg.valtype.hi,\n                hi: arg.valtype.hi };\n            return { valtype, value: -arg.value };\n        }\n    }\n    evalop__add(left: Expr, right: Expr) : Expr | undefined {\n        if (isLiteralInt(left) && isLiteralInt(right)) {\n            let valtype : IntType = { dtype:'int', \n                lo: left.valtype.lo + right.valtype.lo, \n                hi: left.valtype.hi + right.valtype.hi };\n            return { valtype, value: left.value + right.value };\n        }\n    }\n    evalop__sub(left: Expr, right: Expr) : Expr | undefined {\n        if (isLiteralInt(left) && isLiteralInt(right)) {\n            let valtype : IntType = { dtype:'int', \n                lo: left.valtype.lo - right.valtype.hi, \n                hi: left.valtype.hi - right.valtype.lo };\n            return { valtype, value: left.value - right.value };\n        }\n    }\n}\n", "\nimport { SourceLocation } from \"../workertypes\";\nimport { DataValue, ECSError } from \"./ecs\";\n\nexport interface DecoderResult {\n    properties: {[name: string] : DataValue}\n}\n\nabstract class LineDecoder {\n    curline: number = 0; // for debugging, zero-indexed\n    lines : string[][]; // array of token arrays\n\n    constructor(\n        text: string\n    ) {\n        // split the text into lines and into tokens\n        this.lines = text.split('\\n').map(s => s.trim()).filter(s => !!s).map(s => s.split(/\\s+/));\n    }\n\n    decodeBits(s: string, n: number, msbfirst: boolean) {\n        if (s.length != n) throw new ECSError(`Expected ${n} characters`);\n        let b = 0;\n        for (let i=0; i<n; i++) {\n            let bit;\n            let ch = s.charAt(i);\n            if (ch == 'x' || ch == 'X' || ch == '1') bit = 1;\n            else if (ch == '.' || ch == '0') bit = 0;\n            else throw new ECSError('need x or . (or 0 or 1)');\n            if (bit) {\n                if (msbfirst) b |= 1 << (n-1-i);\n                else b |= 1 << i;\n            }\n        }\n        return b;\n    }\n\n    assertTokens(toks: string[], count: number) {\n        if (toks.length != count) throw new ECSError(`Expected ${count} tokens on line.`);\n    }\n\n    hex(s: string) {\n        let v = parseInt(s, 16);\n        if (isNaN(v)) throw new ECSError(`Invalid hex value: ${s}`)\n        return v;\n    }\n\n    getErrorLocation($loc: SourceLocation): SourceLocation {\n        // TODO: blank lines mess this up\n        $loc.line += this.curline + 1;\n        return $loc;\n    }\n\n    abstract parse() : DecoderResult;\n}\n\nexport class VCSSpriteDecoder extends LineDecoder {\n    parse() {\n        let height = this.lines.length;\n        let bitmapdata = new Uint8Array(height);\n        let colormapdata = new Uint8Array(height);\n        for (let i=0; i<height; i++) {\n            this.curline = height - 1 - i;\n            let toks = this.lines[this.curline];\n            this.assertTokens(toks, 2);\n            bitmapdata[i] = this.decodeBits(toks[0], 8, true);\n            colormapdata[i] = this.hex(toks[1]);\n        }\n        return {\n            properties: {\n                bitmapdata, colormapdata, height: height-1\n            }\n        }\n    }\n}\n\nexport class VCSBitmapDecoder extends LineDecoder {\n    parse() {\n        let height = this.lines.length;\n        let bitmapdata = new Uint8Array(height);\n        for (let i=0; i<height; i++) {\n            this.curline = height - 1 - i;\n            let toks = this.lines[this.curline];\n            this.assertTokens(toks, 1);\n            bitmapdata[i] = this.decodeBits(toks[0], 8, true);\n        }\n        return {\n            properties: {\n                bitmapdata, height: height-1\n            }\n        }\n    }\n}\n\nexport class VCSPlayfieldDecoder extends LineDecoder {\n    parse() {\n        let height = this.lines.length;\n        let pf = new Uint32Array(height);\n        for (let i=0; i<height; i++) {\n            this.curline = height - 1 - i;\n            let toks = this.lines[this.curline];\n            this.assertTokens(toks, 1);\n            let pf0 = this.decodeBits(toks[0].substring(0,4), 4, false) << 4;\n            let pf1 = this.decodeBits(toks[0].substring(4,12), 8, true);\n            let pf2 = this.decodeBits(toks[0].substring(12,20), 8, false);\n            pf[i] = (pf0 << 0) | (pf1 << 8) | (pf2 << 16);\n        }\n        return {\n            properties: {\n                pf\n            }\n        }\n    }\n}\n\n\nexport class VCSVersatilePlayfieldDecoder extends LineDecoder {\n    parse() {\n        let height = this.lines.length;\n        let data = new Uint8Array(height * 2);\n        data.fill(0x3f);\n        // pf0 pf1 pf2 colupf colubk ctrlpf trash\n        const regs = [0x0d, 0x0e, 0x0f, 0x08, 0x09, 0x0a, 0x3f];\n        let prev = [0,0,0,0,0,0,0];\n        let cur  = [0,0,0,0,0,0,0];\n        for (let i=0; i<height; i++) {\n            let dataofs = height*2 - i*2;\n            this.curline = i;\n            let toks = this.lines[this.curline];\n            if (toks.length == 2) {\n                data[dataofs - 1] = this.hex(toks[0]);\n                data[dataofs - 2] = this.hex(toks[1]);\n                continue;\n            }\n            this.assertTokens(toks, 4);\n            cur[0] = this.decodeBits(toks[0].substring(0,4), 4, false) << 4;\n            cur[1] = this.decodeBits(toks[0].substring(4,12), 8, true);\n            cur[2] = this.decodeBits(toks[0].substring(12,20), 8, false);\n            if (toks[1] != '..') cur[3] = this.hex(toks[1]);\n            if (toks[2] != '..') cur[4] = this.hex(toks[2]);\n            if (toks[3] != '..') cur[5] = this.hex(toks[3]);\n            let changed = [];\n            for (let j=0; j<cur.length; j++) {\n                if (cur[j] != prev[j])\n                    changed.push(j);\n            }\n            if (changed.length > 1) {\n                console.log(changed, cur, prev);\n                throw new ECSError(`More than one register change in line ${i+1}: [${changed}]`);\n            }\n            let chgidx = changed.length ? changed[0] : regs.length-1;\n            data[dataofs - 1] = regs[chgidx];\n            data[dataofs - 2] = cur[chgidx];\n            prev[chgidx] = cur[chgidx];\n        }\n        return {\n            properties: {\n                data\n            }\n        }\n    }\n}\n\nexport class VCSBitmap48Decoder extends LineDecoder {\n    parse() {\n        let height = this.lines.length;\n        let bitmap0 = new Uint8Array(height);\n        let bitmap1 = new Uint8Array(height);\n        let bitmap2 = new Uint8Array(height);\n        let bitmap3 = new Uint8Array(height);\n        let bitmap4 = new Uint8Array(height);\n        let bitmap5 = new Uint8Array(height);\n        for (let i=0; i<height; i++) {\n            this.curline = height - 1 - i;\n            let toks = this.lines[this.curline];\n            this.assertTokens(toks, 1);\n            bitmap0[i] = this.decodeBits(toks[0].slice(0,8), 8, true);\n            bitmap1[i] = this.decodeBits(toks[0].slice(8,16), 8, true);\n            bitmap2[i] = this.decodeBits(toks[0].slice(16,24), 8, true);\n            bitmap3[i] = this.decodeBits(toks[0].slice(24,32), 8, true);\n            bitmap4[i] = this.decodeBits(toks[0].slice(32,40), 8, true);\n            bitmap5[i] = this.decodeBits(toks[0].slice(40,48), 8, true);\n        }\n        return {\n            properties: {\n                bitmap0, bitmap1, bitmap2, bitmap3, bitmap4, bitmap5,\n                height: height-1\n            }\n        }\n    }\n}\n\nexport function newDecoder(name: string, text: string) : LineDecoder | undefined {\n    let cons = (DECODERS as any)[name];\n    if (cons) return new cons(text);\n}\n\nconst DECODERS = {\n    'vcs_sprite': VCSSpriteDecoder,\n    'vcs_bitmap': VCSBitmapDecoder,\n    'vcs_playfield': VCSPlayfieldDecoder,\n    'vcs_versatile': VCSVersatilePlayfieldDecoder,\n    'vcs_bitmap48': VCSBitmap48Decoder,\n}\n", "\nimport { mergeLocs, Token, Tokenizer, TokenType } from \"../tokenizer\";\nimport { SourceLocated, SourceLocation } from \"../workertypes\";\nimport { newDecoder } from \"./decoder\";\nimport { Action, ActionContext, ArrayType, CodeLiteralNode, CodePlaceholderNode, ComponentType, DataField, DataType, DataValue, ECSError, Entity, EntityArchetype, EntityManager, EntityScope, IntType, Query, RefType, SelectType, SELECT_TYPE, SourceFileExport, System, SystemInstance, SystemInstanceParameters, ComponentFieldPair, Expr, ExprBase, ForwardRef, isLiteral, EntityFieldOp, LExpr, Statement, QueryExpr } from \"./ecs\";\n\nexport enum ECSTokenType {\n    Ellipsis = 'ellipsis',\n    Operator = 'operator',\n    Relational = 'relational',\n    QuotedString = 'quoted-string',\n    Integer = 'integer',\n    CodeFragment = 'code-fragment',\n    Placeholder = 'placeholder',\n}\n\nconst OPERATORS = {\n    'IMP':  {f:'bimp',p:4},\n    'EQV':  {f:'beqv',p:5},\n    'XOR':  {f:'bxor',p:6},\n    'OR':   {f:'bor',p:7}, // or \"lor\" for logical\n    'AND':  {f:'band',p:8}, // or \"land\" for logical\n    '||':   {f:'lor',p:17}, // not used\n    '&&':   {f:'land',p:18}, // not used\n    '=':    {f:'eq',p:50},\n    '==':   {f:'eq',p:50},\n    '<>':   {f:'ne',p:50},\n    '><':   {f:'ne',p:50},\n    '!=':   {f:'ne',p:50},\n    '#':    {f:'ne',p:50},\n    '<':    {f:'lt',p:50},\n    '>':    {f:'gt',p:50},\n    '<=':   {f:'le',p:50},\n    '>=':   {f:'ge',p:50},\n    'MIN':  {f:'min',p:75},\n    'MAX':  {f:'max',p:75},\n    '+':    {f:'add',p:100},\n    '-':    {f:'sub',p:100},\n};\n\nfunction getOperator(op: string) {\n    return (OPERATORS as any)[op];\n}\n\nfunction getPrecedence(tok: Token): number {\n    switch (tok.type) {\n        case ECSTokenType.Operator:\n        case ECSTokenType.Relational:\n        case TokenType.Ident:\n            let op = getOperator(tok.str);\n            if (op) return op.p;\n    }\n    return -1;\n}\n\n// is token an end of statement marker? (\":\" or end of line)\nfunction isEOS(tok: Token) {\n    return tok.type == TokenType.EOL || tok.type == TokenType.Comment\n        || tok.str == ':' || tok.str == 'ELSE'; // TODO: only ELSE if ifElse==true\n}\n\n///\n\nexport class ECSCompiler extends Tokenizer {\n\n    currentScope: EntityScope | null = null;\n    currentContext: ActionContext | null = null;\n    includeDebugInfo = false;\n\n    constructor(\n        public readonly em: EntityManager,\n        public readonly isMainFile: boolean) {\n        super();\n        //this.includeEOL = true;\n        this.setTokenRules([\n            { type: ECSTokenType.Ellipsis, regex: /\\.\\./ },\n            { type: ECSTokenType.QuotedString, regex: /\".*?\"/ },\n            { type: ECSTokenType.CodeFragment, regex: /---.*?---/ },\n            { type: ECSTokenType.Integer, regex: /0[xX][A-Fa-f0-9]+/ },\n            { type: ECSTokenType.Integer, regex: /\\$[A-Fa-f0-9]+/ },\n            { type: ECSTokenType.Integer, regex: /[%][01]+/ },\n            { type: ECSTokenType.Integer, regex: /\\d+/ },\n            { type: ECSTokenType.Relational, regex: /[=<>][=<>]?/ },\n            { type: ECSTokenType.Operator, regex: /[.#,:(){}\\[\\]\\-\\+]/ },\n            { type: TokenType.Ident, regex: /[A-Za-z_][A-Za-z0-9_]*/ },\n            { type: TokenType.Ignore, regex: /\\/\\/.*?[\\n\\r]/ },\n            { type: TokenType.Ignore, regex: /\\/\\*.*?\\*\\// },\n            { type: TokenType.EOL, regex: /[\\n\\r]+/ },\n            { type: TokenType.Ignore, regex: /\\s+/ },\n        ]);\n        this.errorOnCatchAll = true;\n    }\n\n    annotate<T extends SourceLocated>(fn: () => T) {\n        let start = this.peekToken();\n        let obj = fn();\n        let end = this.lasttoken;\n        let $loc = end ? mergeLocs(start.$loc, end.$loc) : start.$loc;\n        if (obj) (obj as SourceLocated).$loc = $loc;\n        return obj;\n    }\n\n    parseFile(text: string, path: string) {\n        this.tokenizeFile(text, path);\n        while (!this.isEOF()) {\n            let top = this.parseTopLevel();\n            if (top) {\n                let t = top;\n                this.annotate(() => t); // TODO? typescript bug?\n            }\n        }\n        this.runDeferred();\n    }\n\n    getImportFile: (path: string) => string;\n\n    importFile(path: string) {\n        if (!this.em.imported[path]) { // already imported?\n            let text = this.getImportFile && this.getImportFile(path);\n            if (!text) this.compileError(`I can't find the import file \"${path}\".`);\n            this.em.imported[path] = true;\n            let comp = new ECSCompiler(this.em, false);\n            comp.includeDebugInfo = this.includeDebugInfo; // TODO: clone compiler\n            try {\n                comp.parseFile(text, path);\n            } catch (e) {\n                for (var err of comp.errors) this.errors.push(err);\n                throw e;\n            }\n        }\n    }\n\n    parseTopLevel() {\n        //this.skipBlankLines();\n        let tok = this.expectTokens(['component', 'system', 'scope', 'resource', 'import', 'demo', 'comment']);\n        if (tok.str == 'component') {\n            return this.em.defineComponent(this.parseComponentDefinition());\n        }\n        if (tok.str == 'system') {\n            return this.em.defineSystem(this.parseSystem());\n        }\n        if (tok.str == 'scope') {\n            return this.parseScope();\n        }\n        if (tok.str == 'resource') {\n            return this.em.defineSystem(this.parseResource());\n        }\n        if (tok.str == 'import') {\n            let tok = this.expectTokenTypes([ECSTokenType.QuotedString]);\n            let path = tok.str.substring(1, tok.str.length - 1);\n            return this.importFile(path);\n        }\n        if (tok.str == 'demo') {\n            if (this.isMainFile) {\n                let scope = this.parseScope();\n                scope.isDemo = true;\n                this.expectToken('demo');\n                return scope;\n            } else {\n                this.skipDemo(); // don't even parse it, just skip it\n                return;\n            }\n        }\n        if (tok.str == 'comment') {\n            this.expectTokenTypes([ECSTokenType.CodeFragment]);\n            return;\n        }\n        this.compileError(`Unexpected top-level keyword: ${tok.str}`);\n    }\n\n    skipDemo() {\n        var tok;\n        while ((tok = this.consumeToken()) && !this.isEOF()) {\n            if (tok.str == 'end' && this.peekToken().str == 'demo') {\n                this.consumeToken();\n                return;\n            }\n        }\n        throw new ECSError(`Expected \"end demo\" after a \"demo\" declaration.`);\n    }\n\n    parseComponentDefinition(): ComponentType {\n        let name = this.expectIdent().str;\n        let fields = [];\n        this.em.deferComponent(name);\n        while (this.peekToken().str != 'end') {\n            fields.push(this.parseComponentField());\n        }\n        this.expectToken('end');\n        return { name, fields };\n    }\n\n    parseComponentField(): DataField {\n        let name = this.expectIdent();\n        this.expectToken(':', 'I expected either a \":\" or \"end\" here.'); // TODO\n        let type = this.parseDataType();\n        return { name: name.str, $loc: name.$loc, ...type };\n    }\n\n    parseDataType(): DataType {\n        if (this.peekToken().type == 'integer') {\n            let lo = this.parseIntegerConstant();\n            this.expectToken('..');\n            let hi = this.parseIntegerConstant();\n            this.checkLowerLimit(lo, -0x80000000, \"lower int range\");\n            this.checkUpperLimit(hi, 0x7fffffff, \"upper int range\");\n            this.checkUpperLimit(hi-lo, 0xffffffff, \"int range\");\n            this.checkLowerLimit(hi, lo, \"int range\");\n            // TODO: use default value?\n            let defvalue;\n            if (this.ifToken('default')) {\n                defvalue = this.parseIntegerConstant();\n            }\n            // TODO: check types\n            return { dtype: 'int', lo, hi, defvalue } as IntType;\n        }\n        if (this.peekToken().str == '[') {\n            return { dtype: 'ref', query: this.parseQuery() } as RefType;\n        }\n        if (this.ifToken('array')) {\n            let index: IntType | undefined = undefined;\n            if (this.peekToken().type == ECSTokenType.Integer) {\n                index = this.parseDataType() as IntType;\n            }\n            this.expectToken('of');\n            let elem = this.parseDataType();\n            let baseoffset;\n            if (this.ifToken('baseoffset')) {\n                baseoffset = this.parseIntegerConstant();\n                this.checkLowerLimit(baseoffset, -32768, \"base offset\");\n                this.checkUpperLimit(baseoffset, 32767, \"base offset\");\n            }\n            return { dtype: 'array', index, elem, baseoffset } as ArrayType;\n        }\n        if (this.ifToken('enum')) {\n            this.expectToken('[');\n            let enumtoks = this.parseList(this.parseEnumIdent, ',');\n            this.expectToken(']');\n            if (enumtoks.length == 0) this.compileError(`must define at least one enum`);\n            let lo = 0;\n            let hi = enumtoks.length-1;\n            this.checkLowerLimit(hi, 0, \"enum count\");\n            this.checkUpperLimit(hi, 255, \"enum count\");\n            let enums : {[name:string]:number} = {};\n            for (let i=0; i<=hi; i++)\n                enums[enumtoks[i].str] = i;\n            // TODO: use default value?\n            let defvalue;\n            if (this.ifToken('default')) {\n                defvalue = this.parseIntegerConstant();\n            }\n            return { dtype: 'int', lo, hi, defvalue, enums } as IntType;\n        }\n        throw this.compileError(`I expected a data type here.`);\n    }\n\n    parseEnumIdent() {\n        let tok = this.expectTokenTypes([TokenType.Ident]);\n        return tok;\n    }\n    parseEnumValue(tok: Token, field: IntType) {\n        if (!field.enums) throw new ECSError(`field is not an enum`);\n        let value = field.enums[tok.str];\n        if (value == null) throw new ECSError(`unknown enum \"${tok.str}\"`);\n        return value;\n    }\n\n    parseDataValue(field: DataField): DataValue | ForwardRef {\n        let tok = this.peekToken();\n        // TODO: move to expr\n        if (tok.type == TokenType.Ident && field.dtype == 'int') {\n            return this.parseEnumValue(this.consumeToken(), field);\n        }\n        if (tok.type == TokenType.Ident) {\n            let entity = this.currentScope?.getEntityByName(tok.str);\n            if (!entity)\n                this.compileError('no entity named \"${tok.str}\"');\n            else {\n                this.consumeToken();\n                this.expectToken('.');\n                let fieldName = this.expectIdent().str;\n                let constValue = this.currentScope?.getConstValue(entity, fieldName);\n                if (constValue == null)\n                    throw new ECSError(`\"${fieldName}\" is not defined as a constant`, entity);\n                else\n                    return constValue;\n            }\n        }\n        if (tok.str == '[') {\n            // TODO: 16-bit?\n            return new Uint8Array(this.parseDataArray());\n        }\n        if (tok.str == '#') {\n            this.consumeToken();\n            let reftype = field.dtype == 'ref' ? field as RefType : undefined;\n            return this.parseEntityForwardRef(reftype);\n        }\n        // TODO?\n        return this.parseIntegerConstant();\n        // TODO: throw this.compileError(`I expected a ${field.dtype} here.`);\n    }\n\n    parseEntityForwardRef(reftype?: RefType): ForwardRef {\n        let token = this.expectIdent();\n        return { reftype, token };\n    }\n\n    parseDataArray() {\n        this.expectToken('[');\n        let arr = this.parseList(this.parseIntegerConstant, ',');\n        this.expectToken(']');\n        return arr;\n    }\n\n    expectInteger(): number {\n        let s = this.consumeToken().str;\n        let i: number;\n        if (s.startsWith('$'))\n            i = parseInt(s.substring(1), 16); // hex $...\n        else if (s.startsWith('%'))\n            i = parseInt(s.substring(1), 2); // binary %...\n        else\n            i = parseInt(s); // default base 10 or 16 (0x...)\n        if (isNaN(i)) this.compileError('There should be an integer here.');\n        return i;\n    }\n\n    parseSystem(): System {\n        let name = this.expectIdent().str;\n        let actions: Action[] = [];\n        let system: System = { name, actions };\n        let cmd;\n        while ((cmd = this.expectTokens(['on', 'locals', 'end']).str) != 'end') {\n            if (cmd == 'on') {\n                let action = this.annotate(() => this.parseAction(system));\n                actions.push(action);\n            } else if (cmd == 'locals') {\n                system.tempbytes = this.parseIntegerConstant();\n            } else {\n                this.compileError(`Unexpected system keyword: ${cmd}`);\n            }\n        }\n        return system;\n    }\n\n    parseResource(): System {\n        let name = this.expectIdent().str;\n        let tempbytes;\n        if (this.peekToken().str == 'locals') {\n            this.consumeToken();\n            tempbytes = this.parseIntegerConstant();\n        }\n        let system: System = { name, tempbytes, actions: [] };\n        let expr = this.annotate(() => this.parseBlockStatement());\n        let action: Action = { expr, event: name };\n        system.actions.push(action);\n        return system;\n    }\n\n    parseAction(system: System): Action {\n        // TODO: unused events?\n        const event = this.expectIdent().str;\n        this.expectToken('do');\n        let fitbytes = undefined;\n        let critical = undefined;\n        if (this.ifToken('critical')) critical = true;\n        if (this.ifToken('fit')) fitbytes = this.parseIntegerConstant();\n        let expr = this.annotate(() => this.parseBlockStatement());\n        //query, join, select, direction, \n        let action : Action = { expr, event, fitbytes, critical };\n        return action as Action;\n    }\n\n    parseQuery() {\n        let q: Query = { include: [] };\n        let start = this.expectToken('[');\n        this.parseList(() => this.parseQueryItem(q), ',');\n        this.expectToken(']');\n        // TODO: other params\n        q.$loc = mergeLocs(start.$loc, this.lasttoken.$loc);\n        return q;\n    }\n\n    parseQueryItem(q: Query) {\n        let prefix = this.peekToken();\n        if (prefix.type != TokenType.Ident) {\n            this.consumeToken();\n        }\n        if (prefix.type == TokenType.Ident) {\n            let cref = this.parseComponentRef();\n            q.include.push(cref);\n        } else if (prefix.str == '-') {\n            let cref = this.parseComponentRef();\n            if (!q.exclude) q.exclude = [];\n            q.exclude.push(cref);\n        } else if (prefix.str == '#') {\n            const scope = this.currentScope;\n            if (scope == null) {\n                throw this.compileError('You can only reference specific entities inside of a scope.');\n            }\n            let eref = this.parseEntityForwardRef();\n            this.deferred.push(() => {\n                let refvalue = this.resolveEntityRef(scope, eref);\n                if (!q.entities) q.entities = [];\n                q.entities.push(scope.entities[refvalue]);\n            });\n        } else {\n            this.compileError(`Query components may be preceded only by a '-'.`);\n        }\n    }\n\n    parseEventName() {\n        return this.expectIdent().str;\n    }\n\n    parseEventList() {\n        return this.parseList(this.parseEventName, \",\");\n    }\n\n    parseCode(): string { // TODOActionNode[] {\n        // TODO: add $loc\n        let tok = this.expectTokenTypes([ECSTokenType.CodeFragment]);\n        let code = tok.str.substring(3, tok.str.length - 3);\n        // TODO: add after parsing maybe?\n        let lines = code.split('\\n');\n        if (this.includeDebugInfo) this.addDebugInfo(lines, tok.$loc.line);\n        code = lines.join('\\n');\n\n        //let acomp = new ECSActionCompiler(context);\n        //let nodes = acomp.parseFile(code, this.path);\n        // TODO: return nodes\n        return code;\n    }\n\n    addDebugInfo(lines: string[], startline: number) {\n        const re = /^\\s*(;|\\/\\/|$)/; // ignore comments and blank lines\n        for (let i = 0; i < lines.length; i++) {\n            if (!lines[i].match(re))\n                lines[i] = this.em.dialect.debug_line(this.path, startline + i) + '\\n' + lines[i];\n        }\n    }\n\n    parseScope(): EntityScope {\n        let name = this.expectIdent().str;\n        let scope = this.em.newScope(name, this.currentScope || undefined);\n        scope.filePath = this.path;\n        this.currentScope = scope;\n        let cmd;\n        while ((cmd = this.expectTokens(['end', 'using', 'entity', 'scope', 'comment', 'system']).str) != 'end') {\n            if (cmd == 'using') {\n                this.parseScopeUsing();\n            }\n            if (cmd == 'entity') {\n                this.annotate(() => this.parseEntity());\n            }\n            if (cmd == 'scope') {\n                this.annotate(() => this.parseScope());\n            }\n            if (cmd == 'comment') {\n                this.expectTokenTypes([ECSTokenType.CodeFragment]);\n            }\n            // TODO: need to make these local names, otherwise we get \"duplicate name\"\n            if (cmd == 'system') {\n                let sys = this.annotate(() => this.parseSystem());\n                this.em.defineSystem(sys);\n                this.currentScope.newSystemInstanceWithDefaults(sys);\n            }\n        }\n        this.currentScope = scope.parent || null;\n        return scope;\n    }\n\n    parseScopeUsing() {\n        let instlist = this.parseList(this.parseSystemInstanceRef, ',');\n        let params = {};\n        if (this.peekToken().str == 'with') {\n            this.consumeToken();\n            params = this.parseSystemInstanceParameters();\n        }\n        for (let inst of instlist) {\n            inst.params = params;\n            this.currentScope?.newSystemInstance(inst);\n        }\n    }\n\n    parseEntity(): Entity {\n        if (!this.currentScope) { throw this.internalError(); }\n        const scope = this.currentScope;\n        let entname = '';\n        if (this.peekToken().type == TokenType.Ident) {\n            entname = this.expectIdent().str;\n        }\n        let etype = this.parseEntityArchetype();\n        let entity = this.currentScope.newEntity(etype, entname);\n        let cmd2: string;\n        // TODO: remove init?\n        while ((cmd2 = this.expectTokens(['const', 'init', 'var', 'decode', 'end']).str) != 'end') {\n            let cmd = cmd2; // put in scope\n            if (cmd == 'var') cmd = 'init'; // TODO: remove?\n            if (cmd == 'init' || cmd == 'const') {\n                this.parseInitConst(cmd, scope, entity);\n            } else if (cmd == 'decode') {\n                this.parseDecode(scope, entity);\n            }\n        }\n        return entity;\n    }\n\n    parseInitConst(cmd: string, scope: EntityScope, entity: Entity) {\n        // TODO: check data types\n        let name = this.expectIdent().str;\n        let { c, f } = this.getEntityField(entity, name);\n        let symtype = scope.isConstOrInit(c, name);\n        if (symtype && symtype != cmd)\n            this.compileError(`I can't mix const and init values for a given field in a scope.`);\n        this.expectToken('=');\n        let valueOrRef = this.parseDataValue(f);\n        if ((valueOrRef as ForwardRef).token != null) {\n            this.deferred.push(() => {\n                this.lasttoken = (valueOrRef as ForwardRef).token; // for errors\n                let refvalue = this.resolveEntityRef(scope, valueOrRef as ForwardRef);\n                if (cmd == 'const') scope.setConstValue(entity, c, f, refvalue);\n                if (cmd == 'init') scope.setInitValue(entity, c, f, refvalue);\n            });\n        } else {\n            if (cmd == 'const') scope.setConstValue(entity, c, f, valueOrRef as DataValue);\n            if (cmd == 'init') scope.setInitValue(entity, c, f, valueOrRef as DataValue);\n        }\n    }\n\n    parseDecode(scope: EntityScope, entity: Entity) {\n        let decoderid = this.expectIdent().str;\n        let codetok = this.expectTokenTypes([ECSTokenType.CodeFragment]);\n        let code = codetok.str;\n        code = code.substring(3, code.length - 3);\n        let decoder = newDecoder(decoderid, code);\n        if (!decoder) { throw this.compileError(`I can't find a \"${decoderid}\" decoder.`); }\n        let result;\n        try {\n            result = decoder.parse();\n        } catch (e) {\n            throw new ECSError(e.message, decoder.getErrorLocation(codetok.$loc));\n        }\n        for (let entry of Object.entries(result.properties)) {\n            let { c, f } = this.getEntityField(entity, entry[0]);\n            scope.setConstValue(entity, c, f, entry[1] as DataValue);\n        }\n    }\n\n    getEntityField(e: Entity, name: string): ComponentFieldPair {\n        if (!this.currentScope) { throw this.internalError(); }\n        let comps = this.em.componentsWithFieldName([e.etype], name);\n        if (comps.length == 0) this.compileError(`I couldn't find a field named \"${name}\" for this entity.`)\n        if (comps.length > 1) this.compileError(`I found more than one field named \"${name}\" for this entity.`)\n        let component = comps[0];\n        let field = component.fields.find(f => f.name == name);\n        if (!field) { throw this.internalError(); }\n        return { c: component, f: field };\n    }\n\n    parseEntityArchetype(): EntityArchetype {\n        this.expectToken('[');\n        let components = this.parseList(this.parseComponentRef, ',');\n        this.expectToken(']');\n        return { components };\n    }\n\n    parseComponentRef(): ComponentType {\n        let name = this.expectIdent().str;\n        let cref = this.em.getComponentByName(name);\n        if (!cref) this.compileError(`I couldn't find a component named \"${name}\".`)\n        return cref;\n    }\n\n    findEntityByName(scope: EntityScope, token: Token) {\n        let name = token.str;\n        let eref = scope.entities.find(e => e.name == name);\n        if (!eref) {\n            throw this.compileError(`I couldn't find an entity named \"${name}\" in this scope.`, token.$loc)\n        }\n        return eref;\n    }\n\n    resolveEntityRef(scope: EntityScope, ref: ForwardRef): number {\n        let id = this.findEntityByName(scope, ref.token).id;\n        if (ref.reftype) {\n            // TODO: make this a function? elo ehi etc?\n            let atypes = this.em.archetypesMatching(ref.reftype.query);\n            let entities = scope.entitiesMatching(atypes);\n            if (entities.length == 0)\n                throw this.compileError(`This entity doesn't seem to fit the reference type.`, ref.token.$loc);\n            id -= entities[0].id;\n        }\n        return id;\n    }\n\n    parseSystemInstanceRef(): SystemInstance {\n        let name = this.expectIdent().str;\n        let system = this.em.getSystemByName(name);\n        if (!system) throw this.compileError(`I couldn't find a system named \"${name}\".`, this.lasttoken.$loc);\n        let params = {};\n        let inst = { system, params, id: 0 };\n        return inst;\n    }\n\n    parseSystemInstanceParameters(): SystemInstanceParameters {\n        let scope = this.currentScope;\n        if (scope == null) throw this.internalError();\n        if (this.peekToken().str == '[') {\n            return { query: this.parseQuery() };\n        }\n        this.expectToken('#');\n        let entname = this.expectIdent();\n        this.expectToken('.');\n        let fieldname = this.expectIdent();\n        let entity = this.findEntityByName(scope, entname);\n        let cf = this.getEntityField(entity, fieldname.str);\n        return { refEntity: entity, refField: cf };\n    }\n\n    exportToFile(src: SourceFileExport) {\n        this.em.exportToFile(src);\n    }\n\n    export() {\n        let src = new SourceFileExport();\n        src.line(this.em.dialect.debug_file(this.path));\n        for (let path of Object.keys(this.em.imported))\n            src.line(this.em.dialect.debug_file(path));\n        this.exportToFile(src);\n        return src.toString();\n    }\n\n    checkUpperLimit(value: number, upper: number, what: string) {\n        if (value > upper) this.compileError(`This ${what} is too high; must be ${upper} or less`);\n    }\n    checkLowerLimit(value: number, lower: number, what: string) {\n        if (value < lower) this.compileError(`This ${what} is too low; must be ${lower} or more`);\n    }\n\n    // expression stuff\n\n    parseConstant(): DataValue {\n        let expr = this.parseExpr();\n        expr = this.em.evalExpr(expr, this.currentScope);\n        if (isLiteral(expr)) return expr.value;\n        throw this.compileError('This expression is not a constant.');\n    }\n    parseIntegerConstant(): number {\n        let value = this.parseConstant();\n        if (typeof value === 'number') return value;\n        throw this.compileError('This expression is not an integer.');\n    }\n    parseExpr(): Expr {\n        var startloc = this.peekToken().$loc;\n        var expr = this.parseExpr1(this.parsePrimary(), 0);\n        var endloc = this.lasttoken.$loc;\n        expr.$loc = mergeLocs(startloc, endloc);\n        return expr;\n    }\n    parseExpr1(left: Expr, minPred: number): Expr {\n        let look = this.peekToken();\n        while (getPrecedence(look) >= minPred) {\n            let op = this.consumeToken();\n            let right: Expr = this.parsePrimary();\n            look = this.peekToken();\n            while (getPrecedence(look) > getPrecedence(op)) {\n                right = this.parseExpr1(right, getPrecedence(look));\n                look = this.peekToken();\n            }\n            var opfn = getOperator(op.str).f;\n            // use logical operators instead of bitwise?\n            if (op.str == 'and') opfn = 'land';\n            if (op.str == 'or') opfn = 'lor';\n            var valtype = this.exprTypeForOp(opfn, left, right, op);\n            left = { valtype:valtype, op:opfn, left: left, right: right };\n        }\n        return left;\n    }\n    parsePrimary(): Expr {\n        let tok = this.consumeToken();\n        switch (tok.type) {\n            case ECSTokenType.Integer:\n                this.pushbackToken(tok);\n                let value = this.expectInteger();\n                let valtype : IntType = { dtype: 'int', lo: value, hi: value };\n                return { valtype, value };\n            case TokenType.Ident:\n                if (tok.str == 'not') {\n                    let expr = this.parsePrimary();\n                    let valtype : IntType = { dtype: 'int', lo: 0, hi: 1 };\n                    return { valtype, op: 'lnot', expr: expr };\n                } else {\n                    this.pushbackToken(tok);\n                    return this.parseVarSubscriptOrFunc();\n                }\n            case ECSTokenType.Operator:\n                if (tok.str == '(') {\n                    let expr = this.parseExpr();\n                    this.expectToken(')', `There should be another expression or a \")\" here.`);\n                    return expr;\n                } else if (tok.str == '-') {\n                    let expr = this.parsePrimary(); // TODO: -2^2=-4 and -2-2=-4\n                    let valtype = (expr as ExprBase).valtype;\n                    if (valtype?.dtype == 'int') {\n                        let hi = Math.abs(valtype.hi);\n                        let negtype : IntType = { dtype: 'int', lo: -hi, hi: hi };\n                        return { valtype: negtype, op: 'neg', expr: expr };\n                    }\n                } else if (tok.str == '+') {\n                    return this.parsePrimary(); // ignore unary +\n                }\n            default:\n                throw this.compileError(`The expression is incomplete.`);\n        }\n    }\n    parseVarSubscriptOrFunc(): LExpr {\n        var tok = this.consumeToken();\n        switch (tok.type) {\n            case TokenType.Ident:\n                // component:field\n                if (this.ifToken(':')) {\n                    let ftok = this.consumeToken();\n                    let component = this.em.getComponentByName(tok.str);\n                    if (!component) throw this.compileError(`A component named \"${tok.str}\" has not been defined.`);\n                    let field = component.fields.find(f => f.name == ftok.str);\n                    if (!field) throw this.compileError(`There is no \"${ftok.str}\" field in the ${tok.str} component.`);\n                    if (!this.currentScope) throw this.compileError(`This operation only works inside of a scope.`);\n                    let atypes = this.em.archetypesMatching({ include: [component] })\n                    let entities = this.currentScope.entitiesMatching(atypes);\n                    return { entities, field } as EntityFieldOp;\n                }\n                // entity.field\n                if (this.ifToken('.')) {\n                    let ftok = this.consumeToken();\n                    if (!this.currentScope) throw this.compileError(`This operation only works inside of a scope.`);\n                    let entity = this.currentScope.getEntityByName(tok.str);\n                    if (!entity) throw this.compileError(`An entity named \"${tok.str}\" has not been defined.`);\n                    let component = this.em.singleComponentWithFieldName([entity.etype], ftok.str, ftok);\n                    let field = component.fields.find(f => f.name == ftok.str);\n                    if (!field) throw this.compileError(`There is no \"${ftok.str}\" field in this entity.`);\n                    let entities = [entity];\n                    return { entities, field } as EntityFieldOp;\n                }\n                let args : Expr[] = [];\n                if (this.ifToken('(')) {\n                    args = this.parseExprList();\n                    this.expectToken(')', `There should be another expression or a \")\" here.`);\n                }\n                var loc = mergeLocs(tok.$loc, this.lasttoken.$loc);\n                var valtype = this.exprTypeForSubscript(tok.str, args, loc);\n                return { valtype: valtype, name: tok.str, args: args, $loc:loc };\n            default:\n                throw this.compileError(`There should be a variable name here.`);\n        }\n    }\n    parseLexpr(): LExpr {\n        var lexpr = this.parseVarSubscriptOrFunc();\n        //this.vardefs[lexpr.name] = lexpr;\n        //this.validateVarName(lexpr);\n        return lexpr;\n    }\n    exprTypeForOp(fnname: string, left: Expr, right: Expr, optok: Token) : DataType {\n        return { dtype: 'int', lo:0, hi:255 }; // TODO?\n    }\n    exprTypeForSubscript(fnname: string, args: Expr[], loc: SourceLocation) : DataType {\n        return { dtype: 'int', lo:0, hi:255 }; // TODO?\n    }\n    parseLexprList(): LExpr[] {\n        return this.parseList(this.parseLexpr, ',');\n    }\n    parseExprList(): Expr[] {\n        return this.parseList(this.parseExpr, ',');\n    }\n    // TODO: annotate with location\n    parseBlockStatement(): Statement {\n        let valtype : IntType = { dtype:'int', lo:0, hi: 0 } // TODO?\n        if (this.peekToken().type == ECSTokenType.CodeFragment) {\n            return { valtype, code: this.parseCode() };\n        }\n        if (this.ifToken('begin')) {\n            let stmts = [];\n            while (this.peekToken().str != 'end') {\n                stmts.push(this.annotate(() => this.parseBlockStatement()));\n            }\n            this.expectToken('end');\n            return { valtype, stmts };\n        }\n        let cmd = this.peekToken();\n        if (SELECT_TYPE.includes(cmd.str as any)) {\n            return this.parseQueryStatement();\n        }\n        throw this.compileError(`There should be a statement or \"end\" here.`, cmd.$loc);\n    }\n    parseQueryStatement() : QueryExpr {\n        // TODO: include modifiers in error msg\n        const select = this.expectTokens(SELECT_TYPE).str as SelectType; // TODO: type check?\n        let all = this.ifToken('all') != null;\n        let query = undefined;\n        let join = undefined;\n        if (select == 'once') {\n            if (this.peekToken().str == '[') this.compileError(`A \"${select}\" action can't include a query.`)\n        } else {\n            query = this.parseQuery();\n        }\n        if (select == 'join') {\n            this.expectToken('with');\n            join = this.parseQuery();\n        }\n        if (this.ifToken('limit')) {\n            if (!query) { this.compileError(`A \"${select}\" query can't include a limit.`); }\n            else query.limit = this.parseIntegerConstant();\n        }\n        const all_modifiers = ['asc', 'desc']; // TODO\n        const modifiers = this.parseModifiers(all_modifiers);\n        let direction = undefined;\n        if (modifiers['asc']) direction = 'asc';\n        else if (modifiers['desc']) direction = 'desc';\n        let body = this.annotate(() => this.parseBlockStatement());\n        return { select, query, join, direction, all, stmts: [body], loop: select == 'foreach' } as QueryExpr;\n    }\n}\n\n///\n\nexport class ECSActionCompiler extends Tokenizer {\n    constructor(\n        public readonly context: ActionContext) {\n        super();\n        this.setTokenRules([\n            { type: ECSTokenType.Placeholder, regex: /\\{\\{.*?\\}\\}/ },\n            { type: TokenType.CatchAll, regex: /[^{\\n]+\\n*/ },\n        ]);\n        this.errorOnCatchAll = false;\n    }\n\n    parseFile(text: string, path: string) {\n        this.tokenizeFile(text, path);\n        let nodes = [];\n        while (!this.isEOF()) {\n            let tok = this.consumeToken();\n            if (tok.type == ECSTokenType.Placeholder) {\n                let args = tok.str.substring(2, tok.str.length - 2).split(/\\s+/);\n                nodes.push(new CodePlaceholderNode(this.context, tok.$loc, args));\n            } else if (tok.type == TokenType.CatchAll) {\n                nodes.push(new CodeLiteralNode(this.context, tok.$loc, tok.str));\n            }\n        }\n        return nodes;\n    }\n}\n", "import { ECSCompiler } from \"../../common/ecs/compiler\";\nimport { Dialect_CA65, ECSError, EntityManager } from \"../../common/ecs/ecs\";\nimport { CompileError } from \"../../common/tokenizer\";\nimport { CodeListingMap } from \"../../common/workertypes\";\nimport { BuildStep, BuildStepResult, fixParamsWithDefines, gatherFiles, getWorkFileAsString, putWorkFile, staleFiles } from \"../workermain\";\n\nexport function assembleECS(step: BuildStep): BuildStepResult {\n    let em = new EntityManager(new Dialect_CA65()); // TODO\n    let compiler = new ECSCompiler(em, true);\n    compiler.getImportFile = (path: string) => {\n        return getWorkFileAsString(path);\n    }\n    gatherFiles(step, { mainFilePath: \"main.ecs\" });\n    if (step.mainfile) em.mainPath = step.path;\n    var destpath = step.prefix + '.ca65';\n    if (staleFiles(step, [destpath])) {\n        let code = getWorkFileAsString(step.path);\n        fixParamsWithDefines(step.path, step.params);\n        try {\n            compiler.includeDebugInfo = true;\n            compiler.parseFile(code, step.path);\n            let outtext = compiler.export().toString();\n            putWorkFile(destpath, outtext);\n            var listings: CodeListingMap = {};\n            listings[destpath] = {lines:[], text:outtext} // TODO\n            var debuginfo = compiler.em.getDebugTree();\n        } catch (e) {\n            if (e instanceof ECSError) {\n                compiler.addError(e.message, e.$loc);\n                for (let obj of e.$sources) {\n                    let name = (obj as any).event;\n                    if (name == 'start') break;\n                    compiler.addError(`... ${name}`, obj.$loc); // TODO?\n                }\n                return { errors: compiler.errors };\n            } else if (e instanceof CompileError) {\n                return { errors: compiler.errors };\n            } else {\n                throw e;\n            }\n        }\n        return {\n            nexttool: \"ca65\",\n            path: destpath,\n            args: [destpath],\n            files: [destpath].concat(step.files),\n            listings,\n            debuginfo\n        };\n    }\n}\n", "\nimport type { WorkerResult, WorkerBuildStep, WorkerMessage, WorkerError, SourceLine, WorkerErrorResult, WorkingStore } from \"../common/workertypes\";\nimport { getBasePlatform, getRootBasePlatform } from \"../common/util\";\n\n/// <reference types=\"emscripten\" />\nexport interface EmscriptenModule {\n  callMain: (args: string[]) => void;\n  FS : any; // TODO\n}\n\ndeclare function importScripts(path:string);\ndeclare function postMessage(msg);\n\nconst ENVIRONMENT_IS_WEB = typeof window === 'object';\nconst ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\nexport const emglobal : any = ENVIRONMENT_IS_WORKER ? self : ENVIRONMENT_IS_WEB ? window : global;\n\n// simple CommonJS module loader\n// TODO: relative paths for dependencies\nif (!emglobal['require']) {\n  emglobal['require'] = (modpath: string) => {\n    if (modpath.endsWith('.js')) modpath = modpath.slice(-3);\n    var modname = modpath.split('/').slice(-1)[0];\n    var hasNamespace = emglobal[modname] != null;\n    console.log('@@@ require', modname, modpath, hasNamespace);\n    if (!hasNamespace) {\n      exports = {};\n      importScripts(`${modpath}.js`);\n    }\n    if (emglobal[modname] == null) {\n      emglobal[modname] = exports; // TODO: always put in global scope?\n    }\n    return emglobal[modname]; // TODO\n  }\n}\n\n// WebAssembly module cache\n// TODO: leaks memory even when disabled...\nvar _WASM_module_cache = {};\nvar CACHE_WASM_MODULES = true; // if false, use asm.js only\n\n// TODO: which modules need this?\nvar wasmMemory;\nexport function getWASMMemory() {\n    if (wasmMemory == null) {\n      wasmMemory = new WebAssembly.Memory({\n        'initial': 1024,  // 64MB\n        'maximum': 16384, // 1024MB\n      });\n    }\n    return wasmMemory;\n}\n\nfunction getWASMModule(module_id:string) {\n  var module = _WASM_module_cache[module_id];\n  if (!module) {\n    starttime();\n    module = new WebAssembly.Module(wasmBlob[module_id]);\n    if (CACHE_WASM_MODULES) {\n      _WASM_module_cache[module_id] = module;\n      delete wasmBlob[module_id];\n    }\n    endtime(\"module creation \" + module_id);\n  }\n  return module;\n}\n// function for use with instantiateWasm\nexport function moduleInstFn(module_id:string) {\n  return function(imports,ri) {\n    var mod = getWASMModule(module_id);\n    var inst = new WebAssembly.Instance(mod, imports);\n    ri(inst);\n    return inst.exports;\n  }\n}\n\n//\n\nvar PLATFORM_PARAMS = {\n  'vcs': {\n    arch: '6502',\n    code_start: 0x1000,\n    code_size: 0xf000,\n    data_start: 0x80,\n    data_size: 0x80,\n    wiz_rom_ext: '.a26',\n    wiz_inc_dir: '2600',\n    extra_link_files: ['atari2600.cfg'],\n    cfgfile: 'atari2600.cfg',\n  },\n  'mw8080bw': {\n    arch: 'z80',\n    code_start: 0x0,\n    rom_size: 0x2000,\n    data_start: 0x2000,\n    data_size: 0x400,\n    stack_end: 0x2400,\n  },\n  'vicdual': {\n    arch: 'z80',\n    code_start: 0x0,\n    rom_size: 0x4020,\n    data_start: 0xe400,\n    data_size: 0x400,\n    stack_end: 0xe800,\n  },\n  'galaxian': {\n    arch: 'z80',\n    code_start: 0x0,\n    rom_size: 0x4000,\n    data_start: 0x4000,\n    data_size: 0x400,\n    stack_end: 0x4800,\n  },\n  'galaxian-scramble': {\n    arch: 'z80',\n    code_start: 0x0,\n    rom_size: 0x5020,\n    data_start: 0x4000,\n    data_size: 0x400,\n    stack_end: 0x4800,\n  },\n  'williams': {\n    arch: '6809',\n    code_start: 0x0,\n    rom_size: 0xc000,\n    data_start: 0x9800,\n    data_size: 0x2800,\n    stack_end: 0xc000,\n    set_stack_end: 0xc000,\n    extra_link_files: ['williams.scr', 'libcmoc-crt-vec.a', 'libcmoc-std-vec.a'],\n    extra_link_args: ['-swilliams.scr', '-lcmoc-crt-vec', '-lcmoc-std-vec'],\n    extra_compile_files: ['assert.h','cmoc.h','stdarg.h','stdlib.h'],\n    //extra_compile_args: ['--vectrex'],\n  },\n  'williams-defender': {\n    arch: '6809',\n    code_start: 0x0,\n    rom_size: 0xc000,\n    data_start: 0x9800,\n    data_size: 0x2800,\n    stack_end: 0xc000,\n  },\n  'williams-z80': {\n    arch: 'z80',\n    code_start: 0x0,\n    rom_size: 0x9800,\n    data_start: 0x9800,\n    data_size: 0x2800,\n    stack_end: 0xc000,\n  },\n  'vector-z80color': {\n    arch: 'z80',\n    code_start: 0x0,\n    rom_size: 0x8000,\n    data_start: 0xe000,\n    data_size: 0x2000,\n    stack_end: 0x0,\n  },\n  'vector-ataricolor': { //TODO\n    arch: '6502',\n    define: ['__VECTOR__'],\n    cfgfile: 'vector-color.cfg',\n    libargs: ['crt0.o', 'none.lib'],\n    extra_link_files: ['crt0.o', 'vector-color.cfg'],\n  },\n  'sound_williams-z80': {\n    arch: 'z80',\n    code_start: 0x0,\n    rom_size: 0x4000,\n    data_start: 0x4000,\n    data_size: 0x400,\n    stack_end: 0x8000,\n  },\n  'base_z80': {\n    arch: 'z80',\n    code_start: 0x0,\n    rom_size: 0x8000,\n    data_start: 0x8000,\n    data_size: 0x8000,\n    stack_end: 0x0,\n  },\n  'coleco': {\n    arch: 'z80',\n    rom_start: 0x8000,\n    code_start: 0x8100,\n    rom_size: 0x8000,\n    data_start: 0x7000,\n    data_size: 0x400,\n    stack_end: 0x8000,\n    extra_preproc_args: ['-I', '/share/include/coleco', '-D', 'CV_CV'],\n    extra_link_args: ['-k', '/share/lib/coleco', '-l', 'libcv', '-l', 'libcvu', 'crt0.rel'],\n  },\n  'msx': {\n    arch: 'z80',\n    rom_start: 0x4000,\n    code_start: 0x4000,\n    rom_size: 0x8000,\n    data_start: 0xc000,\n    data_size: 0x3000,\n    stack_end: 0xffff,\n    extra_link_args: ['crt0-msx.rel'],\n    extra_link_files: ['crt0-msx.rel', 'crt0-msx.lst'],\n    wiz_sys_type: 'z80',\n    wiz_inc_dir: 'msx',\n  },\n  'msx-libcv': {\n    arch: 'z80',\n    rom_start: 0x4000,\n    code_start: 0x4000,\n    rom_size: 0x8000,\n    data_start: 0xc000,\n    data_size: 0x3000,\n    stack_end: 0xffff,\n    extra_preproc_args: ['-I', '.', '-D', 'CV_MSX'],\n    extra_link_args: ['-k', '.', '-l', 'libcv-msx', '-l', 'libcvu-msx', 'crt0-msx.rel'],\n    extra_link_files: ['libcv-msx.lib', 'libcvu-msx.lib', 'crt0-msx.rel', 'crt0-msx.lst'],\n    extra_compile_files: ['cv.h','cv_graphics.h','cv_input.h','cv_sound.h','cv_support.h','cvu.h','cvu_c.h','cvu_compression.h','cvu_f.h','cvu_graphics.h','cvu_input.h','cvu_sound.h'],\n  },\n  'sms-sg1000-libcv': {\n    arch: 'z80',\n    rom_start: 0x0000,\n    code_start: 0x0100,\n    rom_size: 0xc000,\n    data_start: 0xc000,\n    data_size: 0x400,\n    stack_end: 0xe000,\n    extra_preproc_args: ['-I', '.', '-D', 'CV_SMS'],\n    extra_link_args: ['-k', '.', '-l', 'libcv-sms', '-l', 'libcvu-sms', 'crt0-sms.rel'],\n    extra_link_files: ['libcv-sms.lib', 'libcvu-sms.lib', 'crt0-sms.rel', 'crt0-sms.lst'],\n    extra_compile_files: ['cv.h','cv_graphics.h','cv_input.h','cv_sound.h','cv_support.h','cvu.h','cvu_c.h','cvu_compression.h','cvu_f.h','cvu_graphics.h','cvu_input.h','cvu_sound.h'],\n  },\n  'nes': { //TODO\n    arch: '6502',\n    define: ['__NES__'],\n    cfgfile: 'neslib2.cfg',\n    libargs: ['crt0.o', 'nes.lib', 'neslib2.lib',\n      '-D', 'NES_MAPPER=0', // NROM\n      '-D', 'NES_PRG_BANKS=2', // 2 16K PRG banks\n      '-D', 'NES_CHR_BANKS=1', // 1 CHR bank\n      '-D', 'NES_MIRRORING=0', // horizontal mirroring\n      ],\n    extra_link_files: ['crt0.o', 'neslib2.lib', 'neslib2.cfg', 'nesbanked.cfg'],\n    wiz_rom_ext: '.nes',\n  },\n  'apple2': {\n    arch: '6502',\n    define: ['__APPLE2__'],\n    cfgfile: 'apple2.cfg',\n    libargs: [ '--lib-path', '/share/target/apple2/drv', '-D', '__EXEHDR__=0', 'apple2.lib'],\n    __CODE_RUN__: 16384,\n    code_start: 0x803,\n  },\n  'apple2-e': {\n    arch: '6502',\n    define: ['__APPLE2__'],\n    cfgfile: 'apple2.cfg',\n    libargs: ['apple2.lib'],\n  },\n  'atari8-800xl.disk': {\n    arch: '6502',\n    define: ['__ATARI__'],\n    cfgfile: 'atari.cfg',\n    libargs: ['atari.lib'],\n    fastbasic_cfgfile: 'fastbasic-cart.cfg',\n  },\n  'atari8-800xl': {\n    arch: '6502',\n    define: ['__ATARI__'],\n    cfgfile: 'atari-cart.cfg',\n    libargs: ['atari.lib', '-D', '__CARTFLAGS__=4'],\n    fastbasic_cfgfile: 'fastbasic-cart.cfg',\n  },\n  'atari8-800': {\n    arch: '6502',\n    define: ['__ATARI__'],\n    cfgfile: 'atari-cart.cfg',\n    libargs: ['atari.lib', '-D', '__CARTFLAGS__=4'],\n    fastbasic_cfgfile: 'fastbasic-cart.cfg',\n  },\n  'atari8-5200': {\n    arch: '6502',\n    define: ['__ATARI5200__'],\n    cfgfile: 'atari5200.cfg',\n    libargs: ['atari5200.lib', '-D', '__CARTFLAGS__=255'],\n    fastbasic_cfgfile: 'fastbasic-cart.cfg',\n  },\n  'verilog': {\n    arch: 'verilog',\n    extra_compile_files: ['8bitworkshop.v'],\n  },\n  'astrocade': {\n    arch: 'z80',\n    code_start: 0x2000,\n      rom_size: 0x2000,\n    data_start: 0x4e10,\n     data_size: 0x1f0,\n     stack_end: 0x5000,\n  },\n  'astrocade-arcade': {\n    arch: 'z80',\n    code_start: 0x0000,\n      rom_size: 0x4000,\n    data_start: 0x7de0,\n     data_size: 0x220,\n     stack_end: 0x8000,\n  },\n  'astrocade-bios': {\n    arch: 'z80',\n    code_start: 0x0000,\n      rom_size: 0x2000,\n    data_start: 0x4fce,\n     data_size: 50,\n     stack_end: 0x4fce,\n  },\n  'atari7800': {\n    arch: '6502',\n    define: ['__ATARI7800__'],\n    cfgfile: 'atari7800.cfg',\n    libargs: ['crt0.o', 'none.lib'],\n    extra_link_files: ['crt0.o', 'atari7800.cfg'],\n  },\n  'c64': {\n    arch: '6502',\n    define: ['__CBM__', '__C64__'],\n    cfgfile: 'c64.cfg', // SYS 2061\n    libargs: ['c64.lib'],\n    //extra_link_files: ['c64-cart.cfg'],\n  },\n  'vic20': {\n    arch: '6502',\n    define: ['__CBM__', '__VIC20__'],\n    cfgfile: 'vic20.cfg',\n    libargs: ['vic20.lib'],\n    //extra_link_files: ['c64-cart.cfg'],\n  },\n  'kim1': {\n    arch: '6502',\n  },\n  'vectrex': {\n    arch: '6809',\n    code_start: 0x0,\n    rom_size: 0x8000,\n    data_start: 0xc880,\n    data_size: 0x380,\n    stack_end: 0xcc00,\n    extra_compile_files: ['assert.h','cmoc.h','stdarg.h','vectrex.h','stdlib.h','bios.h'],\n    extra_link_files: ['vectrex.scr', 'libcmoc-crt-vec.a', 'libcmoc-std-vec.a'],\n    extra_compile_args: ['--vectrex'],\n    extra_link_args: ['-svectrex.scr', '-lcmoc-crt-vec', '-lcmoc-std-vec'],\n  },\n  'x86': {    \n    arch: 'x86',\n  },\n  'zx': {\n    arch: 'z80',\n    code_start: 0x5ccb,\n    rom_size: 0xff58-0x5ccb,\n    data_start: 0xf000,\n    data_size: 0xfe00-0xf000,\n    stack_end: 0xff58,\n    extra_link_args: ['crt0-zx.rel'],\n    extra_link_files: ['crt0-zx.rel', 'crt0-zx.lst'],\n  },\n  'devel-6502': {\n    arch: '6502',\n    cfgfile: 'devel-6502.cfg',\n    libargs: ['crt0.o', 'none.lib'],\n    extra_link_files: ['crt0.o', 'devel-6502.cfg'],\n  },\n  // https://github.com/cpcitor/cpc-dev-tool-chain\n  'cpc.rslib': {\n    arch: 'z80',\n    code_start: 0x4000,\n    rom_size: 0xb100-0x4000,\n    data_start: 0xb100,\n    data_size: 0xb100-0xc000,\n    stack_end: 0xc000,\n    extra_compile_files: ['cpcrslib.h'],\n    extra_link_args: ['crt0-cpc.rel', 'cpcrslib.lib'],\n    extra_link_files: ['crt0-cpc.rel', 'crt0-cpc.lst', 'cpcrslib.lib', 'cpcrslib.lst'],\n  },\n  // https://lronaldo.github.io/cpctelera/ (TODO)\n  'cpc': {\n    arch: 'z80',\n    code_start: 0x4000,\n    rom_size: 0xb100-0x4000,\n    data_start: 0xb100,\n    data_size: 0xb100-0xc000,\n    stack_end: 0xc000,\n    extra_compile_files: ['cpctelera.h'],\n    extra_link_args: ['crt0-cpc.rel', 'cpctelera.lib'],\n    extra_link_files: ['crt0-cpc.rel', 'crt0-cpc.lst', 'cpctelera.lib', 'cpctelera.lst'],\n  },\n};\n\nPLATFORM_PARAMS['sms-sms-libcv'] = PLATFORM_PARAMS['sms-sg1000-libcv'];\nPLATFORM_PARAMS['sms-gg-libcv'] = PLATFORM_PARAMS['sms-sms-libcv'];\n\nvar _t1;\nexport function starttime() { _t1 = new Date(); }\nexport function endtime(msg) { var _t2 = new Date(); console.log(msg, _t2.getTime() - _t1.getTime(), \"ms\"); }\n\n/// working file store and build steps\n\ntype FileData = string | Uint8Array;\n\ntype FileEntry = {\n  path: string\n  encoding: string\n  data: FileData\n  ts: number\n};\n\ntype BuildOptions = {\n  mainFilePath : string,\n  processFn?: (s:string, d:FileData) => FileData\n};\n\n// TODO\nexport type BuildStepResult = WorkerResult | WorkerNextToolResult;\n\nexport interface WorkerNextToolResult {\n  nexttool?: string\n  linktool?: string\n  path?: string\n  args: string[]\n  files: string[]\n  bblines?: boolean\n}\n\nexport interface BuildStep extends WorkerBuildStep {\n  files? : string[]\n  args? : string[]\n  nextstep? : BuildStep\n  linkstep? : BuildStep\n  params?\n  result? : BuildStepResult\n  code?\n  prefix?\n  maxts?\n  debuginfo?\n};\n\n///\n\nexport class FileWorkingStore implements WorkingStore {\n  workfs : {[path:string]:FileEntry} = {};\n  workerseq : number = 0;\n  items : {};\n\n  constructor() {\n    this.reset();\n  }\n  reset() {\n    this.workfs = {};\n    this.newVersion();\n  }\n  currentVersion() {\n    return this.workerseq;\n  }\n  newVersion() {\n    let ts = new Date().getTime();\n    if (ts <= this.workerseq)\n      ts = ++this.workerseq;\n    return ts;\n  }\n  putFile(path:string, data:FileData) : FileEntry {\n    var encoding = (typeof data === 'string') ? 'utf8' : 'binary';\n    var entry = this.workfs[path];\n    if (!entry || !compareData(entry.data, data) || entry.encoding != encoding) {\n      this.workfs[path] = entry = {path:path, data:data, encoding:encoding, ts:this.newVersion()};\n      console.log('+++', entry.path, entry.encoding, entry.data.length, entry.ts);\n    }\n    return entry;\n  }\n  hasFile(path: string) {\n    return this.workfs[path] != null;\n  }\n  getFileData(path:string) : FileData {\n    return this.workfs[path] && this.workfs[path].data;\n  }  \n  getFileAsString(path:string) : string {\n    let data = this.getFileData(path);\n    if (data != null && typeof data !== 'string')\n      throw new Error(`${path}: expected string`)\n    return data as string; // TODO\n  }\n  getFileEntry(path:string) : FileEntry {\n    return this.workfs[path];\n  }\n  setItem(key: string, value: object) {\n    this.items[key] = value;\n  }\n}\n\nexport var store = new FileWorkingStore();\n\n///\n\nfunction errorResult(msg: string) : WorkerErrorResult {\n  return { errors:[{ line:0, msg:msg }]};\n}\n\nclass Builder {\n  steps : BuildStep[] = [];\n  startseq : number = 0;\n\n  // returns true if file changed during this build step\n  wasChanged(entry:FileEntry) : boolean {\n    return entry.ts > this.startseq;\n  }\n  async executeBuildSteps() : Promise<WorkerResult> {\n    this.startseq = store.currentVersion();\n    var linkstep : BuildStep = null;\n    while (this.steps.length) {\n      var step = this.steps.shift(); // get top of array\n      var platform = step.platform;\n      var toolfn = TOOLS[step.tool];\n      if (!toolfn) throw Error(\"no tool named \" + step.tool);\n      step.params = PLATFORM_PARAMS[getBasePlatform(platform)];\n      try {\n        step.result = await toolfn(step);\n      } catch (e) {\n        console.log(\"EXCEPTION\", e, e.stack);\n        return errorResult(e+\"\"); // TODO: catch errors already generated?\n      }\n      if (step.result) {\n        (step.result as any).params = step.params; // TODO: type check\n        if (step.debuginfo) {\n          let r = step.result as any; // TODO\n          if (!r.debuginfo) r.debuginfo = {};\n          Object.assign(r.debuginfo, step.debuginfo);\n        }\n        // errors? return them\n        if ('errors' in step.result && step.result.errors.length) {\n          applyDefaultErrorPath(step.result.errors, step.path);\n          return step.result;\n        }\n        // if we got some output, return it immediately\n        if ('output' in step.result && step.result.output) {\n          return step.result;\n        }\n        // combine files with a link tool?\n        if ('linktool' in step.result) {\n          // add to existing link step\n          if (linkstep) {\n            linkstep.files = linkstep.files.concat(step.result.files);\n            linkstep.args = linkstep.args.concat(step.result.args);\n          } else {\n            linkstep = {\n              tool:step.result.linktool,\n              platform:platform,\n              files:step.result.files,\n              args:step.result.args\n            };\n          }\n          linkstep.debuginfo = step.debuginfo; // TODO: multiple debuginfos\n        }\n        // process with another tool?\n        if ('nexttool' in step.result) {\n          var asmstep : BuildStep = {\n            tool: step.result.nexttool,\n            platform: platform,\n            ...step.result\n          }\n          this.steps.push(asmstep);\n        }\n        // process final step?\n        if (this.steps.length == 0 && linkstep) {\n          this.steps.push(linkstep);\n          linkstep = null;\n        }\n      }\n    }\n  }\n  async handleMessage(data: WorkerMessage) : Promise<WorkerResult> {\n    this.steps = [];\n    // file updates\n    if (data.updates) {\n      data.updates.forEach((u) => store.putFile(u.path, u.data));\n    }\n    // object update\n    if (data.setitems) {\n      data.setitems.forEach((i) => store.setItem(i.key, i.value));\n    }\n    // build steps\n    if (data.buildsteps) {\n      this.steps.push.apply(this.steps, data.buildsteps);\n    }\n    // single-file\n    if (data.code) {\n      this.steps.push(data as BuildStep); // TODO: remove cast\n    }\n    // execute build steps\n    if (this.steps.length) {\n      var result = await this.executeBuildSteps();\n      return result ? result : {unchanged:true};\n    }\n    // TODO: cache results\n    // message not recognized\n    console.log(\"Unknown message\",data);\n  }\n}\n\nvar builder = new Builder();\n\n///\n\nfunction applyDefaultErrorPath(errors:WorkerError[], path:string) {\n  if (!path) return;\n  for (var i=0; i<errors.length; i++) {\n    var err = errors[i];\n    if (!err.path && err.line) err.path = path;\n  }\n}\n\nfunction compareData(a:FileData, b:FileData) : boolean {\n  if (a.length != b.length) return false;\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a == b;\n  } else {\n    for (var i=0; i<a.length; i++) {\n      //if (a[i] != b[i]) console.log('differ at byte',i,a[i],b[i]);\n      if (a[i] != b[i]) return false;\n    }\n    return true;\n  }\n}\n\nexport function putWorkFile(path:string, data:FileData) {\n  return store.putFile(path, data);\n}\n\nexport function getWorkFileAsString(path:string) : string {\n  return store.getFileAsString(path);\n}\n\nexport function populateEntry(fs, path:string, entry:FileEntry, options:BuildOptions) {\n  var data = entry.data;\n  if (options && options.processFn) {\n    data = options.processFn(path, data);\n  }\n  // create subfolders\n  var toks = path.split('/');\n  if (toks.length > 1) {\n    for (var i=0; i<toks.length-1; i++)\n      try {\n        fs.mkdir(toks[i]);\n      } catch (e) { }\n  }\n  // write file\n  fs.writeFile(path, data, {encoding:entry.encoding});\n  var time = new Date(entry.ts);\n  fs.utime(path, time, time);\n  console.log(\"<<<\", path, entry.data.length);\n}\n\n// can call multiple times (from populateFiles)\nexport function gatherFiles(step:BuildStep, options?:BuildOptions) : number {\n  var maxts = 0;\n  if (step.files) {\n    for (var i=0; i<step.files.length; i++) {\n      var path = step.files[i];\n      var entry = store.workfs[path];\n      if (!entry) {\n        throw new Error(\"No entry for path '\" + path + \"'\");\n      } else {\n        maxts = Math.max(maxts, entry.ts);\n      }\n    }\n  }\n  else if (step.code) {\n    var path = step.path ? step.path : options.mainFilePath; // TODO: what if options null\n    if (!path) throw Error(\"need path or mainFilePath\");\n    var code = step.code;\n    var entry = putWorkFile(path, code);\n    step.path = path;\n    step.files = [path];\n    maxts = entry.ts;\n  }\n  else if (step.path) {\n    var path = step.path;\n    var entry = store.workfs[path];\n    maxts = entry.ts;\n    step.files = [path];\n  }\n  if (step.path && !step.prefix) {\n    step.prefix = getPrefix(step.path);\n  }\n  step.maxts = maxts;\n  return maxts;\n}\n\nexport function getPrefix(s : string) : string {\n  var pos = s.lastIndexOf('.');\n  return (pos > 0) ? s.substring(0, pos) : s;\n}\n\nexport function populateFiles(step:BuildStep, fs, options?:BuildOptions) {\n  gatherFiles(step, options);\n  if (!step.files) throw Error(\"call gatherFiles() first\");\n  for (var i=0; i<step.files.length; i++) {\n    var path = step.files[i];\n    populateEntry(fs, path, store.workfs[path], options);\n  }\n}\n\nexport function populateExtraFiles(step:BuildStep, fs, extrafiles) {\n  if (extrafiles) {\n    for (var i=0; i<extrafiles.length; i++) {\n      var xfn = extrafiles[i];\n      // is this file cached?\n      if (store.workfs[xfn]) {\n        fs.writeFile(xfn, store.workfs[xfn].data, {encoding:'binary'});\n        continue;\n      }\n      // fetch from network\n      var xpath = \"lib/\" + getBasePlatform(step.platform) + \"/\" + xfn;\n      var xhr = new XMLHttpRequest();\n      xhr.responseType = 'arraybuffer';\n      xhr.open(\"GET\", PWORKER+xpath, false);  // synchronous request\n      xhr.send(null);\n      if (xhr.response && xhr.status == 200) {\n        var data = new Uint8Array(xhr.response);\n        fs.writeFile(xfn, data, {encoding:'binary'});\n        putWorkFile(xfn, data);\n        console.log(\":::\",xfn,data.length);\n      } else {\n        throw Error(\"Could not load extra file \" + xpath);\n      }\n    }\n  }\n}\n\nexport function staleFiles(step:BuildStep, targets:string[]) {\n  if (!step.maxts) throw Error(\"call populateFiles() first\");\n  // see if any target files are more recent than inputs\n  for (var i=0; i<targets.length; i++) {\n    var entry = store.workfs[targets[i]];\n    if (!entry || step.maxts > entry.ts)\n      return true;\n  }\n  console.log(\"unchanged\", step.maxts, targets);\n  return false;\n}\n\nexport function anyTargetChanged(step:BuildStep, targets:string[]) {\n  if (!step.maxts) throw Error(\"call populateFiles() first\");\n  // see if any target files are more recent than inputs\n  for (var i=0; i<targets.length; i++) {\n    var entry = store.workfs[targets[i]];\n    if (!entry || entry.ts > step.maxts)\n      return true;\n  }\n  console.log(\"unchanged\", step.maxts, targets);\n  return false;\n}\n\nexport function execMain(step:BuildStep, mod, args:string[]) {\n  starttime();\n  var run = mod.callMain || mod.run; // TODO: run?\n  run(args);\n  endtime(step.tool);\n}\n\n/// asm.js / WASM / filesystem loading\n\nvar fsMeta = {};\nvar fsBlob = {};\nvar wasmBlob = {};\n\nconst PSRC = \"../../src/\";\nconst PWORKER = PSRC+\"worker/\";\n\n// load filesystems for CC65 and others asynchronously\nfunction loadFilesystem(name:string) {\n  var xhr = new XMLHttpRequest();\n  xhr.responseType = 'blob';\n  xhr.open(\"GET\", PWORKER+\"fs/fs\"+name+\".data\", false);  // synchronous request\n  xhr.send(null);\n  fsBlob[name] = xhr.response;\n  xhr = new XMLHttpRequest();\n  xhr.responseType = 'json';\n  xhr.open(\"GET\", PWORKER+\"fs/fs\"+name+\".js.metadata\", false);  // synchronous request\n  xhr.send(null);\n  fsMeta[name] = xhr.response;\n  console.log(\"Loaded \"+name+\" filesystem\", fsMeta[name].files.length, 'files', fsBlob[name].size, 'bytes');\n}\n\nvar loaded = {};\nexport function load(modulename:string, debug?:boolean) {\n  if (!loaded[modulename]) {\n    importScripts(PWORKER+'asmjs/'+modulename+(debug?\".\"+debug+\".js\":\".js\"));\n    loaded[modulename] = 1;\n  }\n}\nexport function loadWASM(modulename:string, debug?:boolean) {\n  if (!loaded[modulename]) {\n    importScripts(PWORKER+\"wasm/\" + modulename+(debug?\".\"+debug+\".js\":\".js\"));\n    var xhr = new XMLHttpRequest();\n    xhr.responseType = 'arraybuffer';\n    xhr.open(\"GET\", PWORKER+\"wasm/\"+modulename+\".wasm\", false);  // synchronous request\n    xhr.send(null);\n    if (xhr.response) {\n      wasmBlob[modulename] = new Uint8Array(xhr.response);\n      console.log(\"Loaded \" + modulename + \".wasm (\" + wasmBlob[modulename].length + \" bytes)\");\n      loaded[modulename] = 1;\n    } else {\n      throw Error(\"Could not load WASM file \" + modulename + \".wasm\");\n    }\n  }\n}\nexport function loadNative(modulename:string) {\n  // detect WASM\n  if (CACHE_WASM_MODULES && typeof WebAssembly === 'object') {\n    loadWASM(modulename);\n  } else {\n    load(modulename);\n  }\n}\n\n// mount the filesystem at /share\nexport function setupFS(FS, name:string) {\n  var WORKERFS = FS.filesystems['WORKERFS'];\n  if (name === '65-vector') name = '65-none'; // TODO\n  if (name === '65-atari7800') name = '65-none'; // TODO\n  if (name === '65-devel') name = '65-none'; // TODO\n  if (name === '65-vcs') name = '65-none'; // TODO\n  if (!fsMeta[name]) throw Error(\"No filesystem for '\" + name + \"'\");\n  FS.mkdir('/share');\n  FS.mount(WORKERFS, {\n    packages: [{ metadata: fsMeta[name], blob: fsBlob[name] }]\n  }, '/share');\n  // fix for slow Blob operations by caching typed arrays\n  // https://github.com/kripken/emscripten/blob/incoming/src/library_workerfs.js\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=349304#c30\n  var reader = WORKERFS.reader;\n  var blobcache = {};\n  WORKERFS.stream_ops.read = function (stream, buffer, offset, length, position) {\n    if (position >= stream.node.size) return 0;\n    var contents = blobcache[stream.path];\n    if (!contents) {\n      var ab = reader.readAsArrayBuffer(stream.node.contents);\n      contents = blobcache[stream.path] = new Uint8Array(ab);\n    }\n    if (position + length > contents.length)\n      length = contents.length - position;\n    for (var i=0; i<length; i++) {\n      buffer[offset+i] = contents[position+i];\n    }\n    return length;\n  };\n}\n\nexport var print_fn = function(s:string) {\n  console.log(s);\n  //console.log(new Error().stack);\n}\n\n// test.c(6) : warning 85: in function main unreferenced local variable : 'x'\n// main.a (4): error: Unknown Mnemonic 'xxx'.\n// at 2: warning 190: ISO C forbids an empty source file\nexport const re_msvc  = /[/]*([^( ]+)\\s*[(](\\d+)[)]\\s*:\\s*(.+?):\\s*(.*)/;\nexport const re_msvc2 = /\\s*(at)\\s+(\\d+)\\s*(:)\\s*(.*)/;\n\nexport function msvcErrorMatcher(errors:WorkerError[]) {\n  return function(s:string) {\n    var matches = re_msvc.exec(s) || re_msvc2.exec(s);\n    if (matches) {\n      var errline = parseInt(matches[2]);\n      errors.push({\n        line:errline,\n        path:matches[1],\n        //type:matches[3],\n        msg:matches[4]\n      });\n    } else {\n      console.log(s);\n    }\n  }\n}\n\nexport function makeErrorMatcher(errors:WorkerError[], regex, iline:number, imsg:number, mainpath:string, ifilename?:number) {\n  return function(s) {\n    var matches = regex.exec(s);\n    if (matches) {\n      errors.push({\n        line:parseInt(matches[iline]) || 1,\n        msg:matches[imsg],\n        path:ifilename ? matches[ifilename] : mainpath\n      });\n    } else {\n      console.log(\"??? \"+s);\n    }\n  }\n}\n\nexport function extractErrors(regex, strings:string[], path:string, iline, imsg, ifilename) {\n  var errors = [];\n  var matcher = makeErrorMatcher(errors, regex, iline, imsg, path, ifilename);\n  for (var i=0; i<strings.length; i++) {\n    matcher(strings[i]);\n  }\n  return errors;\n}\n\nexport const re_crlf = /\\r?\\n/;\n//    1   %line 16+1 hello.asm\nexport const re_lineoffset = /\\s*(\\d+)\\s+[%]line\\s+(\\d+)\\+(\\d+)\\s+(.+)/;\n\nexport function parseListing(code:string,\n  lineMatch, iline:number, ioffset:number, iinsns:number, icycles?:number,\n  funcMatch?, segMatch?) : SourceLine[] {\n  var lines : SourceLine[] = [];\n  var lineofs = 0;\n  var segment = '';\n  var func = '';\n  var funcbase = 0;\n  code.split(re_crlf).forEach((line, lineindex) => {\n    let segm = segMatch && segMatch.exec(line);\n    if (segm) { segment = segm[1]; }\n    let funcm = funcMatch && funcMatch.exec(line);\n    if (funcm) { funcbase = parseInt(funcm[1],16); func = funcm[2]; }\n\n    var linem = lineMatch.exec(line);\n    if (linem && linem[1]) {\n      var linenum = iline < 0 ? lineindex : parseInt(linem[iline]);\n      var offset = parseInt(linem[ioffset], 16);\n      var insns = linem[iinsns];\n      var cycles : number = icycles ? parseInt(linem[icycles]) : null;\n      var iscode = cycles > 0;\n      if (insns) {\n        lines.push({\n          line: linenum + lineofs,\n          offset: offset - funcbase,\n          insns,\n          cycles,\n          iscode,\n          segment,\n          func\n        });\n      }\n    } else {\n      let m = re_lineoffset.exec(line);\n      // TODO: check filename too\n      if (m) {\n        lineofs = parseInt(m[2]) - parseInt(m[1]) - parseInt(m[3]);\n      }\n    }\n  });\n  return lines;\n}\n\nexport function parseSourceLines(code:string, lineMatch, offsetMatch, funcMatch?, segMatch?) {\n  var lines = [];\n  var lastlinenum = 0;\n  var segment = '';\n  var func = '';\n  var funcbase = 0;\n  for (var line of code.split(re_crlf)) {\n    let segm = segMatch && segMatch.exec(line);\n    if (segm) { segment = segm[1]; }\n    let funcm = funcMatch && funcMatch.exec(line);\n    if (funcm) { funcbase = parseInt(funcm[1],16); func = funcm[2]; }\n    \n    var linem = lineMatch.exec(line);\n    if (linem && linem[1]) {\n      lastlinenum = parseInt(linem[1]);\n    } else if (lastlinenum) {\n      var linem = offsetMatch.exec(line);\n      if (linem && linem[1]) {\n        var offset = parseInt(linem[1], 16);\n        lines.push({\n          line: lastlinenum,\n          offset: offset - funcbase,\n          segment,\n          func\n        });\n        lastlinenum = 0;\n      }\n    }\n  }\n  return lines;\n}\n\nexport function setupStdin(fs, code:string) {\n  var i = 0;\n  fs.init(\n    function() { return i<code.length ? code.charCodeAt(i++) : null; }\n  );\n}\n\nexport function fixParamsWithDefines(path:string, params){\n  var libargs = params.libargs;\n  if (path && libargs) {\n    var code = getWorkFileAsString(path);\n    if (code) {\n      var oldcfgfile = params.cfgfile;\n      var ident2index = {};\n      // find all lib args \"IDENT=VALUE\"\n      for (var i=0; i<libargs.length; i++) {\n        var toks = libargs[i].split('=');\n        if (toks.length == 2) {\n          ident2index[toks[0]] = i;\n        }\n      }\n      // find #defines and replace them\n      var re = /^[;]?#define\\s+(\\w+)\\s+(\\S+)/gmi; // TODO: empty string?\n      var m;\n      while (m = re.exec(code)) {\n        var ident = m[1];\n        var value = m[2];\n        var index = ident2index[ident];\n        if (index >= 0) {\n          libargs[index] = ident + \"=\" + value;\n          console.log('Using libargs', index, libargs[index]);\n          // TODO: MMC3 mapper switch\n          if (ident == 'NES_MAPPER' && value == '4') {\n            params.cfgfile = 'nesbanked.cfg';\n            console.log(\"using config file\", params.cfgfile);\n          }\n        } else if (ident == 'CFGFILE' && value) {\n          params.cfgfile = value;\n        } else if (ident == 'LIBARGS' && value) {\n          params.libargs = value.split(',').filter((s) => { return s!=''; });\n          console.log('Using libargs', params.libargs);\n        } else if (ident == 'CC65_FLAGS' && value) {\n          params.extra_compiler_args = value.split(',').filter((s) => { return s!=''; });\n          console.log('Using compiler flags', params.extra_compiler_args);\n        }\n      }\n    }\n  }\n}\n\n\nfunction makeCPPSafe(s:string) : string {\n  return s.replace(/[^A-Za-z0-9_]/g,'_');\n}\n\nexport function preprocessMCPP(step:BuildStep, filesys:string) {\n  load(\"mcpp\");\n  var platform = step.platform;\n  var params = PLATFORM_PARAMS[getBasePlatform(platform)];\n  if (!params) throw Error(\"Platform not supported: \" + platform);\n  // <stdin>:2: error: Can't open include file \"foo.h\"\n  var errors = [];\n  var match_fn = makeErrorMatcher(errors, /<stdin>:(\\d+): (.+)/, 1, 2, step.path);\n  var MCPP : EmscriptenModule = emglobal.mcpp({\n    noInitialRun:true,\n    noFSInit:true,\n    print:print_fn,\n    printErr:match_fn,\n  });\n  var FS = MCPP.FS;\n  if (filesys) setupFS(FS, filesys);\n  populateFiles(step, FS);\n  populateExtraFiles(step, FS, params.extra_compile_files);\n  // TODO: make configurable by other compilers\n  var args = [\n    \"-D\", \"__8BITWORKSHOP__\",\n    \"-D\", \"__SDCC_z80\",\n    \"-D\", makeCPPSafe(platform.toUpperCase()),\n    \"-I\", \"/share/include\",\n    \"-Q\",\n    step.path, \"main.i\"];\n  if (step.mainfile) {\n    args.unshift.apply(args, [\"-D\", \"__MAIN__\"]);\n  }\n  let platform_def = (platform.toUpperCase() as any).replaceAll(/[^a-zA-Z0-9]/g,'_');\n  args.unshift.apply(args, [\"-D\", `__PLATFORM_${platform_def}__`]);\n  if (params.extra_preproc_args) {\n    args.push.apply(args, params.extra_preproc_args);\n  }\n  execMain(step, MCPP, args);\n  if (errors.length)\n    return {errors:errors};\n  var iout = FS.readFile(\"main.i\", {encoding:'utf8'});\n  iout = iout.replace(/^#line /gm,'\\n# ');\n  try {\n    var errout = FS.readFile(\"mcpp.err\", {encoding:'utf8'});\n    if (errout.length) {\n      // //main.c:2: error: Can't open include file \"stdiosd.h\"\n      var errors = extractErrors(/([^:]+):(\\d+): (.+)/, errout.split(\"\\n\"), step.path, 2, 3, 1);\n      if (errors.length == 0) {\n        errors = errorResult(errout).errors;\n      }\n      return {errors: errors};\n    }\n  } catch (e) {\n    //\n  }\n  return {code:iout};\n}\n\nexport function setupRequireFunction() {\n  var exports = {};\n  exports['jsdom'] = {\n    JSDOM: function(a,b) {\n      this.window = {};\n    }\n  };\n  emglobal['require'] = (modname:string) => {\n    console.log('require',modname,exports[modname]!=null);\n    return exports[modname];\n  }\n}\n\n////////////////////////////\n\nimport * as misc from './tools/misc'\nimport * as cc65 from './tools/cc65'\nimport * as dasm from './tools/dasm'\nimport * as sdcc from './tools/sdcc'\nimport * as verilog from './tools/verilog'\nimport * as m6809 from './tools/m6809'\nimport * as m6502 from './tools/m6502'\nimport * as z80 from './tools/z80'\nimport * as x86 from './tools/x86'\nimport * as arm from './tools/arm'\nimport * as script from './tools/script'\nimport * as ecs from './tools/ecs'\n\nvar TOOLS = {\n  'dasm': dasm.assembleDASM,\n  //'acme': assembleACME,\n  //'plasm': compilePLASMA,\n  'cc65': cc65.compileCC65,\n  'ca65': cc65.assembleCA65,\n  'ld65': cc65.linkLD65,\n  //'z80asm': assembleZ80ASM,\n  //'sccz80': compileSCCZ80,\n  'sdasz80': sdcc.assembleSDASZ80,\n  'sdldz80': sdcc.linkSDLDZ80,\n  'sdcc': sdcc.compileSDCC,\n  'xasm6809': m6809.assembleXASM6809,\n  'cmoc': m6809.compileCMOC,\n  'lwasm': m6809.assembleLWASM,\n  'lwlink': m6809.linkLWLINK,\n  //'naken': assembleNAKEN,\n  'verilator': verilog.compileVerilator,\n  'yosys': verilog.compileYosys,\n  'jsasm': verilog.compileJSASMStep,\n  'zmac': z80.assembleZMAC,\n  'nesasm': m6502.assembleNESASM,\n  'smlrc': x86.compileSmallerC,\n  'yasm': x86.assembleYASM,\n  'bataribasic': dasm.compileBatariBasic,\n  'markdown': misc.translateShowdown,\n  'inform6': misc.compileInform6,\n  'merlin32': m6502.assembleMerlin32,\n  'fastbasic': m6502.compileFastBasic,\n  'basic': misc.compileBASIC,\n  'silice': verilog.compileSilice,\n  'wiz': misc.compileWiz,\n  'armips': arm.assembleARMIPS,\n  'vasmarm': arm.assembleVASMARM,\n  //'js': script.runJavascript,\n  'ecs': ecs.assembleECS,\n}\n\nvar TOOL_PRELOADFS = {\n  'cc65-apple2': '65-apple2',\n  'ca65-apple2': '65-apple2',\n  'cc65-c64': '65-c64',\n  'ca65-c64': '65-c64',\n  'cc65-vic20': '65-vic20',\n  'ca65-vic20': '65-vic20',\n  'cc65-nes': '65-nes',\n  'ca65-nes': '65-nes',\n  'cc65-atari8': '65-atari8',\n  'ca65-atari8': '65-atari8',\n  'cc65-vector': '65-none',\n  'ca65-vector': '65-none',\n  'cc65-atari7800': '65-none',\n  'ca65-atari7800': '65-none',\n  'cc65-devel': '65-none',\n  'ca65-devel': '65-none',\n  'ca65-vcs': '65-none',\n  'sdasz80': 'sdcc',\n  'sdcc': 'sdcc',\n  'sccz80': 'sccz80',\n  'bataribasic': '2600basic',\n  'inform6': 'inform',\n  'fastbasic': '65-atari8',\n  'silice': 'Silice',\n  'wiz': 'wiz',\n  'ecs-vcs': '65-none', // TODO: support multiple platforms\n  'ecs-nes': '65-nes', // TODO: support multiple platforms\n  'ecs-c64': '65-c64', // TODO: support multiple platforms\n}\n\n//const waitFor = delay => new Promise(resolve => setTimeout(resolve, delay)); // for testing\n\nasync function handleMessage(data : WorkerMessage) : Promise<WorkerResult> {\n  // preload file system\n  if (data.preload) {\n    var fs = TOOL_PRELOADFS[data.preload];\n    if (!fs && data.platform)\n      fs = TOOL_PRELOADFS[data.preload+'-'+getBasePlatform(data.platform)];\n    if (!fs && data.platform)\n      fs = TOOL_PRELOADFS[data.preload+'-'+getRootBasePlatform(data.platform)];\n    if (fs && !fsMeta[fs])\n      loadFilesystem(fs);\n    return;\n  }\n  // clear filesystem? (TODO: buildkey)\n  if (data.reset) {\n    store.reset();\n    return;\n  }\n  return builder.handleMessage(data);\n}\n\nif (ENVIRONMENT_IS_WORKER) {\n  var lastpromise = null;\n  onmessage = async function(e) {\n    await lastpromise; // wait for previous message to complete\n    lastpromise = handleMessage(e.data);\n    var result = await lastpromise;\n    lastpromise = null;\n    if (result) {\n      try {\n        postMessage(result);\n      } catch (e) {\n        console.log(e);\n        postMessage(errorResult(`${e}`));\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
